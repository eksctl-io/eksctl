// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/aws/aws-sdk-go/service/cloudformation"
	"github.com/aws/aws-sdk-go/service/cloudtrail"
	"github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
	"github.com/weaveworks/eksctl/pkg/cfn/builder"
	"github.com/weaveworks/eksctl/pkg/cfn/manager"
	iamoidc "github.com/weaveworks/eksctl/pkg/iam/oidc"
	"github.com/weaveworks/eksctl/pkg/kubernetes"
	"github.com/weaveworks/eksctl/pkg/utils/tasks"
)

type FakeStackManager struct {
	AppendNewClusterStackResourceStub        func(bool, bool) (bool, error)
	appendNewClusterStackResourceMutex       sync.RWMutex
	appendNewClusterStackResourceArgsForCall []struct {
		arg1 bool
		arg2 bool
	}
	appendNewClusterStackResourceReturns struct {
		result1 bool
		result2 error
	}
	appendNewClusterStackResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateStackStub        func(string, builder.ResourceSet, map[string]string, map[string]string, chan error) error
	createStackMutex       sync.RWMutex
	createStackArgsForCall []struct {
		arg1 string
		arg2 builder.ResourceSet
		arg3 map[string]string
		arg4 map[string]string
		arg5 chan error
	}
	createStackReturns struct {
		result1 error
	}
	createStackReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStackByNameStub        func(string) (*cloudformation.Stack, error)
	deleteStackByNameMutex       sync.RWMutex
	deleteStackByNameArgsForCall []struct {
		arg1 string
	}
	deleteStackByNameReturns struct {
		result1 *cloudformation.Stack
		result2 error
	}
	deleteStackByNameReturnsOnCall map[int]struct {
		result1 *cloudformation.Stack
		result2 error
	}
	DeleteStackByNameSyncStub        func(string) error
	deleteStackByNameSyncMutex       sync.RWMutex
	deleteStackByNameSyncArgsForCall []struct {
		arg1 string
	}
	deleteStackByNameSyncReturns struct {
		result1 error
	}
	deleteStackByNameSyncReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStackBySpecStub        func(*cloudformation.Stack) (*cloudformation.Stack, error)
	deleteStackBySpecMutex       sync.RWMutex
	deleteStackBySpecArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	deleteStackBySpecReturns struct {
		result1 *cloudformation.Stack
		result2 error
	}
	deleteStackBySpecReturnsOnCall map[int]struct {
		result1 *cloudformation.Stack
		result2 error
	}
	DeleteStackBySpecSyncStub        func(*cloudformation.Stack, chan error) error
	deleteStackBySpecSyncMutex       sync.RWMutex
	deleteStackBySpecSyncArgsForCall []struct {
		arg1 *cloudformation.Stack
		arg2 chan error
	}
	deleteStackBySpecSyncReturns struct {
		result1 error
	}
	deleteStackBySpecSyncReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTasksForDeprecatedStacksStub        func() (*tasks.TaskTree, error)
	deleteTasksForDeprecatedStacksMutex       sync.RWMutex
	deleteTasksForDeprecatedStacksArgsForCall []struct {
	}
	deleteTasksForDeprecatedStacksReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	deleteTasksForDeprecatedStacksReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	DescribeClusterStackStub        func() (*cloudformation.Stack, error)
	describeClusterStackMutex       sync.RWMutex
	describeClusterStackArgsForCall []struct {
	}
	describeClusterStackReturns struct {
		result1 *cloudformation.Stack
		result2 error
	}
	describeClusterStackReturnsOnCall map[int]struct {
		result1 *cloudformation.Stack
		result2 error
	}
	DescribeIAMServiceAccountStacksStub        func() ([]*cloudformation.Stack, error)
	describeIAMServiceAccountStacksMutex       sync.RWMutex
	describeIAMServiceAccountStacksArgsForCall []struct {
	}
	describeIAMServiceAccountStacksReturns struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	describeIAMServiceAccountStacksReturnsOnCall map[int]struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	DescribeNodeGroupStackStub        func(string) (*cloudformation.Stack, error)
	describeNodeGroupStackMutex       sync.RWMutex
	describeNodeGroupStackArgsForCall []struct {
		arg1 string
	}
	describeNodeGroupStackReturns struct {
		result1 *cloudformation.Stack
		result2 error
	}
	describeNodeGroupStackReturnsOnCall map[int]struct {
		result1 *cloudformation.Stack
		result2 error
	}
	DescribeNodeGroupStacksStub        func() ([]*cloudformation.Stack, error)
	describeNodeGroupStacksMutex       sync.RWMutex
	describeNodeGroupStacksArgsForCall []struct {
	}
	describeNodeGroupStacksReturns struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	describeNodeGroupStacksReturnsOnCall map[int]struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	DescribeNodeGroupStacksAndResourcesStub        func() (map[string]manager.StackInfo, error)
	describeNodeGroupStacksAndResourcesMutex       sync.RWMutex
	describeNodeGroupStacksAndResourcesArgsForCall []struct {
	}
	describeNodeGroupStacksAndResourcesReturns struct {
		result1 map[string]manager.StackInfo
		result2 error
	}
	describeNodeGroupStacksAndResourcesReturnsOnCall map[int]struct {
		result1 map[string]manager.StackInfo
		result2 error
	}
	DescribeStackStub        func(*cloudformation.Stack) (*cloudformation.Stack, error)
	describeStackMutex       sync.RWMutex
	describeStackArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	describeStackReturns struct {
		result1 *cloudformation.Stack
		result2 error
	}
	describeStackReturnsOnCall map[int]struct {
		result1 *cloudformation.Stack
		result2 error
	}
	DescribeStackChangeSetStub        func(*cloudformation.Stack, string) (*cloudformation.DescribeChangeSetOutput, error)
	describeStackChangeSetMutex       sync.RWMutex
	describeStackChangeSetArgsForCall []struct {
		arg1 *cloudformation.Stack
		arg2 string
	}
	describeStackChangeSetReturns struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}
	describeStackChangeSetReturnsOnCall map[int]struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}
	DescribeStackEventsStub        func(*cloudformation.Stack) ([]*cloudformation.StackEvent, error)
	describeStackEventsMutex       sync.RWMutex
	describeStackEventsArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	describeStackEventsReturns struct {
		result1 []*cloudformation.StackEvent
		result2 error
	}
	describeStackEventsReturnsOnCall map[int]struct {
		result1 []*cloudformation.StackEvent
		result2 error
	}
	DescribeStacksStub        func() ([]*cloudformation.Stack, error)
	describeStacksMutex       sync.RWMutex
	describeStacksArgsForCall []struct {
	}
	describeStacksReturns struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	describeStacksReturnsOnCall map[int]struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	DoCreateStackRequestStub        func(*cloudformation.Stack, manager.TemplateData, map[string]string, map[string]string, bool, bool) error
	doCreateStackRequestMutex       sync.RWMutex
	doCreateStackRequestArgsForCall []struct {
		arg1 *cloudformation.Stack
		arg2 manager.TemplateData
		arg3 map[string]string
		arg4 map[string]string
		arg5 bool
		arg6 bool
	}
	doCreateStackRequestReturns struct {
		result1 error
	}
	doCreateStackRequestReturnsOnCall map[int]struct {
		result1 error
	}
	DoWaitUntilStackIsCreatedStub        func(*cloudformation.Stack) error
	doWaitUntilStackIsCreatedMutex       sync.RWMutex
	doWaitUntilStackIsCreatedArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	doWaitUntilStackIsCreatedReturns struct {
		result1 error
	}
	doWaitUntilStackIsCreatedReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureMapPublicIPOnLaunchEnabledStub        func() error
	ensureMapPublicIPOnLaunchEnabledMutex       sync.RWMutex
	ensureMapPublicIPOnLaunchEnabledArgsForCall []struct {
	}
	ensureMapPublicIPOnLaunchEnabledReturns struct {
		result1 error
	}
	ensureMapPublicIPOnLaunchEnabledReturnsOnCall map[int]struct {
		result1 error
	}
	ErrStackNotFoundStub        func() error
	errStackNotFoundMutex       sync.RWMutex
	errStackNotFoundArgsForCall []struct {
	}
	errStackNotFoundReturns struct {
		result1 error
	}
	errStackNotFoundReturnsOnCall map[int]struct {
		result1 error
	}
	FixClusterCompatibilityStub        func() error
	fixClusterCompatibilityMutex       sync.RWMutex
	fixClusterCompatibilityArgsForCall []struct {
	}
	fixClusterCompatibilityReturns struct {
		result1 error
	}
	fixClusterCompatibilityReturnsOnCall map[int]struct {
		result1 error
	}
	GetAutoScalingGroupNameStub        func(*cloudformation.Stack) (string, error)
	getAutoScalingGroupNameMutex       sync.RWMutex
	getAutoScalingGroupNameArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	getAutoScalingGroupNameReturns struct {
		result1 string
		result2 error
	}
	getAutoScalingGroupNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetFargateStackStub        func() (*cloudformation.Stack, error)
	getFargateStackMutex       sync.RWMutex
	getFargateStackArgsForCall []struct {
	}
	getFargateStackReturns struct {
		result1 *cloudformation.Stack
		result2 error
	}
	getFargateStackReturnsOnCall map[int]struct {
		result1 *cloudformation.Stack
		result2 error
	}
	GetIAMAddonNameStub        func(*cloudformation.Stack) string
	getIAMAddonNameMutex       sync.RWMutex
	getIAMAddonNameArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	getIAMAddonNameReturns struct {
		result1 string
	}
	getIAMAddonNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetIAMAddonsStacksStub        func() ([]*cloudformation.Stack, error)
	getIAMAddonsStacksMutex       sync.RWMutex
	getIAMAddonsStacksArgsForCall []struct {
	}
	getIAMAddonsStacksReturns struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	getIAMAddonsStacksReturnsOnCall map[int]struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	GetIAMServiceAccountsStub        func() ([]*v1alpha5.ClusterIAMServiceAccount, error)
	getIAMServiceAccountsMutex       sync.RWMutex
	getIAMServiceAccountsArgsForCall []struct {
	}
	getIAMServiceAccountsReturns struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}
	getIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}
	GetManagedNodeGroupAutoScalingGroupNameStub        func(*cloudformation.Stack) (string, error)
	getManagedNodeGroupAutoScalingGroupNameMutex       sync.RWMutex
	getManagedNodeGroupAutoScalingGroupNameArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	getManagedNodeGroupAutoScalingGroupNameReturns struct {
		result1 string
		result2 error
	}
	getManagedNodeGroupAutoScalingGroupNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetManagedNodeGroupTemplateStub        func(string) (string, error)
	getManagedNodeGroupTemplateMutex       sync.RWMutex
	getManagedNodeGroupTemplateArgsForCall []struct {
		arg1 string
	}
	getManagedNodeGroupTemplateReturns struct {
		result1 string
		result2 error
	}
	getManagedNodeGroupTemplateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetNodeGroupAutoScalingGroupNameStub        func(*cloudformation.Stack) (string, error)
	getNodeGroupAutoScalingGroupNameMutex       sync.RWMutex
	getNodeGroupAutoScalingGroupNameArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	getNodeGroupAutoScalingGroupNameReturns struct {
		result1 string
		result2 error
	}
	getNodeGroupAutoScalingGroupNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetNodeGroupNameStub        func(*cloudformation.Stack) string
	getNodeGroupNameMutex       sync.RWMutex
	getNodeGroupNameArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	getNodeGroupNameReturns struct {
		result1 string
	}
	getNodeGroupNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetNodeGroupStackTypeStub        func(string) (v1alpha5.NodeGroupType, error)
	getNodeGroupStackTypeMutex       sync.RWMutex
	getNodeGroupStackTypeArgsForCall []struct {
		arg1 string
	}
	getNodeGroupStackTypeReturns struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}
	getNodeGroupStackTypeReturnsOnCall map[int]struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}
	GetNodeGroupSummariesStub        func(string) ([]*manager.NodeGroupSummary, error)
	getNodeGroupSummariesMutex       sync.RWMutex
	getNodeGroupSummariesArgsForCall []struct {
		arg1 string
	}
	getNodeGroupSummariesReturns struct {
		result1 []*manager.NodeGroupSummary
		result2 error
	}
	getNodeGroupSummariesReturnsOnCall map[int]struct {
		result1 []*manager.NodeGroupSummary
		result2 error
	}
	GetStackTemplateStub        func(string) (string, error)
	getStackTemplateMutex       sync.RWMutex
	getStackTemplateArgsForCall []struct {
		arg1 string
	}
	getStackTemplateReturns struct {
		result1 string
		result2 error
	}
	getStackTemplateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HasClusterStackStub        func() (bool, error)
	hasClusterStackMutex       sync.RWMutex
	hasClusterStackArgsForCall []struct {
	}
	hasClusterStackReturns struct {
		result1 bool
		result2 error
	}
	hasClusterStackReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	HasClusterStackUsingCachedListStub        func([]string) (bool, error)
	hasClusterStackUsingCachedListMutex       sync.RWMutex
	hasClusterStackUsingCachedListArgsForCall []struct {
		arg1 []string
	}
	hasClusterStackUsingCachedListReturns struct {
		result1 bool
		result2 error
	}
	hasClusterStackUsingCachedListReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListClusterStackNamesStub        func() ([]string, error)
	listClusterStackNamesMutex       sync.RWMutex
	listClusterStackNamesArgsForCall []struct {
	}
	listClusterStackNamesReturns struct {
		result1 []string
		result2 error
	}
	listClusterStackNamesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListIAMServiceAccountStacksStub        func() ([]string, error)
	listIAMServiceAccountStacksMutex       sync.RWMutex
	listIAMServiceAccountStacksArgsForCall []struct {
	}
	listIAMServiceAccountStacksReturns struct {
		result1 []string
		result2 error
	}
	listIAMServiceAccountStacksReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListNodeGroupStacksStub        func() ([]manager.NodeGroupStack, error)
	listNodeGroupStacksMutex       sync.RWMutex
	listNodeGroupStacksArgsForCall []struct {
	}
	listNodeGroupStacksReturns struct {
		result1 []manager.NodeGroupStack
		result2 error
	}
	listNodeGroupStacksReturnsOnCall map[int]struct {
		result1 []manager.NodeGroupStack
		result2 error
	}
	ListStacksStub        func(...string) ([]*cloudformation.Stack, error)
	listStacksMutex       sync.RWMutex
	listStacksArgsForCall []struct {
		arg1 []string
	}
	listStacksReturns struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	listStacksReturnsOnCall map[int]struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	ListStacksMatchingStub        func(string, ...string) ([]*cloudformation.Stack, error)
	listStacksMatchingMutex       sync.RWMutex
	listStacksMatchingArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	listStacksMatchingReturns struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	listStacksMatchingReturnsOnCall map[int]struct {
		result1 []*cloudformation.Stack
		result2 error
	}
	LookupCloudTrailEventsStub        func(*cloudformation.Stack) ([]*cloudtrail.Event, error)
	lookupCloudTrailEventsMutex       sync.RWMutex
	lookupCloudTrailEventsArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	lookupCloudTrailEventsReturns struct {
		result1 []*cloudtrail.Event
		result2 error
	}
	lookupCloudTrailEventsReturnsOnCall map[int]struct {
		result1 []*cloudtrail.Event
		result2 error
	}
	MakeChangeSetNameStub        func(string) string
	makeChangeSetNameMutex       sync.RWMutex
	makeChangeSetNameArgsForCall []struct {
		arg1 string
	}
	makeChangeSetNameReturns struct {
		result1 string
	}
	makeChangeSetNameReturnsOnCall map[int]struct {
		result1 string
	}
	NewClusterCompatTaskStub        func() tasks.Task
	newClusterCompatTaskMutex       sync.RWMutex
	newClusterCompatTaskArgsForCall []struct {
	}
	newClusterCompatTaskReturns struct {
		result1 tasks.Task
	}
	newClusterCompatTaskReturnsOnCall map[int]struct {
		result1 tasks.Task
	}
	NewManagedNodeGroupTaskStub        func([]*v1alpha5.ManagedNodeGroup, bool) *tasks.TaskTree
	newManagedNodeGroupTaskMutex       sync.RWMutex
	newManagedNodeGroupTaskArgsForCall []struct {
		arg1 []*v1alpha5.ManagedNodeGroup
		arg2 bool
	}
	newManagedNodeGroupTaskReturns struct {
		result1 *tasks.TaskTree
	}
	newManagedNodeGroupTaskReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	NewTaskToDeleteAddonIAMStub        func(bool) (*tasks.TaskTree, error)
	newTaskToDeleteAddonIAMMutex       sync.RWMutex
	newTaskToDeleteAddonIAMArgsForCall []struct {
		arg1 bool
	}
	newTaskToDeleteAddonIAMReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTaskToDeleteAddonIAMReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToCreateClusterWithNodeGroupsStub        func([]*v1alpha5.NodeGroup, []*v1alpha5.ManagedNodeGroup, bool, ...tasks.Task) *tasks.TaskTree
	newTasksToCreateClusterWithNodeGroupsMutex       sync.RWMutex
	newTasksToCreateClusterWithNodeGroupsArgsForCall []struct {
		arg1 []*v1alpha5.NodeGroup
		arg2 []*v1alpha5.ManagedNodeGroup
		arg3 bool
		arg4 []tasks.Task
	}
	newTasksToCreateClusterWithNodeGroupsReturns struct {
		result1 *tasks.TaskTree
	}
	newTasksToCreateClusterWithNodeGroupsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	NewTasksToCreateIAMServiceAccountsStub        func([]*v1alpha5.ClusterIAMServiceAccount, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) *tasks.TaskTree
	newTasksToCreateIAMServiceAccountsMutex       sync.RWMutex
	newTasksToCreateIAMServiceAccountsArgsForCall []struct {
		arg1 []*v1alpha5.ClusterIAMServiceAccount
		arg2 *iamoidc.OpenIDConnectManager
		arg3 kubernetes.ClientSetGetter
	}
	newTasksToCreateIAMServiceAccountsReturns struct {
		result1 *tasks.TaskTree
	}
	newTasksToCreateIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	NewTasksToDeleteClusterWithNodeGroupsStub        func(bool, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter, bool, func(chan error, string) error) (*tasks.TaskTree, error)
	newTasksToDeleteClusterWithNodeGroupsMutex       sync.RWMutex
	newTasksToDeleteClusterWithNodeGroupsArgsForCall []struct {
		arg1 bool
		arg2 *iamoidc.OpenIDConnectManager
		arg3 kubernetes.ClientSetGetter
		arg4 bool
		arg5 func(chan error, string) error
	}
	newTasksToDeleteClusterWithNodeGroupsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteClusterWithNodeGroupsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToDeleteIAMServiceAccountsStub        func(func(string) bool, kubernetes.ClientSetGetter, bool) (*tasks.TaskTree, error)
	newTasksToDeleteIAMServiceAccountsMutex       sync.RWMutex
	newTasksToDeleteIAMServiceAccountsArgsForCall []struct {
		arg1 func(string) bool
		arg2 kubernetes.ClientSetGetter
		arg3 bool
	}
	newTasksToDeleteIAMServiceAccountsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToDeleteNodeGroupsStub        func(func(string) bool, bool, func(chan error, string) error) (*tasks.TaskTree, error)
	newTasksToDeleteNodeGroupsMutex       sync.RWMutex
	newTasksToDeleteNodeGroupsArgsForCall []struct {
		arg1 func(string) bool
		arg2 bool
		arg3 func(chan error, string) error
	}
	newTasksToDeleteNodeGroupsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteNodeGroupsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub        func(*iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) (*tasks.TaskTree, error)
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex       sync.RWMutex
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall []struct {
		arg1 *iamoidc.OpenIDConnectManager
		arg2 kubernetes.ClientSetGetter
	}
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewUnmanagedNodeGroupTaskStub        func([]*v1alpha5.NodeGroup, bool, bool) *tasks.TaskTree
	newUnmanagedNodeGroupTaskMutex       sync.RWMutex
	newUnmanagedNodeGroupTaskArgsForCall []struct {
		arg1 []*v1alpha5.NodeGroup
		arg2 bool
		arg3 bool
	}
	newUnmanagedNodeGroupTaskReturns struct {
		result1 *tasks.TaskTree
	}
	newUnmanagedNodeGroupTaskReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	RefreshFargatePodExecutionRoleARNStub        func() error
	refreshFargatePodExecutionRoleARNMutex       sync.RWMutex
	refreshFargatePodExecutionRoleARNArgsForCall []struct {
	}
	refreshFargatePodExecutionRoleARNReturns struct {
		result1 error
	}
	refreshFargatePodExecutionRoleARNReturnsOnCall map[int]struct {
		result1 error
	}
	ScaleNodeGroupStub        func(*v1alpha5.NodeGroup) error
	scaleNodeGroupMutex       sync.RWMutex
	scaleNodeGroupArgsForCall []struct {
		arg1 *v1alpha5.NodeGroup
	}
	scaleNodeGroupReturns struct {
		result1 error
	}
	scaleNodeGroupReturnsOnCall map[int]struct {
		result1 error
	}
	StackStatusIsNotReadyStub        func(*cloudformation.Stack) bool
	stackStatusIsNotReadyMutex       sync.RWMutex
	stackStatusIsNotReadyArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	stackStatusIsNotReadyReturns struct {
		result1 bool
	}
	stackStatusIsNotReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	StackStatusIsNotTransitionalStub        func(*cloudformation.Stack) bool
	stackStatusIsNotTransitionalMutex       sync.RWMutex
	stackStatusIsNotTransitionalArgsForCall []struct {
		arg1 *cloudformation.Stack
	}
	stackStatusIsNotTransitionalReturns struct {
		result1 bool
	}
	stackStatusIsNotTransitionalReturnsOnCall map[int]struct {
		result1 bool
	}
	UpdateNodeGroupStackStub        func(string, string) error
	updateNodeGroupStackMutex       sync.RWMutex
	updateNodeGroupStackArgsForCall []struct {
		arg1 string
		arg2 string
	}
	updateNodeGroupStackReturns struct {
		result1 error
	}
	updateNodeGroupStackReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStackStub        func(string, string, string, manager.TemplateData, map[string]string) error
	updateStackMutex       sync.RWMutex
	updateStackArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 manager.TemplateData
		arg5 map[string]string
	}
	updateStackReturns struct {
		result1 error
	}
	updateStackReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStackManager) AppendNewClusterStackResource(arg1 bool, arg2 bool) (bool, error) {
	fake.appendNewClusterStackResourceMutex.Lock()
	ret, specificReturn := fake.appendNewClusterStackResourceReturnsOnCall[len(fake.appendNewClusterStackResourceArgsForCall)]
	fake.appendNewClusterStackResourceArgsForCall = append(fake.appendNewClusterStackResourceArgsForCall, struct {
		arg1 bool
		arg2 bool
	}{arg1, arg2})
	stub := fake.AppendNewClusterStackResourceStub
	fakeReturns := fake.appendNewClusterStackResourceReturns
	fake.recordInvocation("AppendNewClusterStackResource", []interface{}{arg1, arg2})
	fake.appendNewClusterStackResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) AppendNewClusterStackResourceCallCount() int {
	fake.appendNewClusterStackResourceMutex.RLock()
	defer fake.appendNewClusterStackResourceMutex.RUnlock()
	return len(fake.appendNewClusterStackResourceArgsForCall)
}

func (fake *FakeStackManager) AppendNewClusterStackResourceCalls(stub func(bool, bool) (bool, error)) {
	fake.appendNewClusterStackResourceMutex.Lock()
	defer fake.appendNewClusterStackResourceMutex.Unlock()
	fake.AppendNewClusterStackResourceStub = stub
}

func (fake *FakeStackManager) AppendNewClusterStackResourceArgsForCall(i int) (bool, bool) {
	fake.appendNewClusterStackResourceMutex.RLock()
	defer fake.appendNewClusterStackResourceMutex.RUnlock()
	argsForCall := fake.appendNewClusterStackResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) AppendNewClusterStackResourceReturns(result1 bool, result2 error) {
	fake.appendNewClusterStackResourceMutex.Lock()
	defer fake.appendNewClusterStackResourceMutex.Unlock()
	fake.AppendNewClusterStackResourceStub = nil
	fake.appendNewClusterStackResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) AppendNewClusterStackResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.appendNewClusterStackResourceMutex.Lock()
	defer fake.appendNewClusterStackResourceMutex.Unlock()
	fake.AppendNewClusterStackResourceStub = nil
	if fake.appendNewClusterStackResourceReturnsOnCall == nil {
		fake.appendNewClusterStackResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.appendNewClusterStackResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) CreateStack(arg1 string, arg2 builder.ResourceSet, arg3 map[string]string, arg4 map[string]string, arg5 chan error) error {
	fake.createStackMutex.Lock()
	ret, specificReturn := fake.createStackReturnsOnCall[len(fake.createStackArgsForCall)]
	fake.createStackArgsForCall = append(fake.createStackArgsForCall, struct {
		arg1 string
		arg2 builder.ResourceSet
		arg3 map[string]string
		arg4 map[string]string
		arg5 chan error
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateStackStub
	fakeReturns := fake.createStackReturns
	fake.recordInvocation("CreateStack", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) CreateStackCallCount() int {
	fake.createStackMutex.RLock()
	defer fake.createStackMutex.RUnlock()
	return len(fake.createStackArgsForCall)
}

func (fake *FakeStackManager) CreateStackCalls(stub func(string, builder.ResourceSet, map[string]string, map[string]string, chan error) error) {
	fake.createStackMutex.Lock()
	defer fake.createStackMutex.Unlock()
	fake.CreateStackStub = stub
}

func (fake *FakeStackManager) CreateStackArgsForCall(i int) (string, builder.ResourceSet, map[string]string, map[string]string, chan error) {
	fake.createStackMutex.RLock()
	defer fake.createStackMutex.RUnlock()
	argsForCall := fake.createStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStackManager) CreateStackReturns(result1 error) {
	fake.createStackMutex.Lock()
	defer fake.createStackMutex.Unlock()
	fake.CreateStackStub = nil
	fake.createStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) CreateStackReturnsOnCall(i int, result1 error) {
	fake.createStackMutex.Lock()
	defer fake.createStackMutex.Unlock()
	fake.CreateStackStub = nil
	if fake.createStackReturnsOnCall == nil {
		fake.createStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackByName(arg1 string) (*cloudformation.Stack, error) {
	fake.deleteStackByNameMutex.Lock()
	ret, specificReturn := fake.deleteStackByNameReturnsOnCall[len(fake.deleteStackByNameArgsForCall)]
	fake.deleteStackByNameArgsForCall = append(fake.deleteStackByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteStackByNameStub
	fakeReturns := fake.deleteStackByNameReturns
	fake.recordInvocation("DeleteStackByName", []interface{}{arg1})
	fake.deleteStackByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DeleteStackByNameCallCount() int {
	fake.deleteStackByNameMutex.RLock()
	defer fake.deleteStackByNameMutex.RUnlock()
	return len(fake.deleteStackByNameArgsForCall)
}

func (fake *FakeStackManager) DeleteStackByNameCalls(stub func(string) (*cloudformation.Stack, error)) {
	fake.deleteStackByNameMutex.Lock()
	defer fake.deleteStackByNameMutex.Unlock()
	fake.DeleteStackByNameStub = stub
}

func (fake *FakeStackManager) DeleteStackByNameArgsForCall(i int) string {
	fake.deleteStackByNameMutex.RLock()
	defer fake.deleteStackByNameMutex.RUnlock()
	argsForCall := fake.deleteStackByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DeleteStackByNameReturns(result1 *cloudformation.Stack, result2 error) {
	fake.deleteStackByNameMutex.Lock()
	defer fake.deleteStackByNameMutex.Unlock()
	fake.DeleteStackByNameStub = nil
	fake.deleteStackByNameReturns = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteStackByNameReturnsOnCall(i int, result1 *cloudformation.Stack, result2 error) {
	fake.deleteStackByNameMutex.Lock()
	defer fake.deleteStackByNameMutex.Unlock()
	fake.DeleteStackByNameStub = nil
	if fake.deleteStackByNameReturnsOnCall == nil {
		fake.deleteStackByNameReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.Stack
			result2 error
		})
	}
	fake.deleteStackByNameReturnsOnCall[i] = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteStackByNameSync(arg1 string) error {
	fake.deleteStackByNameSyncMutex.Lock()
	ret, specificReturn := fake.deleteStackByNameSyncReturnsOnCall[len(fake.deleteStackByNameSyncArgsForCall)]
	fake.deleteStackByNameSyncArgsForCall = append(fake.deleteStackByNameSyncArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteStackByNameSyncStub
	fakeReturns := fake.deleteStackByNameSyncReturns
	fake.recordInvocation("DeleteStackByNameSync", []interface{}{arg1})
	fake.deleteStackByNameSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DeleteStackByNameSyncCallCount() int {
	fake.deleteStackByNameSyncMutex.RLock()
	defer fake.deleteStackByNameSyncMutex.RUnlock()
	return len(fake.deleteStackByNameSyncArgsForCall)
}

func (fake *FakeStackManager) DeleteStackByNameSyncCalls(stub func(string) error) {
	fake.deleteStackByNameSyncMutex.Lock()
	defer fake.deleteStackByNameSyncMutex.Unlock()
	fake.DeleteStackByNameSyncStub = stub
}

func (fake *FakeStackManager) DeleteStackByNameSyncArgsForCall(i int) string {
	fake.deleteStackByNameSyncMutex.RLock()
	defer fake.deleteStackByNameSyncMutex.RUnlock()
	argsForCall := fake.deleteStackByNameSyncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DeleteStackByNameSyncReturns(result1 error) {
	fake.deleteStackByNameSyncMutex.Lock()
	defer fake.deleteStackByNameSyncMutex.Unlock()
	fake.DeleteStackByNameSyncStub = nil
	fake.deleteStackByNameSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackByNameSyncReturnsOnCall(i int, result1 error) {
	fake.deleteStackByNameSyncMutex.Lock()
	defer fake.deleteStackByNameSyncMutex.Unlock()
	fake.DeleteStackByNameSyncStub = nil
	if fake.deleteStackByNameSyncReturnsOnCall == nil {
		fake.deleteStackByNameSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteStackByNameSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackBySpec(arg1 *cloudformation.Stack) (*cloudformation.Stack, error) {
	fake.deleteStackBySpecMutex.Lock()
	ret, specificReturn := fake.deleteStackBySpecReturnsOnCall[len(fake.deleteStackBySpecArgsForCall)]
	fake.deleteStackBySpecArgsForCall = append(fake.deleteStackBySpecArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.DeleteStackBySpecStub
	fakeReturns := fake.deleteStackBySpecReturns
	fake.recordInvocation("DeleteStackBySpec", []interface{}{arg1})
	fake.deleteStackBySpecMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DeleteStackBySpecCallCount() int {
	fake.deleteStackBySpecMutex.RLock()
	defer fake.deleteStackBySpecMutex.RUnlock()
	return len(fake.deleteStackBySpecArgsForCall)
}

func (fake *FakeStackManager) DeleteStackBySpecCalls(stub func(*cloudformation.Stack) (*cloudformation.Stack, error)) {
	fake.deleteStackBySpecMutex.Lock()
	defer fake.deleteStackBySpecMutex.Unlock()
	fake.DeleteStackBySpecStub = stub
}

func (fake *FakeStackManager) DeleteStackBySpecArgsForCall(i int) *cloudformation.Stack {
	fake.deleteStackBySpecMutex.RLock()
	defer fake.deleteStackBySpecMutex.RUnlock()
	argsForCall := fake.deleteStackBySpecArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DeleteStackBySpecReturns(result1 *cloudformation.Stack, result2 error) {
	fake.deleteStackBySpecMutex.Lock()
	defer fake.deleteStackBySpecMutex.Unlock()
	fake.DeleteStackBySpecStub = nil
	fake.deleteStackBySpecReturns = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteStackBySpecReturnsOnCall(i int, result1 *cloudformation.Stack, result2 error) {
	fake.deleteStackBySpecMutex.Lock()
	defer fake.deleteStackBySpecMutex.Unlock()
	fake.DeleteStackBySpecStub = nil
	if fake.deleteStackBySpecReturnsOnCall == nil {
		fake.deleteStackBySpecReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.Stack
			result2 error
		})
	}
	fake.deleteStackBySpecReturnsOnCall[i] = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteStackBySpecSync(arg1 *cloudformation.Stack, arg2 chan error) error {
	fake.deleteStackBySpecSyncMutex.Lock()
	ret, specificReturn := fake.deleteStackBySpecSyncReturnsOnCall[len(fake.deleteStackBySpecSyncArgsForCall)]
	fake.deleteStackBySpecSyncArgsForCall = append(fake.deleteStackBySpecSyncArgsForCall, struct {
		arg1 *cloudformation.Stack
		arg2 chan error
	}{arg1, arg2})
	stub := fake.DeleteStackBySpecSyncStub
	fakeReturns := fake.deleteStackBySpecSyncReturns
	fake.recordInvocation("DeleteStackBySpecSync", []interface{}{arg1, arg2})
	fake.deleteStackBySpecSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DeleteStackBySpecSyncCallCount() int {
	fake.deleteStackBySpecSyncMutex.RLock()
	defer fake.deleteStackBySpecSyncMutex.RUnlock()
	return len(fake.deleteStackBySpecSyncArgsForCall)
}

func (fake *FakeStackManager) DeleteStackBySpecSyncCalls(stub func(*cloudformation.Stack, chan error) error) {
	fake.deleteStackBySpecSyncMutex.Lock()
	defer fake.deleteStackBySpecSyncMutex.Unlock()
	fake.DeleteStackBySpecSyncStub = stub
}

func (fake *FakeStackManager) DeleteStackBySpecSyncArgsForCall(i int) (*cloudformation.Stack, chan error) {
	fake.deleteStackBySpecSyncMutex.RLock()
	defer fake.deleteStackBySpecSyncMutex.RUnlock()
	argsForCall := fake.deleteStackBySpecSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DeleteStackBySpecSyncReturns(result1 error) {
	fake.deleteStackBySpecSyncMutex.Lock()
	defer fake.deleteStackBySpecSyncMutex.Unlock()
	fake.DeleteStackBySpecSyncStub = nil
	fake.deleteStackBySpecSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackBySpecSyncReturnsOnCall(i int, result1 error) {
	fake.deleteStackBySpecSyncMutex.Lock()
	defer fake.deleteStackBySpecSyncMutex.Unlock()
	fake.DeleteStackBySpecSyncStub = nil
	if fake.deleteStackBySpecSyncReturnsOnCall == nil {
		fake.deleteStackBySpecSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteStackBySpecSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacks() (*tasks.TaskTree, error) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	ret, specificReturn := fake.deleteTasksForDeprecatedStacksReturnsOnCall[len(fake.deleteTasksForDeprecatedStacksArgsForCall)]
	fake.deleteTasksForDeprecatedStacksArgsForCall = append(fake.deleteTasksForDeprecatedStacksArgsForCall, struct {
	}{})
	stub := fake.DeleteTasksForDeprecatedStacksStub
	fakeReturns := fake.deleteTasksForDeprecatedStacksReturns
	fake.recordInvocation("DeleteTasksForDeprecatedStacks", []interface{}{})
	fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksCallCount() int {
	fake.deleteTasksForDeprecatedStacksMutex.RLock()
	defer fake.deleteTasksForDeprecatedStacksMutex.RUnlock()
	return len(fake.deleteTasksForDeprecatedStacksArgsForCall)
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksCalls(stub func() (*tasks.TaskTree, error)) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	defer fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	fake.DeleteTasksForDeprecatedStacksStub = stub
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksReturns(result1 *tasks.TaskTree, result2 error) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	defer fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	fake.DeleteTasksForDeprecatedStacksStub = nil
	fake.deleteTasksForDeprecatedStacksReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	defer fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	fake.DeleteTasksForDeprecatedStacksStub = nil
	if fake.deleteTasksForDeprecatedStacksReturnsOnCall == nil {
		fake.deleteTasksForDeprecatedStacksReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.deleteTasksForDeprecatedStacksReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeClusterStack() (*cloudformation.Stack, error) {
	fake.describeClusterStackMutex.Lock()
	ret, specificReturn := fake.describeClusterStackReturnsOnCall[len(fake.describeClusterStackArgsForCall)]
	fake.describeClusterStackArgsForCall = append(fake.describeClusterStackArgsForCall, struct {
	}{})
	stub := fake.DescribeClusterStackStub
	fakeReturns := fake.describeClusterStackReturns
	fake.recordInvocation("DescribeClusterStack", []interface{}{})
	fake.describeClusterStackMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeClusterStackCallCount() int {
	fake.describeClusterStackMutex.RLock()
	defer fake.describeClusterStackMutex.RUnlock()
	return len(fake.describeClusterStackArgsForCall)
}

func (fake *FakeStackManager) DescribeClusterStackCalls(stub func() (*cloudformation.Stack, error)) {
	fake.describeClusterStackMutex.Lock()
	defer fake.describeClusterStackMutex.Unlock()
	fake.DescribeClusterStackStub = stub
}

func (fake *FakeStackManager) DescribeClusterStackReturns(result1 *cloudformation.Stack, result2 error) {
	fake.describeClusterStackMutex.Lock()
	defer fake.describeClusterStackMutex.Unlock()
	fake.DescribeClusterStackStub = nil
	fake.describeClusterStackReturns = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeClusterStackReturnsOnCall(i int, result1 *cloudformation.Stack, result2 error) {
	fake.describeClusterStackMutex.Lock()
	defer fake.describeClusterStackMutex.Unlock()
	fake.DescribeClusterStackStub = nil
	if fake.describeClusterStackReturnsOnCall == nil {
		fake.describeClusterStackReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.Stack
			result2 error
		})
	}
	fake.describeClusterStackReturnsOnCall[i] = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacks() ([]*cloudformation.Stack, error) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	ret, specificReturn := fake.describeIAMServiceAccountStacksReturnsOnCall[len(fake.describeIAMServiceAccountStacksArgsForCall)]
	fake.describeIAMServiceAccountStacksArgsForCall = append(fake.describeIAMServiceAccountStacksArgsForCall, struct {
	}{})
	stub := fake.DescribeIAMServiceAccountStacksStub
	fakeReturns := fake.describeIAMServiceAccountStacksReturns
	fake.recordInvocation("DescribeIAMServiceAccountStacks", []interface{}{})
	fake.describeIAMServiceAccountStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksCallCount() int {
	fake.describeIAMServiceAccountStacksMutex.RLock()
	defer fake.describeIAMServiceAccountStacksMutex.RUnlock()
	return len(fake.describeIAMServiceAccountStacksArgsForCall)
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksCalls(stub func() ([]*cloudformation.Stack, error)) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	defer fake.describeIAMServiceAccountStacksMutex.Unlock()
	fake.DescribeIAMServiceAccountStacksStub = stub
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksReturns(result1 []*cloudformation.Stack, result2 error) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	defer fake.describeIAMServiceAccountStacksMutex.Unlock()
	fake.DescribeIAMServiceAccountStacksStub = nil
	fake.describeIAMServiceAccountStacksReturns = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksReturnsOnCall(i int, result1 []*cloudformation.Stack, result2 error) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	defer fake.describeIAMServiceAccountStacksMutex.Unlock()
	fake.DescribeIAMServiceAccountStacksStub = nil
	if fake.describeIAMServiceAccountStacksReturnsOnCall == nil {
		fake.describeIAMServiceAccountStacksReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.Stack
			result2 error
		})
	}
	fake.describeIAMServiceAccountStacksReturnsOnCall[i] = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStack(arg1 string) (*cloudformation.Stack, error) {
	fake.describeNodeGroupStackMutex.Lock()
	ret, specificReturn := fake.describeNodeGroupStackReturnsOnCall[len(fake.describeNodeGroupStackArgsForCall)]
	fake.describeNodeGroupStackArgsForCall = append(fake.describeNodeGroupStackArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DescribeNodeGroupStackStub
	fakeReturns := fake.describeNodeGroupStackReturns
	fake.recordInvocation("DescribeNodeGroupStack", []interface{}{arg1})
	fake.describeNodeGroupStackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeNodeGroupStackCallCount() int {
	fake.describeNodeGroupStackMutex.RLock()
	defer fake.describeNodeGroupStackMutex.RUnlock()
	return len(fake.describeNodeGroupStackArgsForCall)
}

func (fake *FakeStackManager) DescribeNodeGroupStackCalls(stub func(string) (*cloudformation.Stack, error)) {
	fake.describeNodeGroupStackMutex.Lock()
	defer fake.describeNodeGroupStackMutex.Unlock()
	fake.DescribeNodeGroupStackStub = stub
}

func (fake *FakeStackManager) DescribeNodeGroupStackArgsForCall(i int) string {
	fake.describeNodeGroupStackMutex.RLock()
	defer fake.describeNodeGroupStackMutex.RUnlock()
	argsForCall := fake.describeNodeGroupStackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeNodeGroupStackReturns(result1 *cloudformation.Stack, result2 error) {
	fake.describeNodeGroupStackMutex.Lock()
	defer fake.describeNodeGroupStackMutex.Unlock()
	fake.DescribeNodeGroupStackStub = nil
	fake.describeNodeGroupStackReturns = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStackReturnsOnCall(i int, result1 *cloudformation.Stack, result2 error) {
	fake.describeNodeGroupStackMutex.Lock()
	defer fake.describeNodeGroupStackMutex.Unlock()
	fake.DescribeNodeGroupStackStub = nil
	if fake.describeNodeGroupStackReturnsOnCall == nil {
		fake.describeNodeGroupStackReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.Stack
			result2 error
		})
	}
	fake.describeNodeGroupStackReturnsOnCall[i] = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStacks() ([]*cloudformation.Stack, error) {
	fake.describeNodeGroupStacksMutex.Lock()
	ret, specificReturn := fake.describeNodeGroupStacksReturnsOnCall[len(fake.describeNodeGroupStacksArgsForCall)]
	fake.describeNodeGroupStacksArgsForCall = append(fake.describeNodeGroupStacksArgsForCall, struct {
	}{})
	stub := fake.DescribeNodeGroupStacksStub
	fakeReturns := fake.describeNodeGroupStacksReturns
	fake.recordInvocation("DescribeNodeGroupStacks", []interface{}{})
	fake.describeNodeGroupStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeNodeGroupStacksCallCount() int {
	fake.describeNodeGroupStacksMutex.RLock()
	defer fake.describeNodeGroupStacksMutex.RUnlock()
	return len(fake.describeNodeGroupStacksArgsForCall)
}

func (fake *FakeStackManager) DescribeNodeGroupStacksCalls(stub func() ([]*cloudformation.Stack, error)) {
	fake.describeNodeGroupStacksMutex.Lock()
	defer fake.describeNodeGroupStacksMutex.Unlock()
	fake.DescribeNodeGroupStacksStub = stub
}

func (fake *FakeStackManager) DescribeNodeGroupStacksReturns(result1 []*cloudformation.Stack, result2 error) {
	fake.describeNodeGroupStacksMutex.Lock()
	defer fake.describeNodeGroupStacksMutex.Unlock()
	fake.DescribeNodeGroupStacksStub = nil
	fake.describeNodeGroupStacksReturns = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStacksReturnsOnCall(i int, result1 []*cloudformation.Stack, result2 error) {
	fake.describeNodeGroupStacksMutex.Lock()
	defer fake.describeNodeGroupStacksMutex.Unlock()
	fake.DescribeNodeGroupStacksStub = nil
	if fake.describeNodeGroupStacksReturnsOnCall == nil {
		fake.describeNodeGroupStacksReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.Stack
			result2 error
		})
	}
	fake.describeNodeGroupStacksReturnsOnCall[i] = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResources() (map[string]manager.StackInfo, error) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	ret, specificReturn := fake.describeNodeGroupStacksAndResourcesReturnsOnCall[len(fake.describeNodeGroupStacksAndResourcesArgsForCall)]
	fake.describeNodeGroupStacksAndResourcesArgsForCall = append(fake.describeNodeGroupStacksAndResourcesArgsForCall, struct {
	}{})
	stub := fake.DescribeNodeGroupStacksAndResourcesStub
	fakeReturns := fake.describeNodeGroupStacksAndResourcesReturns
	fake.recordInvocation("DescribeNodeGroupStacksAndResources", []interface{}{})
	fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesCallCount() int {
	fake.describeNodeGroupStacksAndResourcesMutex.RLock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.RUnlock()
	return len(fake.describeNodeGroupStacksAndResourcesArgsForCall)
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesCalls(stub func() (map[string]manager.StackInfo, error)) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	fake.DescribeNodeGroupStacksAndResourcesStub = stub
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesReturns(result1 map[string]manager.StackInfo, result2 error) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	fake.DescribeNodeGroupStacksAndResourcesStub = nil
	fake.describeNodeGroupStacksAndResourcesReturns = struct {
		result1 map[string]manager.StackInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesReturnsOnCall(i int, result1 map[string]manager.StackInfo, result2 error) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	fake.DescribeNodeGroupStacksAndResourcesStub = nil
	if fake.describeNodeGroupStacksAndResourcesReturnsOnCall == nil {
		fake.describeNodeGroupStacksAndResourcesReturnsOnCall = make(map[int]struct {
			result1 map[string]manager.StackInfo
			result2 error
		})
	}
	fake.describeNodeGroupStacksAndResourcesReturnsOnCall[i] = struct {
		result1 map[string]manager.StackInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStack(arg1 *cloudformation.Stack) (*cloudformation.Stack, error) {
	fake.describeStackMutex.Lock()
	ret, specificReturn := fake.describeStackReturnsOnCall[len(fake.describeStackArgsForCall)]
	fake.describeStackArgsForCall = append(fake.describeStackArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.DescribeStackStub
	fakeReturns := fake.describeStackReturns
	fake.recordInvocation("DescribeStack", []interface{}{arg1})
	fake.describeStackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStackCallCount() int {
	fake.describeStackMutex.RLock()
	defer fake.describeStackMutex.RUnlock()
	return len(fake.describeStackArgsForCall)
}

func (fake *FakeStackManager) DescribeStackCalls(stub func(*cloudformation.Stack) (*cloudformation.Stack, error)) {
	fake.describeStackMutex.Lock()
	defer fake.describeStackMutex.Unlock()
	fake.DescribeStackStub = stub
}

func (fake *FakeStackManager) DescribeStackArgsForCall(i int) *cloudformation.Stack {
	fake.describeStackMutex.RLock()
	defer fake.describeStackMutex.RUnlock()
	argsForCall := fake.describeStackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeStackReturns(result1 *cloudformation.Stack, result2 error) {
	fake.describeStackMutex.Lock()
	defer fake.describeStackMutex.Unlock()
	fake.DescribeStackStub = nil
	fake.describeStackReturns = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackReturnsOnCall(i int, result1 *cloudformation.Stack, result2 error) {
	fake.describeStackMutex.Lock()
	defer fake.describeStackMutex.Unlock()
	fake.DescribeStackStub = nil
	if fake.describeStackReturnsOnCall == nil {
		fake.describeStackReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.Stack
			result2 error
		})
	}
	fake.describeStackReturnsOnCall[i] = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackChangeSet(arg1 *cloudformation.Stack, arg2 string) (*cloudformation.DescribeChangeSetOutput, error) {
	fake.describeStackChangeSetMutex.Lock()
	ret, specificReturn := fake.describeStackChangeSetReturnsOnCall[len(fake.describeStackChangeSetArgsForCall)]
	fake.describeStackChangeSetArgsForCall = append(fake.describeStackChangeSetArgsForCall, struct {
		arg1 *cloudformation.Stack
		arg2 string
	}{arg1, arg2})
	stub := fake.DescribeStackChangeSetStub
	fakeReturns := fake.describeStackChangeSetReturns
	fake.recordInvocation("DescribeStackChangeSet", []interface{}{arg1, arg2})
	fake.describeStackChangeSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStackChangeSetCallCount() int {
	fake.describeStackChangeSetMutex.RLock()
	defer fake.describeStackChangeSetMutex.RUnlock()
	return len(fake.describeStackChangeSetArgsForCall)
}

func (fake *FakeStackManager) DescribeStackChangeSetCalls(stub func(*cloudformation.Stack, string) (*cloudformation.DescribeChangeSetOutput, error)) {
	fake.describeStackChangeSetMutex.Lock()
	defer fake.describeStackChangeSetMutex.Unlock()
	fake.DescribeStackChangeSetStub = stub
}

func (fake *FakeStackManager) DescribeStackChangeSetArgsForCall(i int) (*cloudformation.Stack, string) {
	fake.describeStackChangeSetMutex.RLock()
	defer fake.describeStackChangeSetMutex.RUnlock()
	argsForCall := fake.describeStackChangeSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DescribeStackChangeSetReturns(result1 *cloudformation.DescribeChangeSetOutput, result2 error) {
	fake.describeStackChangeSetMutex.Lock()
	defer fake.describeStackChangeSetMutex.Unlock()
	fake.DescribeStackChangeSetStub = nil
	fake.describeStackChangeSetReturns = struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackChangeSetReturnsOnCall(i int, result1 *cloudformation.DescribeChangeSetOutput, result2 error) {
	fake.describeStackChangeSetMutex.Lock()
	defer fake.describeStackChangeSetMutex.Unlock()
	fake.DescribeStackChangeSetStub = nil
	if fake.describeStackChangeSetReturnsOnCall == nil {
		fake.describeStackChangeSetReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.DescribeChangeSetOutput
			result2 error
		})
	}
	fake.describeStackChangeSetReturnsOnCall[i] = struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackEvents(arg1 *cloudformation.Stack) ([]*cloudformation.StackEvent, error) {
	fake.describeStackEventsMutex.Lock()
	ret, specificReturn := fake.describeStackEventsReturnsOnCall[len(fake.describeStackEventsArgsForCall)]
	fake.describeStackEventsArgsForCall = append(fake.describeStackEventsArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.DescribeStackEventsStub
	fakeReturns := fake.describeStackEventsReturns
	fake.recordInvocation("DescribeStackEvents", []interface{}{arg1})
	fake.describeStackEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStackEventsCallCount() int {
	fake.describeStackEventsMutex.RLock()
	defer fake.describeStackEventsMutex.RUnlock()
	return len(fake.describeStackEventsArgsForCall)
}

func (fake *FakeStackManager) DescribeStackEventsCalls(stub func(*cloudformation.Stack) ([]*cloudformation.StackEvent, error)) {
	fake.describeStackEventsMutex.Lock()
	defer fake.describeStackEventsMutex.Unlock()
	fake.DescribeStackEventsStub = stub
}

func (fake *FakeStackManager) DescribeStackEventsArgsForCall(i int) *cloudformation.Stack {
	fake.describeStackEventsMutex.RLock()
	defer fake.describeStackEventsMutex.RUnlock()
	argsForCall := fake.describeStackEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeStackEventsReturns(result1 []*cloudformation.StackEvent, result2 error) {
	fake.describeStackEventsMutex.Lock()
	defer fake.describeStackEventsMutex.Unlock()
	fake.DescribeStackEventsStub = nil
	fake.describeStackEventsReturns = struct {
		result1 []*cloudformation.StackEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackEventsReturnsOnCall(i int, result1 []*cloudformation.StackEvent, result2 error) {
	fake.describeStackEventsMutex.Lock()
	defer fake.describeStackEventsMutex.Unlock()
	fake.DescribeStackEventsStub = nil
	if fake.describeStackEventsReturnsOnCall == nil {
		fake.describeStackEventsReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.StackEvent
			result2 error
		})
	}
	fake.describeStackEventsReturnsOnCall[i] = struct {
		result1 []*cloudformation.StackEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStacks() ([]*cloudformation.Stack, error) {
	fake.describeStacksMutex.Lock()
	ret, specificReturn := fake.describeStacksReturnsOnCall[len(fake.describeStacksArgsForCall)]
	fake.describeStacksArgsForCall = append(fake.describeStacksArgsForCall, struct {
	}{})
	stub := fake.DescribeStacksStub
	fakeReturns := fake.describeStacksReturns
	fake.recordInvocation("DescribeStacks", []interface{}{})
	fake.describeStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStacksCallCount() int {
	fake.describeStacksMutex.RLock()
	defer fake.describeStacksMutex.RUnlock()
	return len(fake.describeStacksArgsForCall)
}

func (fake *FakeStackManager) DescribeStacksCalls(stub func() ([]*cloudformation.Stack, error)) {
	fake.describeStacksMutex.Lock()
	defer fake.describeStacksMutex.Unlock()
	fake.DescribeStacksStub = stub
}

func (fake *FakeStackManager) DescribeStacksReturns(result1 []*cloudformation.Stack, result2 error) {
	fake.describeStacksMutex.Lock()
	defer fake.describeStacksMutex.Unlock()
	fake.DescribeStacksStub = nil
	fake.describeStacksReturns = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStacksReturnsOnCall(i int, result1 []*cloudformation.Stack, result2 error) {
	fake.describeStacksMutex.Lock()
	defer fake.describeStacksMutex.Unlock()
	fake.DescribeStacksStub = nil
	if fake.describeStacksReturnsOnCall == nil {
		fake.describeStacksReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.Stack
			result2 error
		})
	}
	fake.describeStacksReturnsOnCall[i] = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DoCreateStackRequest(arg1 *cloudformation.Stack, arg2 manager.TemplateData, arg3 map[string]string, arg4 map[string]string, arg5 bool, arg6 bool) error {
	fake.doCreateStackRequestMutex.Lock()
	ret, specificReturn := fake.doCreateStackRequestReturnsOnCall[len(fake.doCreateStackRequestArgsForCall)]
	fake.doCreateStackRequestArgsForCall = append(fake.doCreateStackRequestArgsForCall, struct {
		arg1 *cloudformation.Stack
		arg2 manager.TemplateData
		arg3 map[string]string
		arg4 map[string]string
		arg5 bool
		arg6 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.DoCreateStackRequestStub
	fakeReturns := fake.doCreateStackRequestReturns
	fake.recordInvocation("DoCreateStackRequest", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.doCreateStackRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DoCreateStackRequestCallCount() int {
	fake.doCreateStackRequestMutex.RLock()
	defer fake.doCreateStackRequestMutex.RUnlock()
	return len(fake.doCreateStackRequestArgsForCall)
}

func (fake *FakeStackManager) DoCreateStackRequestCalls(stub func(*cloudformation.Stack, manager.TemplateData, map[string]string, map[string]string, bool, bool) error) {
	fake.doCreateStackRequestMutex.Lock()
	defer fake.doCreateStackRequestMutex.Unlock()
	fake.DoCreateStackRequestStub = stub
}

func (fake *FakeStackManager) DoCreateStackRequestArgsForCall(i int) (*cloudformation.Stack, manager.TemplateData, map[string]string, map[string]string, bool, bool) {
	fake.doCreateStackRequestMutex.RLock()
	defer fake.doCreateStackRequestMutex.RUnlock()
	argsForCall := fake.doCreateStackRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStackManager) DoCreateStackRequestReturns(result1 error) {
	fake.doCreateStackRequestMutex.Lock()
	defer fake.doCreateStackRequestMutex.Unlock()
	fake.DoCreateStackRequestStub = nil
	fake.doCreateStackRequestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DoCreateStackRequestReturnsOnCall(i int, result1 error) {
	fake.doCreateStackRequestMutex.Lock()
	defer fake.doCreateStackRequestMutex.Unlock()
	fake.DoCreateStackRequestStub = nil
	if fake.doCreateStackRequestReturnsOnCall == nil {
		fake.doCreateStackRequestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doCreateStackRequestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreated(arg1 *cloudformation.Stack) error {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	ret, specificReturn := fake.doWaitUntilStackIsCreatedReturnsOnCall[len(fake.doWaitUntilStackIsCreatedArgsForCall)]
	fake.doWaitUntilStackIsCreatedArgsForCall = append(fake.doWaitUntilStackIsCreatedArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.DoWaitUntilStackIsCreatedStub
	fakeReturns := fake.doWaitUntilStackIsCreatedReturns
	fake.recordInvocation("DoWaitUntilStackIsCreated", []interface{}{arg1})
	fake.doWaitUntilStackIsCreatedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedCallCount() int {
	fake.doWaitUntilStackIsCreatedMutex.RLock()
	defer fake.doWaitUntilStackIsCreatedMutex.RUnlock()
	return len(fake.doWaitUntilStackIsCreatedArgsForCall)
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedCalls(stub func(*cloudformation.Stack) error) {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	defer fake.doWaitUntilStackIsCreatedMutex.Unlock()
	fake.DoWaitUntilStackIsCreatedStub = stub
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedArgsForCall(i int) *cloudformation.Stack {
	fake.doWaitUntilStackIsCreatedMutex.RLock()
	defer fake.doWaitUntilStackIsCreatedMutex.RUnlock()
	argsForCall := fake.doWaitUntilStackIsCreatedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedReturns(result1 error) {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	defer fake.doWaitUntilStackIsCreatedMutex.Unlock()
	fake.DoWaitUntilStackIsCreatedStub = nil
	fake.doWaitUntilStackIsCreatedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedReturnsOnCall(i int, result1 error) {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	defer fake.doWaitUntilStackIsCreatedMutex.Unlock()
	fake.DoWaitUntilStackIsCreatedStub = nil
	if fake.doWaitUntilStackIsCreatedReturnsOnCall == nil {
		fake.doWaitUntilStackIsCreatedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doWaitUntilStackIsCreatedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabled() error {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	ret, specificReturn := fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall[len(fake.ensureMapPublicIPOnLaunchEnabledArgsForCall)]
	fake.ensureMapPublicIPOnLaunchEnabledArgsForCall = append(fake.ensureMapPublicIPOnLaunchEnabledArgsForCall, struct {
	}{})
	stub := fake.EnsureMapPublicIPOnLaunchEnabledStub
	fakeReturns := fake.ensureMapPublicIPOnLaunchEnabledReturns
	fake.recordInvocation("EnsureMapPublicIPOnLaunchEnabled", []interface{}{})
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledCallCount() int {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.RLock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.RUnlock()
	return len(fake.ensureMapPublicIPOnLaunchEnabledArgsForCall)
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledCalls(stub func() error) {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	fake.EnsureMapPublicIPOnLaunchEnabledStub = stub
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledReturns(result1 error) {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	fake.EnsureMapPublicIPOnLaunchEnabledStub = nil
	fake.ensureMapPublicIPOnLaunchEnabledReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledReturnsOnCall(i int, result1 error) {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	fake.EnsureMapPublicIPOnLaunchEnabledStub = nil
	if fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall == nil {
		fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) ErrStackNotFound() error {
	fake.errStackNotFoundMutex.Lock()
	ret, specificReturn := fake.errStackNotFoundReturnsOnCall[len(fake.errStackNotFoundArgsForCall)]
	fake.errStackNotFoundArgsForCall = append(fake.errStackNotFoundArgsForCall, struct {
	}{})
	stub := fake.ErrStackNotFoundStub
	fakeReturns := fake.errStackNotFoundReturns
	fake.recordInvocation("ErrStackNotFound", []interface{}{})
	fake.errStackNotFoundMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) ErrStackNotFoundCallCount() int {
	fake.errStackNotFoundMutex.RLock()
	defer fake.errStackNotFoundMutex.RUnlock()
	return len(fake.errStackNotFoundArgsForCall)
}

func (fake *FakeStackManager) ErrStackNotFoundCalls(stub func() error) {
	fake.errStackNotFoundMutex.Lock()
	defer fake.errStackNotFoundMutex.Unlock()
	fake.ErrStackNotFoundStub = stub
}

func (fake *FakeStackManager) ErrStackNotFoundReturns(result1 error) {
	fake.errStackNotFoundMutex.Lock()
	defer fake.errStackNotFoundMutex.Unlock()
	fake.ErrStackNotFoundStub = nil
	fake.errStackNotFoundReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) ErrStackNotFoundReturnsOnCall(i int, result1 error) {
	fake.errStackNotFoundMutex.Lock()
	defer fake.errStackNotFoundMutex.Unlock()
	fake.ErrStackNotFoundStub = nil
	if fake.errStackNotFoundReturnsOnCall == nil {
		fake.errStackNotFoundReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.errStackNotFoundReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) FixClusterCompatibility() error {
	fake.fixClusterCompatibilityMutex.Lock()
	ret, specificReturn := fake.fixClusterCompatibilityReturnsOnCall[len(fake.fixClusterCompatibilityArgsForCall)]
	fake.fixClusterCompatibilityArgsForCall = append(fake.fixClusterCompatibilityArgsForCall, struct {
	}{})
	stub := fake.FixClusterCompatibilityStub
	fakeReturns := fake.fixClusterCompatibilityReturns
	fake.recordInvocation("FixClusterCompatibility", []interface{}{})
	fake.fixClusterCompatibilityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) FixClusterCompatibilityCallCount() int {
	fake.fixClusterCompatibilityMutex.RLock()
	defer fake.fixClusterCompatibilityMutex.RUnlock()
	return len(fake.fixClusterCompatibilityArgsForCall)
}

func (fake *FakeStackManager) FixClusterCompatibilityCalls(stub func() error) {
	fake.fixClusterCompatibilityMutex.Lock()
	defer fake.fixClusterCompatibilityMutex.Unlock()
	fake.FixClusterCompatibilityStub = stub
}

func (fake *FakeStackManager) FixClusterCompatibilityReturns(result1 error) {
	fake.fixClusterCompatibilityMutex.Lock()
	defer fake.fixClusterCompatibilityMutex.Unlock()
	fake.FixClusterCompatibilityStub = nil
	fake.fixClusterCompatibilityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) FixClusterCompatibilityReturnsOnCall(i int, result1 error) {
	fake.fixClusterCompatibilityMutex.Lock()
	defer fake.fixClusterCompatibilityMutex.Unlock()
	fake.FixClusterCompatibilityStub = nil
	if fake.fixClusterCompatibilityReturnsOnCall == nil {
		fake.fixClusterCompatibilityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fixClusterCompatibilityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) GetAutoScalingGroupName(arg1 *cloudformation.Stack) (string, error) {
	fake.getAutoScalingGroupNameMutex.Lock()
	ret, specificReturn := fake.getAutoScalingGroupNameReturnsOnCall[len(fake.getAutoScalingGroupNameArgsForCall)]
	fake.getAutoScalingGroupNameArgsForCall = append(fake.getAutoScalingGroupNameArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.GetAutoScalingGroupNameStub
	fakeReturns := fake.getAutoScalingGroupNameReturns
	fake.recordInvocation("GetAutoScalingGroupName", []interface{}{arg1})
	fake.getAutoScalingGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetAutoScalingGroupNameCallCount() int {
	fake.getAutoScalingGroupNameMutex.RLock()
	defer fake.getAutoScalingGroupNameMutex.RUnlock()
	return len(fake.getAutoScalingGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetAutoScalingGroupNameCalls(stub func(*cloudformation.Stack) (string, error)) {
	fake.getAutoScalingGroupNameMutex.Lock()
	defer fake.getAutoScalingGroupNameMutex.Unlock()
	fake.GetAutoScalingGroupNameStub = stub
}

func (fake *FakeStackManager) GetAutoScalingGroupNameArgsForCall(i int) *cloudformation.Stack {
	fake.getAutoScalingGroupNameMutex.RLock()
	defer fake.getAutoScalingGroupNameMutex.RUnlock()
	argsForCall := fake.getAutoScalingGroupNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetAutoScalingGroupNameReturns(result1 string, result2 error) {
	fake.getAutoScalingGroupNameMutex.Lock()
	defer fake.getAutoScalingGroupNameMutex.Unlock()
	fake.GetAutoScalingGroupNameStub = nil
	fake.getAutoScalingGroupNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetAutoScalingGroupNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getAutoScalingGroupNameMutex.Lock()
	defer fake.getAutoScalingGroupNameMutex.Unlock()
	fake.GetAutoScalingGroupNameStub = nil
	if fake.getAutoScalingGroupNameReturnsOnCall == nil {
		fake.getAutoScalingGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getAutoScalingGroupNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetFargateStack() (*cloudformation.Stack, error) {
	fake.getFargateStackMutex.Lock()
	ret, specificReturn := fake.getFargateStackReturnsOnCall[len(fake.getFargateStackArgsForCall)]
	fake.getFargateStackArgsForCall = append(fake.getFargateStackArgsForCall, struct {
	}{})
	stub := fake.GetFargateStackStub
	fakeReturns := fake.getFargateStackReturns
	fake.recordInvocation("GetFargateStack", []interface{}{})
	fake.getFargateStackMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetFargateStackCallCount() int {
	fake.getFargateStackMutex.RLock()
	defer fake.getFargateStackMutex.RUnlock()
	return len(fake.getFargateStackArgsForCall)
}

func (fake *FakeStackManager) GetFargateStackCalls(stub func() (*cloudformation.Stack, error)) {
	fake.getFargateStackMutex.Lock()
	defer fake.getFargateStackMutex.Unlock()
	fake.GetFargateStackStub = stub
}

func (fake *FakeStackManager) GetFargateStackReturns(result1 *cloudformation.Stack, result2 error) {
	fake.getFargateStackMutex.Lock()
	defer fake.getFargateStackMutex.Unlock()
	fake.GetFargateStackStub = nil
	fake.getFargateStackReturns = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetFargateStackReturnsOnCall(i int, result1 *cloudformation.Stack, result2 error) {
	fake.getFargateStackMutex.Lock()
	defer fake.getFargateStackMutex.Unlock()
	fake.GetFargateStackStub = nil
	if fake.getFargateStackReturnsOnCall == nil {
		fake.getFargateStackReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.Stack
			result2 error
		})
	}
	fake.getFargateStackReturnsOnCall[i] = struct {
		result1 *cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMAddonName(arg1 *cloudformation.Stack) string {
	fake.getIAMAddonNameMutex.Lock()
	ret, specificReturn := fake.getIAMAddonNameReturnsOnCall[len(fake.getIAMAddonNameArgsForCall)]
	fake.getIAMAddonNameArgsForCall = append(fake.getIAMAddonNameArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.GetIAMAddonNameStub
	fakeReturns := fake.getIAMAddonNameReturns
	fake.recordInvocation("GetIAMAddonName", []interface{}{arg1})
	fake.getIAMAddonNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) GetIAMAddonNameCallCount() int {
	fake.getIAMAddonNameMutex.RLock()
	defer fake.getIAMAddonNameMutex.RUnlock()
	return len(fake.getIAMAddonNameArgsForCall)
}

func (fake *FakeStackManager) GetIAMAddonNameCalls(stub func(*cloudformation.Stack) string) {
	fake.getIAMAddonNameMutex.Lock()
	defer fake.getIAMAddonNameMutex.Unlock()
	fake.GetIAMAddonNameStub = stub
}

func (fake *FakeStackManager) GetIAMAddonNameArgsForCall(i int) *cloudformation.Stack {
	fake.getIAMAddonNameMutex.RLock()
	defer fake.getIAMAddonNameMutex.RUnlock()
	argsForCall := fake.getIAMAddonNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetIAMAddonNameReturns(result1 string) {
	fake.getIAMAddonNameMutex.Lock()
	defer fake.getIAMAddonNameMutex.Unlock()
	fake.GetIAMAddonNameStub = nil
	fake.getIAMAddonNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetIAMAddonNameReturnsOnCall(i int, result1 string) {
	fake.getIAMAddonNameMutex.Lock()
	defer fake.getIAMAddonNameMutex.Unlock()
	fake.GetIAMAddonNameStub = nil
	if fake.getIAMAddonNameReturnsOnCall == nil {
		fake.getIAMAddonNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getIAMAddonNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetIAMAddonsStacks() ([]*cloudformation.Stack, error) {
	fake.getIAMAddonsStacksMutex.Lock()
	ret, specificReturn := fake.getIAMAddonsStacksReturnsOnCall[len(fake.getIAMAddonsStacksArgsForCall)]
	fake.getIAMAddonsStacksArgsForCall = append(fake.getIAMAddonsStacksArgsForCall, struct {
	}{})
	stub := fake.GetIAMAddonsStacksStub
	fakeReturns := fake.getIAMAddonsStacksReturns
	fake.recordInvocation("GetIAMAddonsStacks", []interface{}{})
	fake.getIAMAddonsStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetIAMAddonsStacksCallCount() int {
	fake.getIAMAddonsStacksMutex.RLock()
	defer fake.getIAMAddonsStacksMutex.RUnlock()
	return len(fake.getIAMAddonsStacksArgsForCall)
}

func (fake *FakeStackManager) GetIAMAddonsStacksCalls(stub func() ([]*cloudformation.Stack, error)) {
	fake.getIAMAddonsStacksMutex.Lock()
	defer fake.getIAMAddonsStacksMutex.Unlock()
	fake.GetIAMAddonsStacksStub = stub
}

func (fake *FakeStackManager) GetIAMAddonsStacksReturns(result1 []*cloudformation.Stack, result2 error) {
	fake.getIAMAddonsStacksMutex.Lock()
	defer fake.getIAMAddonsStacksMutex.Unlock()
	fake.GetIAMAddonsStacksStub = nil
	fake.getIAMAddonsStacksReturns = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMAddonsStacksReturnsOnCall(i int, result1 []*cloudformation.Stack, result2 error) {
	fake.getIAMAddonsStacksMutex.Lock()
	defer fake.getIAMAddonsStacksMutex.Unlock()
	fake.GetIAMAddonsStacksStub = nil
	if fake.getIAMAddonsStacksReturnsOnCall == nil {
		fake.getIAMAddonsStacksReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.Stack
			result2 error
		})
	}
	fake.getIAMAddonsStacksReturnsOnCall[i] = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMServiceAccounts() ([]*v1alpha5.ClusterIAMServiceAccount, error) {
	fake.getIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.getIAMServiceAccountsReturnsOnCall[len(fake.getIAMServiceAccountsArgsForCall)]
	fake.getIAMServiceAccountsArgsForCall = append(fake.getIAMServiceAccountsArgsForCall, struct {
	}{})
	stub := fake.GetIAMServiceAccountsStub
	fakeReturns := fake.getIAMServiceAccountsReturns
	fake.recordInvocation("GetIAMServiceAccounts", []interface{}{})
	fake.getIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetIAMServiceAccountsCallCount() int {
	fake.getIAMServiceAccountsMutex.RLock()
	defer fake.getIAMServiceAccountsMutex.RUnlock()
	return len(fake.getIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) GetIAMServiceAccountsCalls(stub func() ([]*v1alpha5.ClusterIAMServiceAccount, error)) {
	fake.getIAMServiceAccountsMutex.Lock()
	defer fake.getIAMServiceAccountsMutex.Unlock()
	fake.GetIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) GetIAMServiceAccountsReturns(result1 []*v1alpha5.ClusterIAMServiceAccount, result2 error) {
	fake.getIAMServiceAccountsMutex.Lock()
	defer fake.getIAMServiceAccountsMutex.Unlock()
	fake.GetIAMServiceAccountsStub = nil
	fake.getIAMServiceAccountsReturns = struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMServiceAccountsReturnsOnCall(i int, result1 []*v1alpha5.ClusterIAMServiceAccount, result2 error) {
	fake.getIAMServiceAccountsMutex.Lock()
	defer fake.getIAMServiceAccountsMutex.Unlock()
	fake.GetIAMServiceAccountsStub = nil
	if fake.getIAMServiceAccountsReturnsOnCall == nil {
		fake.getIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 []*v1alpha5.ClusterIAMServiceAccount
			result2 error
		})
	}
	fake.getIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetManagedNodeGroupAutoScalingGroupName(arg1 *cloudformation.Stack) (string, error) {
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.Lock()
	ret, specificReturn := fake.getManagedNodeGroupAutoScalingGroupNameReturnsOnCall[len(fake.getManagedNodeGroupAutoScalingGroupNameArgsForCall)]
	fake.getManagedNodeGroupAutoScalingGroupNameArgsForCall = append(fake.getManagedNodeGroupAutoScalingGroupNameArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.GetManagedNodeGroupAutoScalingGroupNameStub
	fakeReturns := fake.getManagedNodeGroupAutoScalingGroupNameReturns
	fake.recordInvocation("GetManagedNodeGroupAutoScalingGroupName", []interface{}{arg1})
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetManagedNodeGroupAutoScalingGroupNameCallCount() int {
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getManagedNodeGroupAutoScalingGroupNameMutex.RUnlock()
	return len(fake.getManagedNodeGroupAutoScalingGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetManagedNodeGroupAutoScalingGroupNameCalls(stub func(*cloudformation.Stack) (string, error)) {
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getManagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetManagedNodeGroupAutoScalingGroupNameStub = stub
}

func (fake *FakeStackManager) GetManagedNodeGroupAutoScalingGroupNameArgsForCall(i int) *cloudformation.Stack {
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getManagedNodeGroupAutoScalingGroupNameMutex.RUnlock()
	argsForCall := fake.getManagedNodeGroupAutoScalingGroupNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetManagedNodeGroupAutoScalingGroupNameReturns(result1 string, result2 error) {
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getManagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetManagedNodeGroupAutoScalingGroupNameStub = nil
	fake.getManagedNodeGroupAutoScalingGroupNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetManagedNodeGroupAutoScalingGroupNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getManagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetManagedNodeGroupAutoScalingGroupNameStub = nil
	if fake.getManagedNodeGroupAutoScalingGroupNameReturnsOnCall == nil {
		fake.getManagedNodeGroupAutoScalingGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getManagedNodeGroupAutoScalingGroupNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplate(arg1 string) (string, error) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	ret, specificReturn := fake.getManagedNodeGroupTemplateReturnsOnCall[len(fake.getManagedNodeGroupTemplateArgsForCall)]
	fake.getManagedNodeGroupTemplateArgsForCall = append(fake.getManagedNodeGroupTemplateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetManagedNodeGroupTemplateStub
	fakeReturns := fake.getManagedNodeGroupTemplateReturns
	fake.recordInvocation("GetManagedNodeGroupTemplate", []interface{}{arg1})
	fake.getManagedNodeGroupTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateCallCount() int {
	fake.getManagedNodeGroupTemplateMutex.RLock()
	defer fake.getManagedNodeGroupTemplateMutex.RUnlock()
	return len(fake.getManagedNodeGroupTemplateArgsForCall)
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateCalls(stub func(string) (string, error)) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	defer fake.getManagedNodeGroupTemplateMutex.Unlock()
	fake.GetManagedNodeGroupTemplateStub = stub
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateArgsForCall(i int) string {
	fake.getManagedNodeGroupTemplateMutex.RLock()
	defer fake.getManagedNodeGroupTemplateMutex.RUnlock()
	argsForCall := fake.getManagedNodeGroupTemplateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateReturns(result1 string, result2 error) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	defer fake.getManagedNodeGroupTemplateMutex.Unlock()
	fake.GetManagedNodeGroupTemplateStub = nil
	fake.getManagedNodeGroupTemplateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateReturnsOnCall(i int, result1 string, result2 error) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	defer fake.getManagedNodeGroupTemplateMutex.Unlock()
	fake.GetManagedNodeGroupTemplateStub = nil
	if fake.getManagedNodeGroupTemplateReturnsOnCall == nil {
		fake.getManagedNodeGroupTemplateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getManagedNodeGroupTemplateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupAutoScalingGroupName(arg1 *cloudformation.Stack) (string, error) {
	fake.getNodeGroupAutoScalingGroupNameMutex.Lock()
	ret, specificReturn := fake.getNodeGroupAutoScalingGroupNameReturnsOnCall[len(fake.getNodeGroupAutoScalingGroupNameArgsForCall)]
	fake.getNodeGroupAutoScalingGroupNameArgsForCall = append(fake.getNodeGroupAutoScalingGroupNameArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.GetNodeGroupAutoScalingGroupNameStub
	fakeReturns := fake.getNodeGroupAutoScalingGroupNameReturns
	fake.recordInvocation("GetNodeGroupAutoScalingGroupName", []interface{}{arg1})
	fake.getNodeGroupAutoScalingGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetNodeGroupAutoScalingGroupNameCallCount() int {
	fake.getNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getNodeGroupAutoScalingGroupNameMutex.RUnlock()
	return len(fake.getNodeGroupAutoScalingGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetNodeGroupAutoScalingGroupNameCalls(stub func(*cloudformation.Stack) (string, error)) {
	fake.getNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetNodeGroupAutoScalingGroupNameStub = stub
}

func (fake *FakeStackManager) GetNodeGroupAutoScalingGroupNameArgsForCall(i int) *cloudformation.Stack {
	fake.getNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getNodeGroupAutoScalingGroupNameMutex.RUnlock()
	argsForCall := fake.getNodeGroupAutoScalingGroupNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetNodeGroupAutoScalingGroupNameReturns(result1 string, result2 error) {
	fake.getNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetNodeGroupAutoScalingGroupNameStub = nil
	fake.getNodeGroupAutoScalingGroupNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupAutoScalingGroupNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetNodeGroupAutoScalingGroupNameStub = nil
	if fake.getNodeGroupAutoScalingGroupNameReturnsOnCall == nil {
		fake.getNodeGroupAutoScalingGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getNodeGroupAutoScalingGroupNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupName(arg1 *cloudformation.Stack) string {
	fake.getNodeGroupNameMutex.Lock()
	ret, specificReturn := fake.getNodeGroupNameReturnsOnCall[len(fake.getNodeGroupNameArgsForCall)]
	fake.getNodeGroupNameArgsForCall = append(fake.getNodeGroupNameArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.GetNodeGroupNameStub
	fakeReturns := fake.getNodeGroupNameReturns
	fake.recordInvocation("GetNodeGroupName", []interface{}{arg1})
	fake.getNodeGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) GetNodeGroupNameCallCount() int {
	fake.getNodeGroupNameMutex.RLock()
	defer fake.getNodeGroupNameMutex.RUnlock()
	return len(fake.getNodeGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetNodeGroupNameCalls(stub func(*cloudformation.Stack) string) {
	fake.getNodeGroupNameMutex.Lock()
	defer fake.getNodeGroupNameMutex.Unlock()
	fake.GetNodeGroupNameStub = stub
}

func (fake *FakeStackManager) GetNodeGroupNameArgsForCall(i int) *cloudformation.Stack {
	fake.getNodeGroupNameMutex.RLock()
	defer fake.getNodeGroupNameMutex.RUnlock()
	argsForCall := fake.getNodeGroupNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetNodeGroupNameReturns(result1 string) {
	fake.getNodeGroupNameMutex.Lock()
	defer fake.getNodeGroupNameMutex.Unlock()
	fake.GetNodeGroupNameStub = nil
	fake.getNodeGroupNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetNodeGroupNameReturnsOnCall(i int, result1 string) {
	fake.getNodeGroupNameMutex.Lock()
	defer fake.getNodeGroupNameMutex.Unlock()
	fake.GetNodeGroupNameStub = nil
	if fake.getNodeGroupNameReturnsOnCall == nil {
		fake.getNodeGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNodeGroupNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetNodeGroupStackType(arg1 string) (v1alpha5.NodeGroupType, error) {
	fake.getNodeGroupStackTypeMutex.Lock()
	ret, specificReturn := fake.getNodeGroupStackTypeReturnsOnCall[len(fake.getNodeGroupStackTypeArgsForCall)]
	fake.getNodeGroupStackTypeArgsForCall = append(fake.getNodeGroupStackTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNodeGroupStackTypeStub
	fakeReturns := fake.getNodeGroupStackTypeReturns
	fake.recordInvocation("GetNodeGroupStackType", []interface{}{arg1})
	fake.getNodeGroupStackTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetNodeGroupStackTypeCallCount() int {
	fake.getNodeGroupStackTypeMutex.RLock()
	defer fake.getNodeGroupStackTypeMutex.RUnlock()
	return len(fake.getNodeGroupStackTypeArgsForCall)
}

func (fake *FakeStackManager) GetNodeGroupStackTypeCalls(stub func(string) (v1alpha5.NodeGroupType, error)) {
	fake.getNodeGroupStackTypeMutex.Lock()
	defer fake.getNodeGroupStackTypeMutex.Unlock()
	fake.GetNodeGroupStackTypeStub = stub
}

func (fake *FakeStackManager) GetNodeGroupStackTypeArgsForCall(i int) string {
	fake.getNodeGroupStackTypeMutex.RLock()
	defer fake.getNodeGroupStackTypeMutex.RUnlock()
	argsForCall := fake.getNodeGroupStackTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetNodeGroupStackTypeReturns(result1 v1alpha5.NodeGroupType, result2 error) {
	fake.getNodeGroupStackTypeMutex.Lock()
	defer fake.getNodeGroupStackTypeMutex.Unlock()
	fake.GetNodeGroupStackTypeStub = nil
	fake.getNodeGroupStackTypeReturns = struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupStackTypeReturnsOnCall(i int, result1 v1alpha5.NodeGroupType, result2 error) {
	fake.getNodeGroupStackTypeMutex.Lock()
	defer fake.getNodeGroupStackTypeMutex.Unlock()
	fake.GetNodeGroupStackTypeStub = nil
	if fake.getNodeGroupStackTypeReturnsOnCall == nil {
		fake.getNodeGroupStackTypeReturnsOnCall = make(map[int]struct {
			result1 v1alpha5.NodeGroupType
			result2 error
		})
	}
	fake.getNodeGroupStackTypeReturnsOnCall[i] = struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupSummaries(arg1 string) ([]*manager.NodeGroupSummary, error) {
	fake.getNodeGroupSummariesMutex.Lock()
	ret, specificReturn := fake.getNodeGroupSummariesReturnsOnCall[len(fake.getNodeGroupSummariesArgsForCall)]
	fake.getNodeGroupSummariesArgsForCall = append(fake.getNodeGroupSummariesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNodeGroupSummariesStub
	fakeReturns := fake.getNodeGroupSummariesReturns
	fake.recordInvocation("GetNodeGroupSummaries", []interface{}{arg1})
	fake.getNodeGroupSummariesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetNodeGroupSummariesCallCount() int {
	fake.getNodeGroupSummariesMutex.RLock()
	defer fake.getNodeGroupSummariesMutex.RUnlock()
	return len(fake.getNodeGroupSummariesArgsForCall)
}

func (fake *FakeStackManager) GetNodeGroupSummariesCalls(stub func(string) ([]*manager.NodeGroupSummary, error)) {
	fake.getNodeGroupSummariesMutex.Lock()
	defer fake.getNodeGroupSummariesMutex.Unlock()
	fake.GetNodeGroupSummariesStub = stub
}

func (fake *FakeStackManager) GetNodeGroupSummariesArgsForCall(i int) string {
	fake.getNodeGroupSummariesMutex.RLock()
	defer fake.getNodeGroupSummariesMutex.RUnlock()
	argsForCall := fake.getNodeGroupSummariesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetNodeGroupSummariesReturns(result1 []*manager.NodeGroupSummary, result2 error) {
	fake.getNodeGroupSummariesMutex.Lock()
	defer fake.getNodeGroupSummariesMutex.Unlock()
	fake.GetNodeGroupSummariesStub = nil
	fake.getNodeGroupSummariesReturns = struct {
		result1 []*manager.NodeGroupSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupSummariesReturnsOnCall(i int, result1 []*manager.NodeGroupSummary, result2 error) {
	fake.getNodeGroupSummariesMutex.Lock()
	defer fake.getNodeGroupSummariesMutex.Unlock()
	fake.GetNodeGroupSummariesStub = nil
	if fake.getNodeGroupSummariesReturnsOnCall == nil {
		fake.getNodeGroupSummariesReturnsOnCall = make(map[int]struct {
			result1 []*manager.NodeGroupSummary
			result2 error
		})
	}
	fake.getNodeGroupSummariesReturnsOnCall[i] = struct {
		result1 []*manager.NodeGroupSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetStackTemplate(arg1 string) (string, error) {
	fake.getStackTemplateMutex.Lock()
	ret, specificReturn := fake.getStackTemplateReturnsOnCall[len(fake.getStackTemplateArgsForCall)]
	fake.getStackTemplateArgsForCall = append(fake.getStackTemplateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStackTemplateStub
	fakeReturns := fake.getStackTemplateReturns
	fake.recordInvocation("GetStackTemplate", []interface{}{arg1})
	fake.getStackTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetStackTemplateCallCount() int {
	fake.getStackTemplateMutex.RLock()
	defer fake.getStackTemplateMutex.RUnlock()
	return len(fake.getStackTemplateArgsForCall)
}

func (fake *FakeStackManager) GetStackTemplateCalls(stub func(string) (string, error)) {
	fake.getStackTemplateMutex.Lock()
	defer fake.getStackTemplateMutex.Unlock()
	fake.GetStackTemplateStub = stub
}

func (fake *FakeStackManager) GetStackTemplateArgsForCall(i int) string {
	fake.getStackTemplateMutex.RLock()
	defer fake.getStackTemplateMutex.RUnlock()
	argsForCall := fake.getStackTemplateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetStackTemplateReturns(result1 string, result2 error) {
	fake.getStackTemplateMutex.Lock()
	defer fake.getStackTemplateMutex.Unlock()
	fake.GetStackTemplateStub = nil
	fake.getStackTemplateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetStackTemplateReturnsOnCall(i int, result1 string, result2 error) {
	fake.getStackTemplateMutex.Lock()
	defer fake.getStackTemplateMutex.Unlock()
	fake.GetStackTemplateStub = nil
	if fake.getStackTemplateReturnsOnCall == nil {
		fake.getStackTemplateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStackTemplateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) HasClusterStack() (bool, error) {
	fake.hasClusterStackMutex.Lock()
	ret, specificReturn := fake.hasClusterStackReturnsOnCall[len(fake.hasClusterStackArgsForCall)]
	fake.hasClusterStackArgsForCall = append(fake.hasClusterStackArgsForCall, struct {
	}{})
	stub := fake.HasClusterStackStub
	fakeReturns := fake.hasClusterStackReturns
	fake.recordInvocation("HasClusterStack", []interface{}{})
	fake.hasClusterStackMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) HasClusterStackCallCount() int {
	fake.hasClusterStackMutex.RLock()
	defer fake.hasClusterStackMutex.RUnlock()
	return len(fake.hasClusterStackArgsForCall)
}

func (fake *FakeStackManager) HasClusterStackCalls(stub func() (bool, error)) {
	fake.hasClusterStackMutex.Lock()
	defer fake.hasClusterStackMutex.Unlock()
	fake.HasClusterStackStub = stub
}

func (fake *FakeStackManager) HasClusterStackReturns(result1 bool, result2 error) {
	fake.hasClusterStackMutex.Lock()
	defer fake.hasClusterStackMutex.Unlock()
	fake.HasClusterStackStub = nil
	fake.hasClusterStackReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) HasClusterStackReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasClusterStackMutex.Lock()
	defer fake.hasClusterStackMutex.Unlock()
	fake.HasClusterStackStub = nil
	if fake.hasClusterStackReturnsOnCall == nil {
		fake.hasClusterStackReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasClusterStackReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) HasClusterStackUsingCachedList(arg1 []string) (bool, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.hasClusterStackUsingCachedListMutex.Lock()
	ret, specificReturn := fake.hasClusterStackUsingCachedListReturnsOnCall[len(fake.hasClusterStackUsingCachedListArgsForCall)]
	fake.hasClusterStackUsingCachedListArgsForCall = append(fake.hasClusterStackUsingCachedListArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.HasClusterStackUsingCachedListStub
	fakeReturns := fake.hasClusterStackUsingCachedListReturns
	fake.recordInvocation("HasClusterStackUsingCachedList", []interface{}{arg1Copy})
	fake.hasClusterStackUsingCachedListMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) HasClusterStackUsingCachedListCallCount() int {
	fake.hasClusterStackUsingCachedListMutex.RLock()
	defer fake.hasClusterStackUsingCachedListMutex.RUnlock()
	return len(fake.hasClusterStackUsingCachedListArgsForCall)
}

func (fake *FakeStackManager) HasClusterStackUsingCachedListCalls(stub func([]string) (bool, error)) {
	fake.hasClusterStackUsingCachedListMutex.Lock()
	defer fake.hasClusterStackUsingCachedListMutex.Unlock()
	fake.HasClusterStackUsingCachedListStub = stub
}

func (fake *FakeStackManager) HasClusterStackUsingCachedListArgsForCall(i int) []string {
	fake.hasClusterStackUsingCachedListMutex.RLock()
	defer fake.hasClusterStackUsingCachedListMutex.RUnlock()
	argsForCall := fake.hasClusterStackUsingCachedListArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) HasClusterStackUsingCachedListReturns(result1 bool, result2 error) {
	fake.hasClusterStackUsingCachedListMutex.Lock()
	defer fake.hasClusterStackUsingCachedListMutex.Unlock()
	fake.HasClusterStackUsingCachedListStub = nil
	fake.hasClusterStackUsingCachedListReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) HasClusterStackUsingCachedListReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasClusterStackUsingCachedListMutex.Lock()
	defer fake.hasClusterStackUsingCachedListMutex.Unlock()
	fake.HasClusterStackUsingCachedListStub = nil
	if fake.hasClusterStackUsingCachedListReturnsOnCall == nil {
		fake.hasClusterStackUsingCachedListReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasClusterStackUsingCachedListReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListClusterStackNames() ([]string, error) {
	fake.listClusterStackNamesMutex.Lock()
	ret, specificReturn := fake.listClusterStackNamesReturnsOnCall[len(fake.listClusterStackNamesArgsForCall)]
	fake.listClusterStackNamesArgsForCall = append(fake.listClusterStackNamesArgsForCall, struct {
	}{})
	stub := fake.ListClusterStackNamesStub
	fakeReturns := fake.listClusterStackNamesReturns
	fake.recordInvocation("ListClusterStackNames", []interface{}{})
	fake.listClusterStackNamesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListClusterStackNamesCallCount() int {
	fake.listClusterStackNamesMutex.RLock()
	defer fake.listClusterStackNamesMutex.RUnlock()
	return len(fake.listClusterStackNamesArgsForCall)
}

func (fake *FakeStackManager) ListClusterStackNamesCalls(stub func() ([]string, error)) {
	fake.listClusterStackNamesMutex.Lock()
	defer fake.listClusterStackNamesMutex.Unlock()
	fake.ListClusterStackNamesStub = stub
}

func (fake *FakeStackManager) ListClusterStackNamesReturns(result1 []string, result2 error) {
	fake.listClusterStackNamesMutex.Lock()
	defer fake.listClusterStackNamesMutex.Unlock()
	fake.ListClusterStackNamesStub = nil
	fake.listClusterStackNamesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListClusterStackNamesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listClusterStackNamesMutex.Lock()
	defer fake.listClusterStackNamesMutex.Unlock()
	fake.ListClusterStackNamesStub = nil
	if fake.listClusterStackNamesReturnsOnCall == nil {
		fake.listClusterStackNamesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listClusterStackNamesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListIAMServiceAccountStacks() ([]string, error) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	ret, specificReturn := fake.listIAMServiceAccountStacksReturnsOnCall[len(fake.listIAMServiceAccountStacksArgsForCall)]
	fake.listIAMServiceAccountStacksArgsForCall = append(fake.listIAMServiceAccountStacksArgsForCall, struct {
	}{})
	stub := fake.ListIAMServiceAccountStacksStub
	fakeReturns := fake.listIAMServiceAccountStacksReturns
	fake.recordInvocation("ListIAMServiceAccountStacks", []interface{}{})
	fake.listIAMServiceAccountStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksCallCount() int {
	fake.listIAMServiceAccountStacksMutex.RLock()
	defer fake.listIAMServiceAccountStacksMutex.RUnlock()
	return len(fake.listIAMServiceAccountStacksArgsForCall)
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksCalls(stub func() ([]string, error)) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	defer fake.listIAMServiceAccountStacksMutex.Unlock()
	fake.ListIAMServiceAccountStacksStub = stub
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksReturns(result1 []string, result2 error) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	defer fake.listIAMServiceAccountStacksMutex.Unlock()
	fake.ListIAMServiceAccountStacksStub = nil
	fake.listIAMServiceAccountStacksReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	defer fake.listIAMServiceAccountStacksMutex.Unlock()
	fake.ListIAMServiceAccountStacksStub = nil
	if fake.listIAMServiceAccountStacksReturnsOnCall == nil {
		fake.listIAMServiceAccountStacksReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listIAMServiceAccountStacksReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListNodeGroupStacks() ([]manager.NodeGroupStack, error) {
	fake.listNodeGroupStacksMutex.Lock()
	ret, specificReturn := fake.listNodeGroupStacksReturnsOnCall[len(fake.listNodeGroupStacksArgsForCall)]
	fake.listNodeGroupStacksArgsForCall = append(fake.listNodeGroupStacksArgsForCall, struct {
	}{})
	stub := fake.ListNodeGroupStacksStub
	fakeReturns := fake.listNodeGroupStacksReturns
	fake.recordInvocation("ListNodeGroupStacks", []interface{}{})
	fake.listNodeGroupStacksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListNodeGroupStacksCallCount() int {
	fake.listNodeGroupStacksMutex.RLock()
	defer fake.listNodeGroupStacksMutex.RUnlock()
	return len(fake.listNodeGroupStacksArgsForCall)
}

func (fake *FakeStackManager) ListNodeGroupStacksCalls(stub func() ([]manager.NodeGroupStack, error)) {
	fake.listNodeGroupStacksMutex.Lock()
	defer fake.listNodeGroupStacksMutex.Unlock()
	fake.ListNodeGroupStacksStub = stub
}

func (fake *FakeStackManager) ListNodeGroupStacksReturns(result1 []manager.NodeGroupStack, result2 error) {
	fake.listNodeGroupStacksMutex.Lock()
	defer fake.listNodeGroupStacksMutex.Unlock()
	fake.ListNodeGroupStacksStub = nil
	fake.listNodeGroupStacksReturns = struct {
		result1 []manager.NodeGroupStack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListNodeGroupStacksReturnsOnCall(i int, result1 []manager.NodeGroupStack, result2 error) {
	fake.listNodeGroupStacksMutex.Lock()
	defer fake.listNodeGroupStacksMutex.Unlock()
	fake.ListNodeGroupStacksStub = nil
	if fake.listNodeGroupStacksReturnsOnCall == nil {
		fake.listNodeGroupStacksReturnsOnCall = make(map[int]struct {
			result1 []manager.NodeGroupStack
			result2 error
		})
	}
	fake.listNodeGroupStacksReturnsOnCall[i] = struct {
		result1 []manager.NodeGroupStack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacks(arg1 ...string) ([]*cloudformation.Stack, error) {
	fake.listStacksMutex.Lock()
	ret, specificReturn := fake.listStacksReturnsOnCall[len(fake.listStacksArgsForCall)]
	fake.listStacksArgsForCall = append(fake.listStacksArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.ListStacksStub
	fakeReturns := fake.listStacksReturns
	fake.recordInvocation("ListStacks", []interface{}{arg1})
	fake.listStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListStacksCallCount() int {
	fake.listStacksMutex.RLock()
	defer fake.listStacksMutex.RUnlock()
	return len(fake.listStacksArgsForCall)
}

func (fake *FakeStackManager) ListStacksCalls(stub func(...string) ([]*cloudformation.Stack, error)) {
	fake.listStacksMutex.Lock()
	defer fake.listStacksMutex.Unlock()
	fake.ListStacksStub = stub
}

func (fake *FakeStackManager) ListStacksArgsForCall(i int) []string {
	fake.listStacksMutex.RLock()
	defer fake.listStacksMutex.RUnlock()
	argsForCall := fake.listStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListStacksReturns(result1 []*cloudformation.Stack, result2 error) {
	fake.listStacksMutex.Lock()
	defer fake.listStacksMutex.Unlock()
	fake.ListStacksStub = nil
	fake.listStacksReturns = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksReturnsOnCall(i int, result1 []*cloudformation.Stack, result2 error) {
	fake.listStacksMutex.Lock()
	defer fake.listStacksMutex.Unlock()
	fake.ListStacksStub = nil
	if fake.listStacksReturnsOnCall == nil {
		fake.listStacksReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.Stack
			result2 error
		})
	}
	fake.listStacksReturnsOnCall[i] = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksMatching(arg1 string, arg2 ...string) ([]*cloudformation.Stack, error) {
	fake.listStacksMatchingMutex.Lock()
	ret, specificReturn := fake.listStacksMatchingReturnsOnCall[len(fake.listStacksMatchingArgsForCall)]
	fake.listStacksMatchingArgsForCall = append(fake.listStacksMatchingArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2})
	stub := fake.ListStacksMatchingStub
	fakeReturns := fake.listStacksMatchingReturns
	fake.recordInvocation("ListStacksMatching", []interface{}{arg1, arg2})
	fake.listStacksMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListStacksMatchingCallCount() int {
	fake.listStacksMatchingMutex.RLock()
	defer fake.listStacksMatchingMutex.RUnlock()
	return len(fake.listStacksMatchingArgsForCall)
}

func (fake *FakeStackManager) ListStacksMatchingCalls(stub func(string, ...string) ([]*cloudformation.Stack, error)) {
	fake.listStacksMatchingMutex.Lock()
	defer fake.listStacksMatchingMutex.Unlock()
	fake.ListStacksMatchingStub = stub
}

func (fake *FakeStackManager) ListStacksMatchingArgsForCall(i int) (string, []string) {
	fake.listStacksMatchingMutex.RLock()
	defer fake.listStacksMatchingMutex.RUnlock()
	argsForCall := fake.listStacksMatchingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) ListStacksMatchingReturns(result1 []*cloudformation.Stack, result2 error) {
	fake.listStacksMatchingMutex.Lock()
	defer fake.listStacksMatchingMutex.Unlock()
	fake.ListStacksMatchingStub = nil
	fake.listStacksMatchingReturns = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksMatchingReturnsOnCall(i int, result1 []*cloudformation.Stack, result2 error) {
	fake.listStacksMatchingMutex.Lock()
	defer fake.listStacksMatchingMutex.Unlock()
	fake.ListStacksMatchingStub = nil
	if fake.listStacksMatchingReturnsOnCall == nil {
		fake.listStacksMatchingReturnsOnCall = make(map[int]struct {
			result1 []*cloudformation.Stack
			result2 error
		})
	}
	fake.listStacksMatchingReturnsOnCall[i] = struct {
		result1 []*cloudformation.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) LookupCloudTrailEvents(arg1 *cloudformation.Stack) ([]*cloudtrail.Event, error) {
	fake.lookupCloudTrailEventsMutex.Lock()
	ret, specificReturn := fake.lookupCloudTrailEventsReturnsOnCall[len(fake.lookupCloudTrailEventsArgsForCall)]
	fake.lookupCloudTrailEventsArgsForCall = append(fake.lookupCloudTrailEventsArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.LookupCloudTrailEventsStub
	fakeReturns := fake.lookupCloudTrailEventsReturns
	fake.recordInvocation("LookupCloudTrailEvents", []interface{}{arg1})
	fake.lookupCloudTrailEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) LookupCloudTrailEventsCallCount() int {
	fake.lookupCloudTrailEventsMutex.RLock()
	defer fake.lookupCloudTrailEventsMutex.RUnlock()
	return len(fake.lookupCloudTrailEventsArgsForCall)
}

func (fake *FakeStackManager) LookupCloudTrailEventsCalls(stub func(*cloudformation.Stack) ([]*cloudtrail.Event, error)) {
	fake.lookupCloudTrailEventsMutex.Lock()
	defer fake.lookupCloudTrailEventsMutex.Unlock()
	fake.LookupCloudTrailEventsStub = stub
}

func (fake *FakeStackManager) LookupCloudTrailEventsArgsForCall(i int) *cloudformation.Stack {
	fake.lookupCloudTrailEventsMutex.RLock()
	defer fake.lookupCloudTrailEventsMutex.RUnlock()
	argsForCall := fake.lookupCloudTrailEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) LookupCloudTrailEventsReturns(result1 []*cloudtrail.Event, result2 error) {
	fake.lookupCloudTrailEventsMutex.Lock()
	defer fake.lookupCloudTrailEventsMutex.Unlock()
	fake.LookupCloudTrailEventsStub = nil
	fake.lookupCloudTrailEventsReturns = struct {
		result1 []*cloudtrail.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) LookupCloudTrailEventsReturnsOnCall(i int, result1 []*cloudtrail.Event, result2 error) {
	fake.lookupCloudTrailEventsMutex.Lock()
	defer fake.lookupCloudTrailEventsMutex.Unlock()
	fake.LookupCloudTrailEventsStub = nil
	if fake.lookupCloudTrailEventsReturnsOnCall == nil {
		fake.lookupCloudTrailEventsReturnsOnCall = make(map[int]struct {
			result1 []*cloudtrail.Event
			result2 error
		})
	}
	fake.lookupCloudTrailEventsReturnsOnCall[i] = struct {
		result1 []*cloudtrail.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) MakeChangeSetName(arg1 string) string {
	fake.makeChangeSetNameMutex.Lock()
	ret, specificReturn := fake.makeChangeSetNameReturnsOnCall[len(fake.makeChangeSetNameArgsForCall)]
	fake.makeChangeSetNameArgsForCall = append(fake.makeChangeSetNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.MakeChangeSetNameStub
	fakeReturns := fake.makeChangeSetNameReturns
	fake.recordInvocation("MakeChangeSetName", []interface{}{arg1})
	fake.makeChangeSetNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) MakeChangeSetNameCallCount() int {
	fake.makeChangeSetNameMutex.RLock()
	defer fake.makeChangeSetNameMutex.RUnlock()
	return len(fake.makeChangeSetNameArgsForCall)
}

func (fake *FakeStackManager) MakeChangeSetNameCalls(stub func(string) string) {
	fake.makeChangeSetNameMutex.Lock()
	defer fake.makeChangeSetNameMutex.Unlock()
	fake.MakeChangeSetNameStub = stub
}

func (fake *FakeStackManager) MakeChangeSetNameArgsForCall(i int) string {
	fake.makeChangeSetNameMutex.RLock()
	defer fake.makeChangeSetNameMutex.RUnlock()
	argsForCall := fake.makeChangeSetNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) MakeChangeSetNameReturns(result1 string) {
	fake.makeChangeSetNameMutex.Lock()
	defer fake.makeChangeSetNameMutex.Unlock()
	fake.MakeChangeSetNameStub = nil
	fake.makeChangeSetNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) MakeChangeSetNameReturnsOnCall(i int, result1 string) {
	fake.makeChangeSetNameMutex.Lock()
	defer fake.makeChangeSetNameMutex.Unlock()
	fake.MakeChangeSetNameStub = nil
	if fake.makeChangeSetNameReturnsOnCall == nil {
		fake.makeChangeSetNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.makeChangeSetNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) NewClusterCompatTask() tasks.Task {
	fake.newClusterCompatTaskMutex.Lock()
	ret, specificReturn := fake.newClusterCompatTaskReturnsOnCall[len(fake.newClusterCompatTaskArgsForCall)]
	fake.newClusterCompatTaskArgsForCall = append(fake.newClusterCompatTaskArgsForCall, struct {
	}{})
	stub := fake.NewClusterCompatTaskStub
	fakeReturns := fake.newClusterCompatTaskReturns
	fake.recordInvocation("NewClusterCompatTask", []interface{}{})
	fake.newClusterCompatTaskMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewClusterCompatTaskCallCount() int {
	fake.newClusterCompatTaskMutex.RLock()
	defer fake.newClusterCompatTaskMutex.RUnlock()
	return len(fake.newClusterCompatTaskArgsForCall)
}

func (fake *FakeStackManager) NewClusterCompatTaskCalls(stub func() tasks.Task) {
	fake.newClusterCompatTaskMutex.Lock()
	defer fake.newClusterCompatTaskMutex.Unlock()
	fake.NewClusterCompatTaskStub = stub
}

func (fake *FakeStackManager) NewClusterCompatTaskReturns(result1 tasks.Task) {
	fake.newClusterCompatTaskMutex.Lock()
	defer fake.newClusterCompatTaskMutex.Unlock()
	fake.NewClusterCompatTaskStub = nil
	fake.newClusterCompatTaskReturns = struct {
		result1 tasks.Task
	}{result1}
}

func (fake *FakeStackManager) NewClusterCompatTaskReturnsOnCall(i int, result1 tasks.Task) {
	fake.newClusterCompatTaskMutex.Lock()
	defer fake.newClusterCompatTaskMutex.Unlock()
	fake.NewClusterCompatTaskStub = nil
	if fake.newClusterCompatTaskReturnsOnCall == nil {
		fake.newClusterCompatTaskReturnsOnCall = make(map[int]struct {
			result1 tasks.Task
		})
	}
	fake.newClusterCompatTaskReturnsOnCall[i] = struct {
		result1 tasks.Task
	}{result1}
}

func (fake *FakeStackManager) NewManagedNodeGroupTask(arg1 []*v1alpha5.ManagedNodeGroup, arg2 bool) *tasks.TaskTree {
	var arg1Copy []*v1alpha5.ManagedNodeGroup
	if arg1 != nil {
		arg1Copy = make([]*v1alpha5.ManagedNodeGroup, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newManagedNodeGroupTaskMutex.Lock()
	ret, specificReturn := fake.newManagedNodeGroupTaskReturnsOnCall[len(fake.newManagedNodeGroupTaskArgsForCall)]
	fake.newManagedNodeGroupTaskArgsForCall = append(fake.newManagedNodeGroupTaskArgsForCall, struct {
		arg1 []*v1alpha5.ManagedNodeGroup
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.NewManagedNodeGroupTaskStub
	fakeReturns := fake.newManagedNodeGroupTaskReturns
	fake.recordInvocation("NewManagedNodeGroupTask", []interface{}{arg1Copy, arg2})
	fake.newManagedNodeGroupTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskCallCount() int {
	fake.newManagedNodeGroupTaskMutex.RLock()
	defer fake.newManagedNodeGroupTaskMutex.RUnlock()
	return len(fake.newManagedNodeGroupTaskArgsForCall)
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskCalls(stub func([]*v1alpha5.ManagedNodeGroup, bool) *tasks.TaskTree) {
	fake.newManagedNodeGroupTaskMutex.Lock()
	defer fake.newManagedNodeGroupTaskMutex.Unlock()
	fake.NewManagedNodeGroupTaskStub = stub
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskArgsForCall(i int) ([]*v1alpha5.ManagedNodeGroup, bool) {
	fake.newManagedNodeGroupTaskMutex.RLock()
	defer fake.newManagedNodeGroupTaskMutex.RUnlock()
	argsForCall := fake.newManagedNodeGroupTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskReturns(result1 *tasks.TaskTree) {
	fake.newManagedNodeGroupTaskMutex.Lock()
	defer fake.newManagedNodeGroupTaskMutex.Unlock()
	fake.NewManagedNodeGroupTaskStub = nil
	fake.newManagedNodeGroupTaskReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newManagedNodeGroupTaskMutex.Lock()
	defer fake.newManagedNodeGroupTaskMutex.Unlock()
	fake.NewManagedNodeGroupTaskStub = nil
	if fake.newManagedNodeGroupTaskReturnsOnCall == nil {
		fake.newManagedNodeGroupTaskReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newManagedNodeGroupTaskReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTaskToDeleteAddonIAM(arg1 bool) (*tasks.TaskTree, error) {
	fake.newTaskToDeleteAddonIAMMutex.Lock()
	ret, specificReturn := fake.newTaskToDeleteAddonIAMReturnsOnCall[len(fake.newTaskToDeleteAddonIAMArgsForCall)]
	fake.newTaskToDeleteAddonIAMArgsForCall = append(fake.newTaskToDeleteAddonIAMArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.NewTaskToDeleteAddonIAMStub
	fakeReturns := fake.newTaskToDeleteAddonIAMReturns
	fake.recordInvocation("NewTaskToDeleteAddonIAM", []interface{}{arg1})
	fake.newTaskToDeleteAddonIAMMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTaskToDeleteAddonIAMCallCount() int {
	fake.newTaskToDeleteAddonIAMMutex.RLock()
	defer fake.newTaskToDeleteAddonIAMMutex.RUnlock()
	return len(fake.newTaskToDeleteAddonIAMArgsForCall)
}

func (fake *FakeStackManager) NewTaskToDeleteAddonIAMCalls(stub func(bool) (*tasks.TaskTree, error)) {
	fake.newTaskToDeleteAddonIAMMutex.Lock()
	defer fake.newTaskToDeleteAddonIAMMutex.Unlock()
	fake.NewTaskToDeleteAddonIAMStub = stub
}

func (fake *FakeStackManager) NewTaskToDeleteAddonIAMArgsForCall(i int) bool {
	fake.newTaskToDeleteAddonIAMMutex.RLock()
	defer fake.newTaskToDeleteAddonIAMMutex.RUnlock()
	argsForCall := fake.newTaskToDeleteAddonIAMArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) NewTaskToDeleteAddonIAMReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTaskToDeleteAddonIAMMutex.Lock()
	defer fake.newTaskToDeleteAddonIAMMutex.Unlock()
	fake.NewTaskToDeleteAddonIAMStub = nil
	fake.newTaskToDeleteAddonIAMReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTaskToDeleteAddonIAMReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTaskToDeleteAddonIAMMutex.Lock()
	defer fake.newTaskToDeleteAddonIAMMutex.Unlock()
	fake.NewTaskToDeleteAddonIAMStub = nil
	if fake.newTaskToDeleteAddonIAMReturnsOnCall == nil {
		fake.newTaskToDeleteAddonIAMReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTaskToDeleteAddonIAMReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToCreateClusterWithNodeGroups(arg1 []*v1alpha5.NodeGroup, arg2 []*v1alpha5.ManagedNodeGroup, arg3 bool, arg4 ...tasks.Task) *tasks.TaskTree {
	var arg1Copy []*v1alpha5.NodeGroup
	if arg1 != nil {
		arg1Copy = make([]*v1alpha5.NodeGroup, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []*v1alpha5.ManagedNodeGroup
	if arg2 != nil {
		arg2Copy = make([]*v1alpha5.ManagedNodeGroup, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newTasksToCreateClusterWithNodeGroupsMutex.Lock()
	ret, specificReturn := fake.newTasksToCreateClusterWithNodeGroupsReturnsOnCall[len(fake.newTasksToCreateClusterWithNodeGroupsArgsForCall)]
	fake.newTasksToCreateClusterWithNodeGroupsArgsForCall = append(fake.newTasksToCreateClusterWithNodeGroupsArgsForCall, struct {
		arg1 []*v1alpha5.NodeGroup
		arg2 []*v1alpha5.ManagedNodeGroup
		arg3 bool
		arg4 []tasks.Task
	}{arg1Copy, arg2Copy, arg3, arg4})
	stub := fake.NewTasksToCreateClusterWithNodeGroupsStub
	fakeReturns := fake.newTasksToCreateClusterWithNodeGroupsReturns
	fake.recordInvocation("NewTasksToCreateClusterWithNodeGroups", []interface{}{arg1Copy, arg2Copy, arg3, arg4})
	fake.newTasksToCreateClusterWithNodeGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewTasksToCreateClusterWithNodeGroupsCallCount() int {
	fake.newTasksToCreateClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToCreateClusterWithNodeGroupsMutex.RUnlock()
	return len(fake.newTasksToCreateClusterWithNodeGroupsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToCreateClusterWithNodeGroupsCalls(stub func([]*v1alpha5.NodeGroup, []*v1alpha5.ManagedNodeGroup, bool, ...tasks.Task) *tasks.TaskTree) {
	fake.newTasksToCreateClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToCreateClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToCreateClusterWithNodeGroupsStub = stub
}

func (fake *FakeStackManager) NewTasksToCreateClusterWithNodeGroupsArgsForCall(i int) ([]*v1alpha5.NodeGroup, []*v1alpha5.ManagedNodeGroup, bool, []tasks.Task) {
	fake.newTasksToCreateClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToCreateClusterWithNodeGroupsMutex.RUnlock()
	argsForCall := fake.newTasksToCreateClusterWithNodeGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStackManager) NewTasksToCreateClusterWithNodeGroupsReturns(result1 *tasks.TaskTree) {
	fake.newTasksToCreateClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToCreateClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToCreateClusterWithNodeGroupsStub = nil
	fake.newTasksToCreateClusterWithNodeGroupsReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateClusterWithNodeGroupsReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newTasksToCreateClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToCreateClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToCreateClusterWithNodeGroupsStub = nil
	if fake.newTasksToCreateClusterWithNodeGroupsReturnsOnCall == nil {
		fake.newTasksToCreateClusterWithNodeGroupsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newTasksToCreateClusterWithNodeGroupsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccounts(arg1 []*v1alpha5.ClusterIAMServiceAccount, arg2 *iamoidc.OpenIDConnectManager, arg3 kubernetes.ClientSetGetter) *tasks.TaskTree {
	var arg1Copy []*v1alpha5.ClusterIAMServiceAccount
	if arg1 != nil {
		arg1Copy = make([]*v1alpha5.ClusterIAMServiceAccount, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.newTasksToCreateIAMServiceAccountsReturnsOnCall[len(fake.newTasksToCreateIAMServiceAccountsArgsForCall)]
	fake.newTasksToCreateIAMServiceAccountsArgsForCall = append(fake.newTasksToCreateIAMServiceAccountsArgsForCall, struct {
		arg1 []*v1alpha5.ClusterIAMServiceAccount
		arg2 *iamoidc.OpenIDConnectManager
		arg3 kubernetes.ClientSetGetter
	}{arg1Copy, arg2, arg3})
	stub := fake.NewTasksToCreateIAMServiceAccountsStub
	fakeReturns := fake.newTasksToCreateIAMServiceAccountsReturns
	fake.recordInvocation("NewTasksToCreateIAMServiceAccounts", []interface{}{arg1Copy, arg2, arg3})
	fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsCallCount() int {
	fake.newTasksToCreateIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.RUnlock()
	return len(fake.newTasksToCreateIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsCalls(stub func([]*v1alpha5.ClusterIAMServiceAccount, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) *tasks.TaskTree) {
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToCreateIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsArgsForCall(i int) ([]*v1alpha5.ClusterIAMServiceAccount, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) {
	fake.newTasksToCreateIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.newTasksToCreateIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsReturns(result1 *tasks.TaskTree) {
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToCreateIAMServiceAccountsStub = nil
	fake.newTasksToCreateIAMServiceAccountsReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToCreateIAMServiceAccountsStub = nil
	if fake.newTasksToCreateIAMServiceAccountsReturnsOnCall == nil {
		fake.newTasksToCreateIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newTasksToCreateIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroups(arg1 bool, arg2 *iamoidc.OpenIDConnectManager, arg3 kubernetes.ClientSetGetter, arg4 bool, arg5 func(chan error, string) error) (*tasks.TaskTree, error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall[len(fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall)]
	fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall = append(fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall, struct {
		arg1 bool
		arg2 *iamoidc.OpenIDConnectManager
		arg3 kubernetes.ClientSetGetter
		arg4 bool
		arg5 func(chan error, string) error
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NewTasksToDeleteClusterWithNodeGroupsStub
	fakeReturns := fake.newTasksToDeleteClusterWithNodeGroupsReturns
	fake.recordInvocation("NewTasksToDeleteClusterWithNodeGroups", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsCallCount() int {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.RUnlock()
	return len(fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsCalls(stub func(bool, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter, bool, func(chan error, string) error) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteClusterWithNodeGroupsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsArgsForCall(i int) (bool, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter, bool, func(chan error, string) error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteClusterWithNodeGroupsStub = nil
	fake.newTasksToDeleteClusterWithNodeGroupsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteClusterWithNodeGroupsStub = nil
	if fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall == nil {
		fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccounts(arg1 func(string) bool, arg2 kubernetes.ClientSetGetter, arg3 bool) (*tasks.TaskTree, error) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall[len(fake.newTasksToDeleteIAMServiceAccountsArgsForCall)]
	fake.newTasksToDeleteIAMServiceAccountsArgsForCall = append(fake.newTasksToDeleteIAMServiceAccountsArgsForCall, struct {
		arg1 func(string) bool
		arg2 kubernetes.ClientSetGetter
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.NewTasksToDeleteIAMServiceAccountsStub
	fakeReturns := fake.newTasksToDeleteIAMServiceAccountsReturns
	fake.recordInvocation("NewTasksToDeleteIAMServiceAccounts", []interface{}{arg1, arg2, arg3})
	fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsCallCount() int {
	fake.newTasksToDeleteIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.RUnlock()
	return len(fake.newTasksToDeleteIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsCalls(stub func(func(string) bool, kubernetes.ClientSetGetter, bool) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsArgsForCall(i int) (func(string) bool, kubernetes.ClientSetGetter, bool) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteIAMServiceAccountsStub = nil
	fake.newTasksToDeleteIAMServiceAccountsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteIAMServiceAccountsStub = nil
	if fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall == nil {
		fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroups(arg1 func(string) bool, arg2 bool, arg3 func(chan error, string) error) (*tasks.TaskTree, error) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteNodeGroupsReturnsOnCall[len(fake.newTasksToDeleteNodeGroupsArgsForCall)]
	fake.newTasksToDeleteNodeGroupsArgsForCall = append(fake.newTasksToDeleteNodeGroupsArgsForCall, struct {
		arg1 func(string) bool
		arg2 bool
		arg3 func(chan error, string) error
	}{arg1, arg2, arg3})
	stub := fake.NewTasksToDeleteNodeGroupsStub
	fakeReturns := fake.newTasksToDeleteNodeGroupsReturns
	fake.recordInvocation("NewTasksToDeleteNodeGroups", []interface{}{arg1, arg2, arg3})
	fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsCallCount() int {
	fake.newTasksToDeleteNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteNodeGroupsMutex.RUnlock()
	return len(fake.newTasksToDeleteNodeGroupsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsCalls(stub func(func(string) bool, bool, func(chan error, string) error) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteNodeGroupsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsArgsForCall(i int) (func(string) bool, bool, func(chan error, string) error) {
	fake.newTasksToDeleteNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteNodeGroupsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteNodeGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteNodeGroupsStub = nil
	fake.newTasksToDeleteNodeGroupsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteNodeGroupsStub = nil
	if fake.newTasksToDeleteNodeGroupsReturnsOnCall == nil {
		fake.newTasksToDeleteNodeGroupsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteNodeGroupsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccounts(arg1 *iamoidc.OpenIDConnectManager, arg2 kubernetes.ClientSetGetter) (*tasks.TaskTree, error) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall[len(fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall)]
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall = append(fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall, struct {
		arg1 *iamoidc.OpenIDConnectManager
		arg2 kubernetes.ClientSetGetter
	}{arg1, arg2})
	stub := fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub
	fakeReturns := fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns
	fake.recordInvocation("NewTasksToDeleteOIDCProviderWithIAMServiceAccounts", []interface{}{arg1, arg2})
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsCallCount() int {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RUnlock()
	return len(fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsCalls(stub func(*iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall(i int) (*iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub = nil
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub = nil
	if fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall == nil {
		fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTask(arg1 []*v1alpha5.NodeGroup, arg2 bool, arg3 bool) *tasks.TaskTree {
	var arg1Copy []*v1alpha5.NodeGroup
	if arg1 != nil {
		arg1Copy = make([]*v1alpha5.NodeGroup, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	ret, specificReturn := fake.newUnmanagedNodeGroupTaskReturnsOnCall[len(fake.newUnmanagedNodeGroupTaskArgsForCall)]
	fake.newUnmanagedNodeGroupTaskArgsForCall = append(fake.newUnmanagedNodeGroupTaskArgsForCall, struct {
		arg1 []*v1alpha5.NodeGroup
		arg2 bool
		arg3 bool
	}{arg1Copy, arg2, arg3})
	stub := fake.NewUnmanagedNodeGroupTaskStub
	fakeReturns := fake.newUnmanagedNodeGroupTaskReturns
	fake.recordInvocation("NewUnmanagedNodeGroupTask", []interface{}{arg1Copy, arg2, arg3})
	fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskCallCount() int {
	fake.newUnmanagedNodeGroupTaskMutex.RLock()
	defer fake.newUnmanagedNodeGroupTaskMutex.RUnlock()
	return len(fake.newUnmanagedNodeGroupTaskArgsForCall)
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskCalls(stub func([]*v1alpha5.NodeGroup, bool, bool) *tasks.TaskTree) {
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	defer fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	fake.NewUnmanagedNodeGroupTaskStub = stub
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskArgsForCall(i int) ([]*v1alpha5.NodeGroup, bool, bool) {
	fake.newUnmanagedNodeGroupTaskMutex.RLock()
	defer fake.newUnmanagedNodeGroupTaskMutex.RUnlock()
	argsForCall := fake.newUnmanagedNodeGroupTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskReturns(result1 *tasks.TaskTree) {
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	defer fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	fake.NewUnmanagedNodeGroupTaskStub = nil
	fake.newUnmanagedNodeGroupTaskReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	defer fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	fake.NewUnmanagedNodeGroupTaskStub = nil
	if fake.newUnmanagedNodeGroupTaskReturnsOnCall == nil {
		fake.newUnmanagedNodeGroupTaskReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newUnmanagedNodeGroupTaskReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARN() error {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	ret, specificReturn := fake.refreshFargatePodExecutionRoleARNReturnsOnCall[len(fake.refreshFargatePodExecutionRoleARNArgsForCall)]
	fake.refreshFargatePodExecutionRoleARNArgsForCall = append(fake.refreshFargatePodExecutionRoleARNArgsForCall, struct {
	}{})
	stub := fake.RefreshFargatePodExecutionRoleARNStub
	fakeReturns := fake.refreshFargatePodExecutionRoleARNReturns
	fake.recordInvocation("RefreshFargatePodExecutionRoleARN", []interface{}{})
	fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNCallCount() int {
	fake.refreshFargatePodExecutionRoleARNMutex.RLock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.RUnlock()
	return len(fake.refreshFargatePodExecutionRoleARNArgsForCall)
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNCalls(stub func() error) {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	fake.RefreshFargatePodExecutionRoleARNStub = stub
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNReturns(result1 error) {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	fake.RefreshFargatePodExecutionRoleARNStub = nil
	fake.refreshFargatePodExecutionRoleARNReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNReturnsOnCall(i int, result1 error) {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	fake.RefreshFargatePodExecutionRoleARNStub = nil
	if fake.refreshFargatePodExecutionRoleARNReturnsOnCall == nil {
		fake.refreshFargatePodExecutionRoleARNReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshFargatePodExecutionRoleARNReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) ScaleNodeGroup(arg1 *v1alpha5.NodeGroup) error {
	fake.scaleNodeGroupMutex.Lock()
	ret, specificReturn := fake.scaleNodeGroupReturnsOnCall[len(fake.scaleNodeGroupArgsForCall)]
	fake.scaleNodeGroupArgsForCall = append(fake.scaleNodeGroupArgsForCall, struct {
		arg1 *v1alpha5.NodeGroup
	}{arg1})
	stub := fake.ScaleNodeGroupStub
	fakeReturns := fake.scaleNodeGroupReturns
	fake.recordInvocation("ScaleNodeGroup", []interface{}{arg1})
	fake.scaleNodeGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) ScaleNodeGroupCallCount() int {
	fake.scaleNodeGroupMutex.RLock()
	defer fake.scaleNodeGroupMutex.RUnlock()
	return len(fake.scaleNodeGroupArgsForCall)
}

func (fake *FakeStackManager) ScaleNodeGroupCalls(stub func(*v1alpha5.NodeGroup) error) {
	fake.scaleNodeGroupMutex.Lock()
	defer fake.scaleNodeGroupMutex.Unlock()
	fake.ScaleNodeGroupStub = stub
}

func (fake *FakeStackManager) ScaleNodeGroupArgsForCall(i int) *v1alpha5.NodeGroup {
	fake.scaleNodeGroupMutex.RLock()
	defer fake.scaleNodeGroupMutex.RUnlock()
	argsForCall := fake.scaleNodeGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ScaleNodeGroupReturns(result1 error) {
	fake.scaleNodeGroupMutex.Lock()
	defer fake.scaleNodeGroupMutex.Unlock()
	fake.ScaleNodeGroupStub = nil
	fake.scaleNodeGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) ScaleNodeGroupReturnsOnCall(i int, result1 error) {
	fake.scaleNodeGroupMutex.Lock()
	defer fake.scaleNodeGroupMutex.Unlock()
	fake.ScaleNodeGroupStub = nil
	if fake.scaleNodeGroupReturnsOnCall == nil {
		fake.scaleNodeGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scaleNodeGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) StackStatusIsNotReady(arg1 *cloudformation.Stack) bool {
	fake.stackStatusIsNotReadyMutex.Lock()
	ret, specificReturn := fake.stackStatusIsNotReadyReturnsOnCall[len(fake.stackStatusIsNotReadyArgsForCall)]
	fake.stackStatusIsNotReadyArgsForCall = append(fake.stackStatusIsNotReadyArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.StackStatusIsNotReadyStub
	fakeReturns := fake.stackStatusIsNotReadyReturns
	fake.recordInvocation("StackStatusIsNotReady", []interface{}{arg1})
	fake.stackStatusIsNotReadyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) StackStatusIsNotReadyCallCount() int {
	fake.stackStatusIsNotReadyMutex.RLock()
	defer fake.stackStatusIsNotReadyMutex.RUnlock()
	return len(fake.stackStatusIsNotReadyArgsForCall)
}

func (fake *FakeStackManager) StackStatusIsNotReadyCalls(stub func(*cloudformation.Stack) bool) {
	fake.stackStatusIsNotReadyMutex.Lock()
	defer fake.stackStatusIsNotReadyMutex.Unlock()
	fake.StackStatusIsNotReadyStub = stub
}

func (fake *FakeStackManager) StackStatusIsNotReadyArgsForCall(i int) *cloudformation.Stack {
	fake.stackStatusIsNotReadyMutex.RLock()
	defer fake.stackStatusIsNotReadyMutex.RUnlock()
	argsForCall := fake.stackStatusIsNotReadyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) StackStatusIsNotReadyReturns(result1 bool) {
	fake.stackStatusIsNotReadyMutex.Lock()
	defer fake.stackStatusIsNotReadyMutex.Unlock()
	fake.StackStatusIsNotReadyStub = nil
	fake.stackStatusIsNotReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStackManager) StackStatusIsNotReadyReturnsOnCall(i int, result1 bool) {
	fake.stackStatusIsNotReadyMutex.Lock()
	defer fake.stackStatusIsNotReadyMutex.Unlock()
	fake.StackStatusIsNotReadyStub = nil
	if fake.stackStatusIsNotReadyReturnsOnCall == nil {
		fake.stackStatusIsNotReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.stackStatusIsNotReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStackManager) StackStatusIsNotTransitional(arg1 *cloudformation.Stack) bool {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	ret, specificReturn := fake.stackStatusIsNotTransitionalReturnsOnCall[len(fake.stackStatusIsNotTransitionalArgsForCall)]
	fake.stackStatusIsNotTransitionalArgsForCall = append(fake.stackStatusIsNotTransitionalArgsForCall, struct {
		arg1 *cloudformation.Stack
	}{arg1})
	stub := fake.StackStatusIsNotTransitionalStub
	fakeReturns := fake.stackStatusIsNotTransitionalReturns
	fake.recordInvocation("StackStatusIsNotTransitional", []interface{}{arg1})
	fake.stackStatusIsNotTransitionalMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalCallCount() int {
	fake.stackStatusIsNotTransitionalMutex.RLock()
	defer fake.stackStatusIsNotTransitionalMutex.RUnlock()
	return len(fake.stackStatusIsNotTransitionalArgsForCall)
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalCalls(stub func(*cloudformation.Stack) bool) {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	defer fake.stackStatusIsNotTransitionalMutex.Unlock()
	fake.StackStatusIsNotTransitionalStub = stub
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalArgsForCall(i int) *cloudformation.Stack {
	fake.stackStatusIsNotTransitionalMutex.RLock()
	defer fake.stackStatusIsNotTransitionalMutex.RUnlock()
	argsForCall := fake.stackStatusIsNotTransitionalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalReturns(result1 bool) {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	defer fake.stackStatusIsNotTransitionalMutex.Unlock()
	fake.StackStatusIsNotTransitionalStub = nil
	fake.stackStatusIsNotTransitionalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalReturnsOnCall(i int, result1 bool) {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	defer fake.stackStatusIsNotTransitionalMutex.Unlock()
	fake.StackStatusIsNotTransitionalStub = nil
	if fake.stackStatusIsNotTransitionalReturnsOnCall == nil {
		fake.stackStatusIsNotTransitionalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.stackStatusIsNotTransitionalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStackManager) UpdateNodeGroupStack(arg1 string, arg2 string) error {
	fake.updateNodeGroupStackMutex.Lock()
	ret, specificReturn := fake.updateNodeGroupStackReturnsOnCall[len(fake.updateNodeGroupStackArgsForCall)]
	fake.updateNodeGroupStackArgsForCall = append(fake.updateNodeGroupStackArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateNodeGroupStackStub
	fakeReturns := fake.updateNodeGroupStackReturns
	fake.recordInvocation("UpdateNodeGroupStack", []interface{}{arg1, arg2})
	fake.updateNodeGroupStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) UpdateNodeGroupStackCallCount() int {
	fake.updateNodeGroupStackMutex.RLock()
	defer fake.updateNodeGroupStackMutex.RUnlock()
	return len(fake.updateNodeGroupStackArgsForCall)
}

func (fake *FakeStackManager) UpdateNodeGroupStackCalls(stub func(string, string) error) {
	fake.updateNodeGroupStackMutex.Lock()
	defer fake.updateNodeGroupStackMutex.Unlock()
	fake.UpdateNodeGroupStackStub = stub
}

func (fake *FakeStackManager) UpdateNodeGroupStackArgsForCall(i int) (string, string) {
	fake.updateNodeGroupStackMutex.RLock()
	defer fake.updateNodeGroupStackMutex.RUnlock()
	argsForCall := fake.updateNodeGroupStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) UpdateNodeGroupStackReturns(result1 error) {
	fake.updateNodeGroupStackMutex.Lock()
	defer fake.updateNodeGroupStackMutex.Unlock()
	fake.UpdateNodeGroupStackStub = nil
	fake.updateNodeGroupStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) UpdateNodeGroupStackReturnsOnCall(i int, result1 error) {
	fake.updateNodeGroupStackMutex.Lock()
	defer fake.updateNodeGroupStackMutex.Unlock()
	fake.UpdateNodeGroupStackStub = nil
	if fake.updateNodeGroupStackReturnsOnCall == nil {
		fake.updateNodeGroupStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateNodeGroupStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) UpdateStack(arg1 string, arg2 string, arg3 string, arg4 manager.TemplateData, arg5 map[string]string) error {
	fake.updateStackMutex.Lock()
	ret, specificReturn := fake.updateStackReturnsOnCall[len(fake.updateStackArgsForCall)]
	fake.updateStackArgsForCall = append(fake.updateStackArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 manager.TemplateData
		arg5 map[string]string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateStackStub
	fakeReturns := fake.updateStackReturns
	fake.recordInvocation("UpdateStack", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) UpdateStackCallCount() int {
	fake.updateStackMutex.RLock()
	defer fake.updateStackMutex.RUnlock()
	return len(fake.updateStackArgsForCall)
}

func (fake *FakeStackManager) UpdateStackCalls(stub func(string, string, string, manager.TemplateData, map[string]string) error) {
	fake.updateStackMutex.Lock()
	defer fake.updateStackMutex.Unlock()
	fake.UpdateStackStub = stub
}

func (fake *FakeStackManager) UpdateStackArgsForCall(i int) (string, string, string, manager.TemplateData, map[string]string) {
	fake.updateStackMutex.RLock()
	defer fake.updateStackMutex.RUnlock()
	argsForCall := fake.updateStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStackManager) UpdateStackReturns(result1 error) {
	fake.updateStackMutex.Lock()
	defer fake.updateStackMutex.Unlock()
	fake.UpdateStackStub = nil
	fake.updateStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) UpdateStackReturnsOnCall(i int, result1 error) {
	fake.updateStackMutex.Lock()
	defer fake.updateStackMutex.Unlock()
	fake.UpdateStackStub = nil
	if fake.updateStackReturnsOnCall == nil {
		fake.updateStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appendNewClusterStackResourceMutex.RLock()
	defer fake.appendNewClusterStackResourceMutex.RUnlock()
	fake.createStackMutex.RLock()
	defer fake.createStackMutex.RUnlock()
	fake.deleteStackByNameMutex.RLock()
	defer fake.deleteStackByNameMutex.RUnlock()
	fake.deleteStackByNameSyncMutex.RLock()
	defer fake.deleteStackByNameSyncMutex.RUnlock()
	fake.deleteStackBySpecMutex.RLock()
	defer fake.deleteStackBySpecMutex.RUnlock()
	fake.deleteStackBySpecSyncMutex.RLock()
	defer fake.deleteStackBySpecSyncMutex.RUnlock()
	fake.deleteTasksForDeprecatedStacksMutex.RLock()
	defer fake.deleteTasksForDeprecatedStacksMutex.RUnlock()
	fake.describeClusterStackMutex.RLock()
	defer fake.describeClusterStackMutex.RUnlock()
	fake.describeIAMServiceAccountStacksMutex.RLock()
	defer fake.describeIAMServiceAccountStacksMutex.RUnlock()
	fake.describeNodeGroupStackMutex.RLock()
	defer fake.describeNodeGroupStackMutex.RUnlock()
	fake.describeNodeGroupStacksMutex.RLock()
	defer fake.describeNodeGroupStacksMutex.RUnlock()
	fake.describeNodeGroupStacksAndResourcesMutex.RLock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.RUnlock()
	fake.describeStackMutex.RLock()
	defer fake.describeStackMutex.RUnlock()
	fake.describeStackChangeSetMutex.RLock()
	defer fake.describeStackChangeSetMutex.RUnlock()
	fake.describeStackEventsMutex.RLock()
	defer fake.describeStackEventsMutex.RUnlock()
	fake.describeStacksMutex.RLock()
	defer fake.describeStacksMutex.RUnlock()
	fake.doCreateStackRequestMutex.RLock()
	defer fake.doCreateStackRequestMutex.RUnlock()
	fake.doWaitUntilStackIsCreatedMutex.RLock()
	defer fake.doWaitUntilStackIsCreatedMutex.RUnlock()
	fake.ensureMapPublicIPOnLaunchEnabledMutex.RLock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.RUnlock()
	fake.errStackNotFoundMutex.RLock()
	defer fake.errStackNotFoundMutex.RUnlock()
	fake.fixClusterCompatibilityMutex.RLock()
	defer fake.fixClusterCompatibilityMutex.RUnlock()
	fake.getAutoScalingGroupNameMutex.RLock()
	defer fake.getAutoScalingGroupNameMutex.RUnlock()
	fake.getFargateStackMutex.RLock()
	defer fake.getFargateStackMutex.RUnlock()
	fake.getIAMAddonNameMutex.RLock()
	defer fake.getIAMAddonNameMutex.RUnlock()
	fake.getIAMAddonsStacksMutex.RLock()
	defer fake.getIAMAddonsStacksMutex.RUnlock()
	fake.getIAMServiceAccountsMutex.RLock()
	defer fake.getIAMServiceAccountsMutex.RUnlock()
	fake.getManagedNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getManagedNodeGroupAutoScalingGroupNameMutex.RUnlock()
	fake.getManagedNodeGroupTemplateMutex.RLock()
	defer fake.getManagedNodeGroupTemplateMutex.RUnlock()
	fake.getNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getNodeGroupAutoScalingGroupNameMutex.RUnlock()
	fake.getNodeGroupNameMutex.RLock()
	defer fake.getNodeGroupNameMutex.RUnlock()
	fake.getNodeGroupStackTypeMutex.RLock()
	defer fake.getNodeGroupStackTypeMutex.RUnlock()
	fake.getNodeGroupSummariesMutex.RLock()
	defer fake.getNodeGroupSummariesMutex.RUnlock()
	fake.getStackTemplateMutex.RLock()
	defer fake.getStackTemplateMutex.RUnlock()
	fake.hasClusterStackMutex.RLock()
	defer fake.hasClusterStackMutex.RUnlock()
	fake.hasClusterStackUsingCachedListMutex.RLock()
	defer fake.hasClusterStackUsingCachedListMutex.RUnlock()
	fake.listClusterStackNamesMutex.RLock()
	defer fake.listClusterStackNamesMutex.RUnlock()
	fake.listIAMServiceAccountStacksMutex.RLock()
	defer fake.listIAMServiceAccountStacksMutex.RUnlock()
	fake.listNodeGroupStacksMutex.RLock()
	defer fake.listNodeGroupStacksMutex.RUnlock()
	fake.listStacksMutex.RLock()
	defer fake.listStacksMutex.RUnlock()
	fake.listStacksMatchingMutex.RLock()
	defer fake.listStacksMatchingMutex.RUnlock()
	fake.lookupCloudTrailEventsMutex.RLock()
	defer fake.lookupCloudTrailEventsMutex.RUnlock()
	fake.makeChangeSetNameMutex.RLock()
	defer fake.makeChangeSetNameMutex.RUnlock()
	fake.newClusterCompatTaskMutex.RLock()
	defer fake.newClusterCompatTaskMutex.RUnlock()
	fake.newManagedNodeGroupTaskMutex.RLock()
	defer fake.newManagedNodeGroupTaskMutex.RUnlock()
	fake.newTaskToDeleteAddonIAMMutex.RLock()
	defer fake.newTaskToDeleteAddonIAMMutex.RUnlock()
	fake.newTasksToCreateClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToCreateClusterWithNodeGroupsMutex.RUnlock()
	fake.newTasksToCreateIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.RUnlock()
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.RUnlock()
	fake.newTasksToDeleteIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.RUnlock()
	fake.newTasksToDeleteNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteNodeGroupsMutex.RUnlock()
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RUnlock()
	fake.newUnmanagedNodeGroupTaskMutex.RLock()
	defer fake.newUnmanagedNodeGroupTaskMutex.RUnlock()
	fake.refreshFargatePodExecutionRoleARNMutex.RLock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.RUnlock()
	fake.scaleNodeGroupMutex.RLock()
	defer fake.scaleNodeGroupMutex.RUnlock()
	fake.stackStatusIsNotReadyMutex.RLock()
	defer fake.stackStatusIsNotReadyMutex.RUnlock()
	fake.stackStatusIsNotTransitionalMutex.RLock()
	defer fake.stackStatusIsNotTransitionalMutex.RUnlock()
	fake.updateNodeGroupStackMutex.RLock()
	defer fake.updateNodeGroupStackMutex.RUnlock()
	fake.updateStackMutex.RLock()
	defer fake.updateStackMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStackManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ manager.StackManager = new(FakeStackManager)
