// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocksv2

import (
	context "context"

	ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"
	mock "github.com/stretchr/testify/mock"
)

// EC2 is an autogenerated mock type for the EC2 type
type EC2 struct {
	mock.Mock
}

type EC2_Expecter struct {
	mock *mock.Mock
}

func (_m *EC2) EXPECT() *EC2_Expecter {
	return &EC2_Expecter{mock: &_m.Mock}
}

// AcceptReservedInstancesExchangeQuote provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptReservedInstancesExchangeQuote(ctx context.Context, params *ec2.AcceptReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptReservedInstancesExchangeQuote")
	}

	var r0 *ec2.AcceptReservedInstancesExchangeQuoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) *ec2.AcceptReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptReservedInstancesExchangeQuoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AcceptReservedInstancesExchangeQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptReservedInstancesExchangeQuote'
type EC2_AcceptReservedInstancesExchangeQuote_Call struct {
	*mock.Call
}

// AcceptReservedInstancesExchangeQuote is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AcceptReservedInstancesExchangeQuoteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AcceptReservedInstancesExchangeQuote(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AcceptReservedInstancesExchangeQuote_Call {
	return &EC2_AcceptReservedInstancesExchangeQuote_Call{Call: _e.mock.On("AcceptReservedInstancesExchangeQuote",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AcceptReservedInstancesExchangeQuote_Call) Run(run func(ctx context.Context, params *ec2.AcceptReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options))) *EC2_AcceptReservedInstancesExchangeQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AcceptReservedInstancesExchangeQuoteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AcceptReservedInstancesExchangeQuote_Call) Return(_a0 *ec2.AcceptReservedInstancesExchangeQuoteOutput, _a1 error) *EC2_AcceptReservedInstancesExchangeQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AcceptReservedInstancesExchangeQuote_Call) RunAndReturn(run func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error)) *EC2_AcceptReservedInstancesExchangeQuote_Call {
	_c.Call.Return(run)
	return _c
}

// AcceptTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptTransitGatewayMulticastDomainAssociations")
	}

	var r0 *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AcceptTransitGatewayMulticastDomainAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptTransitGatewayMulticastDomainAssociations'
type EC2_AcceptTransitGatewayMulticastDomainAssociations_Call struct {
	*mock.Call
}

// AcceptTransitGatewayMulticastDomainAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AcceptTransitGatewayMulticastDomainAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call {
	return &EC2_AcceptTransitGatewayMulticastDomainAssociations_Call{Call: _e.mock.On("AcceptTransitGatewayMulticastDomainAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call) Run(run func(ctx context.Context, params *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options))) *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AcceptTransitGatewayMulticastDomainAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call) Return(_a0 *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, _a1 error) *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call) RunAndReturn(run func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error)) *EC2_AcceptTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// AcceptTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.AcceptTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.AcceptTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AcceptTransitGatewayPeeringAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptTransitGatewayPeeringAttachment'
type EC2_AcceptTransitGatewayPeeringAttachment_Call struct {
	*mock.Call
}

// AcceptTransitGatewayPeeringAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AcceptTransitGatewayPeeringAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AcceptTransitGatewayPeeringAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AcceptTransitGatewayPeeringAttachment_Call {
	return &EC2_AcceptTransitGatewayPeeringAttachment_Call{Call: _e.mock.On("AcceptTransitGatewayPeeringAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AcceptTransitGatewayPeeringAttachment_Call) Run(run func(ctx context.Context, params *ec2.AcceptTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options))) *EC2_AcceptTransitGatewayPeeringAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AcceptTransitGatewayPeeringAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AcceptTransitGatewayPeeringAttachment_Call) Return(_a0 *ec2.AcceptTransitGatewayPeeringAttachmentOutput, _a1 error) *EC2_AcceptTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AcceptTransitGatewayPeeringAttachment_Call) RunAndReturn(run func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error)) *EC2_AcceptTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// AcceptTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptTransitGatewayVpcAttachment(ctx context.Context, params *ec2.AcceptTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptTransitGatewayVpcAttachment")
	}

	var r0 *ec2.AcceptTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AcceptTransitGatewayVpcAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptTransitGatewayVpcAttachment'
type EC2_AcceptTransitGatewayVpcAttachment_Call struct {
	*mock.Call
}

// AcceptTransitGatewayVpcAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AcceptTransitGatewayVpcAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AcceptTransitGatewayVpcAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AcceptTransitGatewayVpcAttachment_Call {
	return &EC2_AcceptTransitGatewayVpcAttachment_Call{Call: _e.mock.On("AcceptTransitGatewayVpcAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AcceptTransitGatewayVpcAttachment_Call) Run(run func(ctx context.Context, params *ec2.AcceptTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options))) *EC2_AcceptTransitGatewayVpcAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AcceptTransitGatewayVpcAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AcceptTransitGatewayVpcAttachment_Call) Return(_a0 *ec2.AcceptTransitGatewayVpcAttachmentOutput, _a1 error) *EC2_AcceptTransitGatewayVpcAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AcceptTransitGatewayVpcAttachment_Call) RunAndReturn(run func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error)) *EC2_AcceptTransitGatewayVpcAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// AcceptVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptVpcEndpointConnections(ctx context.Context, params *ec2.AcceptVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptVpcEndpointConnections")
	}

	var r0 *ec2.AcceptVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.AcceptVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AcceptVpcEndpointConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptVpcEndpointConnections'
type EC2_AcceptVpcEndpointConnections_Call struct {
	*mock.Call
}

// AcceptVpcEndpointConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AcceptVpcEndpointConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AcceptVpcEndpointConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AcceptVpcEndpointConnections_Call {
	return &EC2_AcceptVpcEndpointConnections_Call{Call: _e.mock.On("AcceptVpcEndpointConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AcceptVpcEndpointConnections_Call) Run(run func(ctx context.Context, params *ec2.AcceptVpcEndpointConnectionsInput, optFns ...func(*ec2.Options))) *EC2_AcceptVpcEndpointConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AcceptVpcEndpointConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AcceptVpcEndpointConnections_Call) Return(_a0 *ec2.AcceptVpcEndpointConnectionsOutput, _a1 error) *EC2_AcceptVpcEndpointConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AcceptVpcEndpointConnections_Call) RunAndReturn(run func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error)) *EC2_AcceptVpcEndpointConnections_Call {
	_c.Call.Return(run)
	return _c
}

// AcceptVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptVpcPeeringConnection(ctx context.Context, params *ec2.AcceptVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptVpcPeeringConnection")
	}

	var r0 *ec2.AcceptVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.AcceptVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AcceptVpcPeeringConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptVpcPeeringConnection'
type EC2_AcceptVpcPeeringConnection_Call struct {
	*mock.Call
}

// AcceptVpcPeeringConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AcceptVpcPeeringConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AcceptVpcPeeringConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AcceptVpcPeeringConnection_Call {
	return &EC2_AcceptVpcPeeringConnection_Call{Call: _e.mock.On("AcceptVpcPeeringConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AcceptVpcPeeringConnection_Call) Run(run func(ctx context.Context, params *ec2.AcceptVpcPeeringConnectionInput, optFns ...func(*ec2.Options))) *EC2_AcceptVpcPeeringConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AcceptVpcPeeringConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AcceptVpcPeeringConnection_Call) Return(_a0 *ec2.AcceptVpcPeeringConnectionOutput, _a1 error) *EC2_AcceptVpcPeeringConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AcceptVpcPeeringConnection_Call) RunAndReturn(run func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error)) *EC2_AcceptVpcPeeringConnection_Call {
	_c.Call.Return(run)
	return _c
}

// AdvertiseByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AdvertiseByoipCidr(ctx context.Context, params *ec2.AdvertiseByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AdvertiseByoipCidr")
	}

	var r0 *ec2.AdvertiseByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) *ec2.AdvertiseByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AdvertiseByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AdvertiseByoipCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AdvertiseByoipCidr'
type EC2_AdvertiseByoipCidr_Call struct {
	*mock.Call
}

// AdvertiseByoipCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AdvertiseByoipCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AdvertiseByoipCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AdvertiseByoipCidr_Call {
	return &EC2_AdvertiseByoipCidr_Call{Call: _e.mock.On("AdvertiseByoipCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AdvertiseByoipCidr_Call) Run(run func(ctx context.Context, params *ec2.AdvertiseByoipCidrInput, optFns ...func(*ec2.Options))) *EC2_AdvertiseByoipCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AdvertiseByoipCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AdvertiseByoipCidr_Call) Return(_a0 *ec2.AdvertiseByoipCidrOutput, _a1 error) *EC2_AdvertiseByoipCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AdvertiseByoipCidr_Call) RunAndReturn(run func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error)) *EC2_AdvertiseByoipCidr_Call {
	_c.Call.Return(run)
	return _c
}

// AllocateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AllocateAddress(ctx context.Context, params *ec2.AllocateAddressInput, optFns ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllocateAddress")
	}

	var r0 *ec2.AllocateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) *ec2.AllocateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AllocateAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateAddress'
type EC2_AllocateAddress_Call struct {
	*mock.Call
}

// AllocateAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AllocateAddressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AllocateAddress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AllocateAddress_Call {
	return &EC2_AllocateAddress_Call{Call: _e.mock.On("AllocateAddress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AllocateAddress_Call) Run(run func(ctx context.Context, params *ec2.AllocateAddressInput, optFns ...func(*ec2.Options))) *EC2_AllocateAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AllocateAddressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AllocateAddress_Call) Return(_a0 *ec2.AllocateAddressOutput, _a1 error) *EC2_AllocateAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AllocateAddress_Call) RunAndReturn(run func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error)) *EC2_AllocateAddress_Call {
	_c.Call.Return(run)
	return _c
}

// AllocateHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AllocateHosts(ctx context.Context, params *ec2.AllocateHostsInput, optFns ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllocateHosts")
	}

	var r0 *ec2.AllocateHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) *ec2.AllocateHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AllocateHosts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateHosts'
type EC2_AllocateHosts_Call struct {
	*mock.Call
}

// AllocateHosts is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AllocateHostsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AllocateHosts(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AllocateHosts_Call {
	return &EC2_AllocateHosts_Call{Call: _e.mock.On("AllocateHosts",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AllocateHosts_Call) Run(run func(ctx context.Context, params *ec2.AllocateHostsInput, optFns ...func(*ec2.Options))) *EC2_AllocateHosts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AllocateHostsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AllocateHosts_Call) Return(_a0 *ec2.AllocateHostsOutput, _a1 error) *EC2_AllocateHosts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AllocateHosts_Call) RunAndReturn(run func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error)) *EC2_AllocateHosts_Call {
	_c.Call.Return(run)
	return _c
}

// AllocateIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AllocateIpamPoolCidr(ctx context.Context, params *ec2.AllocateIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AllocateIpamPoolCidr")
	}

	var r0 *ec2.AllocateIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.AllocateIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AllocateIpamPoolCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocateIpamPoolCidr'
type EC2_AllocateIpamPoolCidr_Call struct {
	*mock.Call
}

// AllocateIpamPoolCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AllocateIpamPoolCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AllocateIpamPoolCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AllocateIpamPoolCidr_Call {
	return &EC2_AllocateIpamPoolCidr_Call{Call: _e.mock.On("AllocateIpamPoolCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AllocateIpamPoolCidr_Call) Run(run func(ctx context.Context, params *ec2.AllocateIpamPoolCidrInput, optFns ...func(*ec2.Options))) *EC2_AllocateIpamPoolCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AllocateIpamPoolCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AllocateIpamPoolCidr_Call) Return(_a0 *ec2.AllocateIpamPoolCidrOutput, _a1 error) *EC2_AllocateIpamPoolCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AllocateIpamPoolCidr_Call) RunAndReturn(run func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error)) *EC2_AllocateIpamPoolCidr_Call {
	_c.Call.Return(run)
	return _c
}

// ApplySecurityGroupsToClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ApplySecurityGroupsToClientVpnTargetNetwork(ctx context.Context, params *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplySecurityGroupsToClientVpnTargetNetwork")
	}

	var r0 *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplySecurityGroupsToClientVpnTargetNetwork'
type EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call struct {
	*mock.Call
}

// ApplySecurityGroupsToClientVpnTargetNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ApplySecurityGroupsToClientVpnTargetNetwork(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call {
	return &EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call{Call: _e.mock.On("ApplySecurityGroupsToClientVpnTargetNetwork",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call) Run(run func(ctx context.Context, params *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, optFns ...func(*ec2.Options))) *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call) Return(_a0 *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, _a1 error) *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call) RunAndReturn(run func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error)) *EC2_ApplySecurityGroupsToClientVpnTargetNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// AssignIpv6Addresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssignIpv6Addresses(ctx context.Context, params *ec2.AssignIpv6AddressesInput, optFns ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssignIpv6Addresses")
	}

	var r0 *ec2.AssignIpv6AddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) *ec2.AssignIpv6AddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignIpv6AddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssignIpv6Addresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignIpv6Addresses'
type EC2_AssignIpv6Addresses_Call struct {
	*mock.Call
}

// AssignIpv6Addresses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssignIpv6AddressesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssignIpv6Addresses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssignIpv6Addresses_Call {
	return &EC2_AssignIpv6Addresses_Call{Call: _e.mock.On("AssignIpv6Addresses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssignIpv6Addresses_Call) Run(run func(ctx context.Context, params *ec2.AssignIpv6AddressesInput, optFns ...func(*ec2.Options))) *EC2_AssignIpv6Addresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssignIpv6AddressesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssignIpv6Addresses_Call) Return(_a0 *ec2.AssignIpv6AddressesOutput, _a1 error) *EC2_AssignIpv6Addresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssignIpv6Addresses_Call) RunAndReturn(run func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error)) *EC2_AssignIpv6Addresses_Call {
	_c.Call.Return(run)
	return _c
}

// AssignPrivateIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssignPrivateIpAddresses(ctx context.Context, params *ec2.AssignPrivateIpAddressesInput, optFns ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssignPrivateIpAddresses")
	}

	var r0 *ec2.AssignPrivateIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) *ec2.AssignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignPrivateIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssignPrivateIpAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignPrivateIpAddresses'
type EC2_AssignPrivateIpAddresses_Call struct {
	*mock.Call
}

// AssignPrivateIpAddresses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssignPrivateIpAddressesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssignPrivateIpAddresses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssignPrivateIpAddresses_Call {
	return &EC2_AssignPrivateIpAddresses_Call{Call: _e.mock.On("AssignPrivateIpAddresses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssignPrivateIpAddresses_Call) Run(run func(ctx context.Context, params *ec2.AssignPrivateIpAddressesInput, optFns ...func(*ec2.Options))) *EC2_AssignPrivateIpAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssignPrivateIpAddressesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssignPrivateIpAddresses_Call) Return(_a0 *ec2.AssignPrivateIpAddressesOutput, _a1 error) *EC2_AssignPrivateIpAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssignPrivateIpAddresses_Call) RunAndReturn(run func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error)) *EC2_AssignPrivateIpAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateAddress(ctx context.Context, params *ec2.AssociateAddressInput, optFns ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAddress")
	}

	var r0 *ec2.AssociateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) *ec2.AssociateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateAddress'
type EC2_AssociateAddress_Call struct {
	*mock.Call
}

// AssociateAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateAddressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateAddress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateAddress_Call {
	return &EC2_AssociateAddress_Call{Call: _e.mock.On("AssociateAddress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateAddress_Call) Run(run func(ctx context.Context, params *ec2.AssociateAddressInput, optFns ...func(*ec2.Options))) *EC2_AssociateAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateAddressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateAddress_Call) Return(_a0 *ec2.AssociateAddressOutput, _a1 error) *EC2_AssociateAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateAddress_Call) RunAndReturn(run func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error)) *EC2_AssociateAddress_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateClientVpnTargetNetwork(ctx context.Context, params *ec2.AssociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateClientVpnTargetNetwork")
	}

	var r0 *ec2.AssociateClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.AssociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateClientVpnTargetNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateClientVpnTargetNetwork'
type EC2_AssociateClientVpnTargetNetwork_Call struct {
	*mock.Call
}

// AssociateClientVpnTargetNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateClientVpnTargetNetworkInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateClientVpnTargetNetwork(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateClientVpnTargetNetwork_Call {
	return &EC2_AssociateClientVpnTargetNetwork_Call{Call: _e.mock.On("AssociateClientVpnTargetNetwork",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateClientVpnTargetNetwork_Call) Run(run func(ctx context.Context, params *ec2.AssociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options))) *EC2_AssociateClientVpnTargetNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateClientVpnTargetNetworkInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateClientVpnTargetNetwork_Call) Return(_a0 *ec2.AssociateClientVpnTargetNetworkOutput, _a1 error) *EC2_AssociateClientVpnTargetNetwork_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateClientVpnTargetNetwork_Call) RunAndReturn(run func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error)) *EC2_AssociateClientVpnTargetNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateDhcpOptions(ctx context.Context, params *ec2.AssociateDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateDhcpOptions")
	}

	var r0 *ec2.AssociateDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) *ec2.AssociateDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateDhcpOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateDhcpOptions'
type EC2_AssociateDhcpOptions_Call struct {
	*mock.Call
}

// AssociateDhcpOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateDhcpOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateDhcpOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateDhcpOptions_Call {
	return &EC2_AssociateDhcpOptions_Call{Call: _e.mock.On("AssociateDhcpOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateDhcpOptions_Call) Run(run func(ctx context.Context, params *ec2.AssociateDhcpOptionsInput, optFns ...func(*ec2.Options))) *EC2_AssociateDhcpOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateDhcpOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateDhcpOptions_Call) Return(_a0 *ec2.AssociateDhcpOptionsOutput, _a1 error) *EC2_AssociateDhcpOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateDhcpOptions_Call) RunAndReturn(run func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error)) *EC2_AssociateDhcpOptions_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateEnclaveCertificateIamRole provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateEnclaveCertificateIamRole(ctx context.Context, params *ec2.AssociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateEnclaveCertificateIamRole")
	}

	var r0 *ec2.AssociateEnclaveCertificateIamRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) *ec2.AssociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateEnclaveCertificateIamRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateEnclaveCertificateIamRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateEnclaveCertificateIamRole'
type EC2_AssociateEnclaveCertificateIamRole_Call struct {
	*mock.Call
}

// AssociateEnclaveCertificateIamRole is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateEnclaveCertificateIamRoleInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateEnclaveCertificateIamRole(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateEnclaveCertificateIamRole_Call {
	return &EC2_AssociateEnclaveCertificateIamRole_Call{Call: _e.mock.On("AssociateEnclaveCertificateIamRole",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateEnclaveCertificateIamRole_Call) Run(run func(ctx context.Context, params *ec2.AssociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options))) *EC2_AssociateEnclaveCertificateIamRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateEnclaveCertificateIamRoleInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateEnclaveCertificateIamRole_Call) Return(_a0 *ec2.AssociateEnclaveCertificateIamRoleOutput, _a1 error) *EC2_AssociateEnclaveCertificateIamRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateEnclaveCertificateIamRole_Call) RunAndReturn(run func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error)) *EC2_AssociateEnclaveCertificateIamRole_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateIamInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateIamInstanceProfile(ctx context.Context, params *ec2.AssociateIamInstanceProfileInput, optFns ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateIamInstanceProfile")
	}

	var r0 *ec2.AssociateIamInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) *ec2.AssociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateIamInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateIamInstanceProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateIamInstanceProfile'
type EC2_AssociateIamInstanceProfile_Call struct {
	*mock.Call
}

// AssociateIamInstanceProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateIamInstanceProfileInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateIamInstanceProfile(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateIamInstanceProfile_Call {
	return &EC2_AssociateIamInstanceProfile_Call{Call: _e.mock.On("AssociateIamInstanceProfile",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateIamInstanceProfile_Call) Run(run func(ctx context.Context, params *ec2.AssociateIamInstanceProfileInput, optFns ...func(*ec2.Options))) *EC2_AssociateIamInstanceProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateIamInstanceProfileInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateIamInstanceProfile_Call) Return(_a0 *ec2.AssociateIamInstanceProfileOutput, _a1 error) *EC2_AssociateIamInstanceProfile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateIamInstanceProfile_Call) RunAndReturn(run func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error)) *EC2_AssociateIamInstanceProfile_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateInstanceEventWindow(ctx context.Context, params *ec2.AssociateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateInstanceEventWindow")
	}

	var r0 *ec2.AssociateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.AssociateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateInstanceEventWindow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateInstanceEventWindow'
type EC2_AssociateInstanceEventWindow_Call struct {
	*mock.Call
}

// AssociateInstanceEventWindow is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateInstanceEventWindowInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateInstanceEventWindow(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateInstanceEventWindow_Call {
	return &EC2_AssociateInstanceEventWindow_Call{Call: _e.mock.On("AssociateInstanceEventWindow",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateInstanceEventWindow_Call) Run(run func(ctx context.Context, params *ec2.AssociateInstanceEventWindowInput, optFns ...func(*ec2.Options))) *EC2_AssociateInstanceEventWindow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateInstanceEventWindowInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateInstanceEventWindow_Call) Return(_a0 *ec2.AssociateInstanceEventWindowOutput, _a1 error) *EC2_AssociateInstanceEventWindow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateInstanceEventWindow_Call) RunAndReturn(run func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error)) *EC2_AssociateInstanceEventWindow_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateRouteTable(ctx context.Context, params *ec2.AssociateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateRouteTable")
	}

	var r0 *ec2.AssociateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) *ec2.AssociateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateRouteTable'
type EC2_AssociateRouteTable_Call struct {
	*mock.Call
}

// AssociateRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateRouteTable_Call {
	return &EC2_AssociateRouteTable_Call{Call: _e.mock.On("AssociateRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateRouteTable_Call) Run(run func(ctx context.Context, params *ec2.AssociateRouteTableInput, optFns ...func(*ec2.Options))) *EC2_AssociateRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateRouteTable_Call) Return(_a0 *ec2.AssociateRouteTableOutput, _a1 error) *EC2_AssociateRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error)) *EC2_AssociateRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateSubnetCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateSubnetCidrBlock(ctx context.Context, params *ec2.AssociateSubnetCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateSubnetCidrBlock")
	}

	var r0 *ec2.AssociateSubnetCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) *ec2.AssociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateSubnetCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateSubnetCidrBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateSubnetCidrBlock'
type EC2_AssociateSubnetCidrBlock_Call struct {
	*mock.Call
}

// AssociateSubnetCidrBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateSubnetCidrBlockInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateSubnetCidrBlock(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateSubnetCidrBlock_Call {
	return &EC2_AssociateSubnetCidrBlock_Call{Call: _e.mock.On("AssociateSubnetCidrBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateSubnetCidrBlock_Call) Run(run func(ctx context.Context, params *ec2.AssociateSubnetCidrBlockInput, optFns ...func(*ec2.Options))) *EC2_AssociateSubnetCidrBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateSubnetCidrBlockInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateSubnetCidrBlock_Call) Return(_a0 *ec2.AssociateSubnetCidrBlockOutput, _a1 error) *EC2_AssociateSubnetCidrBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateSubnetCidrBlock_Call) RunAndReturn(run func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error)) *EC2_AssociateSubnetCidrBlock_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.AssociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTransitGatewayMulticastDomain")
	}

	var r0 *ec2.AssociateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateTransitGatewayMulticastDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateTransitGatewayMulticastDomain'
type EC2_AssociateTransitGatewayMulticastDomain_Call struct {
	*mock.Call
}

// AssociateTransitGatewayMulticastDomain is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateTransitGatewayMulticastDomainInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateTransitGatewayMulticastDomain(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateTransitGatewayMulticastDomain_Call {
	return &EC2_AssociateTransitGatewayMulticastDomain_Call{Call: _e.mock.On("AssociateTransitGatewayMulticastDomain",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateTransitGatewayMulticastDomain_Call) Run(run func(ctx context.Context, params *ec2.AssociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options))) *EC2_AssociateTransitGatewayMulticastDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateTransitGatewayMulticastDomainInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateTransitGatewayMulticastDomain_Call) Return(_a0 *ec2.AssociateTransitGatewayMulticastDomainOutput, _a1 error) *EC2_AssociateTransitGatewayMulticastDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateTransitGatewayMulticastDomain_Call) RunAndReturn(run func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error)) *EC2_AssociateTransitGatewayMulticastDomain_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateTransitGatewayRouteTable(ctx context.Context, params *ec2.AssociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTransitGatewayRouteTable")
	}

	var r0 *ec2.AssociateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateTransitGatewayRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateTransitGatewayRouteTable'
type EC2_AssociateTransitGatewayRouteTable_Call struct {
	*mock.Call
}

// AssociateTransitGatewayRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateTransitGatewayRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateTransitGatewayRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateTransitGatewayRouteTable_Call {
	return &EC2_AssociateTransitGatewayRouteTable_Call{Call: _e.mock.On("AssociateTransitGatewayRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateTransitGatewayRouteTable_Call) Run(run func(ctx context.Context, params *ec2.AssociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options))) *EC2_AssociateTransitGatewayRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateTransitGatewayRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateTransitGatewayRouteTable_Call) Return(_a0 *ec2.AssociateTransitGatewayRouteTableOutput, _a1 error) *EC2_AssociateTransitGatewayRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateTransitGatewayRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error)) *EC2_AssociateTransitGatewayRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateTrunkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateTrunkInterface(ctx context.Context, params *ec2.AssociateTrunkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateTrunkInterface")
	}

	var r0 *ec2.AssociateTrunkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) *ec2.AssociateTrunkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTrunkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateTrunkInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateTrunkInterface'
type EC2_AssociateTrunkInterface_Call struct {
	*mock.Call
}

// AssociateTrunkInterface is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateTrunkInterfaceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateTrunkInterface(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateTrunkInterface_Call {
	return &EC2_AssociateTrunkInterface_Call{Call: _e.mock.On("AssociateTrunkInterface",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateTrunkInterface_Call) Run(run func(ctx context.Context, params *ec2.AssociateTrunkInterfaceInput, optFns ...func(*ec2.Options))) *EC2_AssociateTrunkInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateTrunkInterfaceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateTrunkInterface_Call) Return(_a0 *ec2.AssociateTrunkInterfaceOutput, _a1 error) *EC2_AssociateTrunkInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateTrunkInterface_Call) RunAndReturn(run func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error)) *EC2_AssociateTrunkInterface_Call {
	_c.Call.Return(run)
	return _c
}

// AssociateVpcCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateVpcCidrBlock(ctx context.Context, params *ec2.AssociateVpcCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateVpcCidrBlock")
	}

	var r0 *ec2.AssociateVpcCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) *ec2.AssociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateVpcCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AssociateVpcCidrBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssociateVpcCidrBlock'
type EC2_AssociateVpcCidrBlock_Call struct {
	*mock.Call
}

// AssociateVpcCidrBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AssociateVpcCidrBlockInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AssociateVpcCidrBlock(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AssociateVpcCidrBlock_Call {
	return &EC2_AssociateVpcCidrBlock_Call{Call: _e.mock.On("AssociateVpcCidrBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AssociateVpcCidrBlock_Call) Run(run func(ctx context.Context, params *ec2.AssociateVpcCidrBlockInput, optFns ...func(*ec2.Options))) *EC2_AssociateVpcCidrBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AssociateVpcCidrBlockInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AssociateVpcCidrBlock_Call) Return(_a0 *ec2.AssociateVpcCidrBlockOutput, _a1 error) *EC2_AssociateVpcCidrBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AssociateVpcCidrBlock_Call) RunAndReturn(run func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error)) *EC2_AssociateVpcCidrBlock_Call {
	_c.Call.Return(run)
	return _c
}

// AttachClassicLinkVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachClassicLinkVpc(ctx context.Context, params *ec2.AttachClassicLinkVpcInput, optFns ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachClassicLinkVpc")
	}

	var r0 *ec2.AttachClassicLinkVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) *ec2.AttachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachClassicLinkVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AttachClassicLinkVpc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachClassicLinkVpc'
type EC2_AttachClassicLinkVpc_Call struct {
	*mock.Call
}

// AttachClassicLinkVpc is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AttachClassicLinkVpcInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AttachClassicLinkVpc(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AttachClassicLinkVpc_Call {
	return &EC2_AttachClassicLinkVpc_Call{Call: _e.mock.On("AttachClassicLinkVpc",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AttachClassicLinkVpc_Call) Run(run func(ctx context.Context, params *ec2.AttachClassicLinkVpcInput, optFns ...func(*ec2.Options))) *EC2_AttachClassicLinkVpc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AttachClassicLinkVpcInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AttachClassicLinkVpc_Call) Return(_a0 *ec2.AttachClassicLinkVpcOutput, _a1 error) *EC2_AttachClassicLinkVpc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AttachClassicLinkVpc_Call) RunAndReturn(run func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error)) *EC2_AttachClassicLinkVpc_Call {
	_c.Call.Return(run)
	return _c
}

// AttachInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachInternetGateway(ctx context.Context, params *ec2.AttachInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachInternetGateway")
	}

	var r0 *ec2.AttachInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) *ec2.AttachInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AttachInternetGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachInternetGateway'
type EC2_AttachInternetGateway_Call struct {
	*mock.Call
}

// AttachInternetGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AttachInternetGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AttachInternetGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AttachInternetGateway_Call {
	return &EC2_AttachInternetGateway_Call{Call: _e.mock.On("AttachInternetGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AttachInternetGateway_Call) Run(run func(ctx context.Context, params *ec2.AttachInternetGatewayInput, optFns ...func(*ec2.Options))) *EC2_AttachInternetGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AttachInternetGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AttachInternetGateway_Call) Return(_a0 *ec2.AttachInternetGatewayOutput, _a1 error) *EC2_AttachInternetGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AttachInternetGateway_Call) RunAndReturn(run func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error)) *EC2_AttachInternetGateway_Call {
	_c.Call.Return(run)
	return _c
}

// AttachNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachNetworkInterface(ctx context.Context, params *ec2.AttachNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachNetworkInterface")
	}

	var r0 *ec2.AttachNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.AttachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AttachNetworkInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachNetworkInterface'
type EC2_AttachNetworkInterface_Call struct {
	*mock.Call
}

// AttachNetworkInterface is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AttachNetworkInterfaceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AttachNetworkInterface(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AttachNetworkInterface_Call {
	return &EC2_AttachNetworkInterface_Call{Call: _e.mock.On("AttachNetworkInterface",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AttachNetworkInterface_Call) Run(run func(ctx context.Context, params *ec2.AttachNetworkInterfaceInput, optFns ...func(*ec2.Options))) *EC2_AttachNetworkInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AttachNetworkInterfaceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AttachNetworkInterface_Call) Return(_a0 *ec2.AttachNetworkInterfaceOutput, _a1 error) *EC2_AttachNetworkInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AttachNetworkInterface_Call) RunAndReturn(run func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error)) *EC2_AttachNetworkInterface_Call {
	_c.Call.Return(run)
	return _c
}

// AttachVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachVolume(ctx context.Context, params *ec2.AttachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachVolume")
	}

	var r0 *ec2.AttachVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) *ec2.AttachVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AttachVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachVolume'
type EC2_AttachVolume_Call struct {
	*mock.Call
}

// AttachVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AttachVolumeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AttachVolume(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AttachVolume_Call {
	return &EC2_AttachVolume_Call{Call: _e.mock.On("AttachVolume",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AttachVolume_Call) Run(run func(ctx context.Context, params *ec2.AttachVolumeInput, optFns ...func(*ec2.Options))) *EC2_AttachVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AttachVolumeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AttachVolume_Call) Return(_a0 *ec2.AttachVolumeOutput, _a1 error) *EC2_AttachVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AttachVolume_Call) RunAndReturn(run func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error)) *EC2_AttachVolume_Call {
	_c.Call.Return(run)
	return _c
}

// AttachVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachVpnGateway(ctx context.Context, params *ec2.AttachVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachVpnGateway")
	}

	var r0 *ec2.AttachVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) *ec2.AttachVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AttachVpnGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachVpnGateway'
type EC2_AttachVpnGateway_Call struct {
	*mock.Call
}

// AttachVpnGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AttachVpnGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AttachVpnGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AttachVpnGateway_Call {
	return &EC2_AttachVpnGateway_Call{Call: _e.mock.On("AttachVpnGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AttachVpnGateway_Call) Run(run func(ctx context.Context, params *ec2.AttachVpnGatewayInput, optFns ...func(*ec2.Options))) *EC2_AttachVpnGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AttachVpnGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AttachVpnGateway_Call) Return(_a0 *ec2.AttachVpnGatewayOutput, _a1 error) *EC2_AttachVpnGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AttachVpnGateway_Call) RunAndReturn(run func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error)) *EC2_AttachVpnGateway_Call {
	_c.Call.Return(run)
	return _c
}

// AuthorizeClientVpnIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AuthorizeClientVpnIngress(ctx context.Context, params *ec2.AuthorizeClientVpnIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeClientVpnIngress")
	}

	var r0 *ec2.AuthorizeClientVpnIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeClientVpnIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeClientVpnIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AuthorizeClientVpnIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeClientVpnIngress'
type EC2_AuthorizeClientVpnIngress_Call struct {
	*mock.Call
}

// AuthorizeClientVpnIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AuthorizeClientVpnIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AuthorizeClientVpnIngress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AuthorizeClientVpnIngress_Call {
	return &EC2_AuthorizeClientVpnIngress_Call{Call: _e.mock.On("AuthorizeClientVpnIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AuthorizeClientVpnIngress_Call) Run(run func(ctx context.Context, params *ec2.AuthorizeClientVpnIngressInput, optFns ...func(*ec2.Options))) *EC2_AuthorizeClientVpnIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AuthorizeClientVpnIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AuthorizeClientVpnIngress_Call) Return(_a0 *ec2.AuthorizeClientVpnIngressOutput, _a1 error) *EC2_AuthorizeClientVpnIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AuthorizeClientVpnIngress_Call) RunAndReturn(run func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error)) *EC2_AuthorizeClientVpnIngress_Call {
	_c.Call.Return(run)
	return _c
}

// AuthorizeSecurityGroupEgress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AuthorizeSecurityGroupEgress(ctx context.Context, params *ec2.AuthorizeSecurityGroupEgressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeSecurityGroupEgress")
	}

	var r0 *ec2.AuthorizeSecurityGroupEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AuthorizeSecurityGroupEgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeSecurityGroupEgress'
type EC2_AuthorizeSecurityGroupEgress_Call struct {
	*mock.Call
}

// AuthorizeSecurityGroupEgress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AuthorizeSecurityGroupEgressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AuthorizeSecurityGroupEgress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AuthorizeSecurityGroupEgress_Call {
	return &EC2_AuthorizeSecurityGroupEgress_Call{Call: _e.mock.On("AuthorizeSecurityGroupEgress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AuthorizeSecurityGroupEgress_Call) Run(run func(ctx context.Context, params *ec2.AuthorizeSecurityGroupEgressInput, optFns ...func(*ec2.Options))) *EC2_AuthorizeSecurityGroupEgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AuthorizeSecurityGroupEgressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AuthorizeSecurityGroupEgress_Call) Return(_a0 *ec2.AuthorizeSecurityGroupEgressOutput, _a1 error) *EC2_AuthorizeSecurityGroupEgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AuthorizeSecurityGroupEgress_Call) RunAndReturn(run func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error)) *EC2_AuthorizeSecurityGroupEgress_Call {
	_c.Call.Return(run)
	return _c
}

// AuthorizeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AuthorizeSecurityGroupIngress(ctx context.Context, params *ec2.AuthorizeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeSecurityGroupIngress")
	}

	var r0 *ec2.AuthorizeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_AuthorizeSecurityGroupIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeSecurityGroupIngress'
type EC2_AuthorizeSecurityGroupIngress_Call struct {
	*mock.Call
}

// AuthorizeSecurityGroupIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AuthorizeSecurityGroupIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) AuthorizeSecurityGroupIngress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_AuthorizeSecurityGroupIngress_Call {
	return &EC2_AuthorizeSecurityGroupIngress_Call{Call: _e.mock.On("AuthorizeSecurityGroupIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_AuthorizeSecurityGroupIngress_Call) Run(run func(ctx context.Context, params *ec2.AuthorizeSecurityGroupIngressInput, optFns ...func(*ec2.Options))) *EC2_AuthorizeSecurityGroupIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AuthorizeSecurityGroupIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_AuthorizeSecurityGroupIngress_Call) Return(_a0 *ec2.AuthorizeSecurityGroupIngressOutput, _a1 error) *EC2_AuthorizeSecurityGroupIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_AuthorizeSecurityGroupIngress_Call) RunAndReturn(run func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error)) *EC2_AuthorizeSecurityGroupIngress_Call {
	_c.Call.Return(run)
	return _c
}

// BundleInstance provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) BundleInstance(ctx context.Context, params *ec2.BundleInstanceInput, optFns ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BundleInstance")
	}

	var r0 *ec2.BundleInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) *ec2.BundleInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.BundleInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_BundleInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BundleInstance'
type EC2_BundleInstance_Call struct {
	*mock.Call
}

// BundleInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.BundleInstanceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) BundleInstance(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_BundleInstance_Call {
	return &EC2_BundleInstance_Call{Call: _e.mock.On("BundleInstance",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_BundleInstance_Call) Run(run func(ctx context.Context, params *ec2.BundleInstanceInput, optFns ...func(*ec2.Options))) *EC2_BundleInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.BundleInstanceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_BundleInstance_Call) Return(_a0 *ec2.BundleInstanceOutput, _a1 error) *EC2_BundleInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_BundleInstance_Call) RunAndReturn(run func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error)) *EC2_BundleInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CancelBundleTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelBundleTask(ctx context.Context, params *ec2.CancelBundleTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelBundleTask")
	}

	var r0 *ec2.CancelBundleTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) *ec2.CancelBundleTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelBundleTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelBundleTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelBundleTask'
type EC2_CancelBundleTask_Call struct {
	*mock.Call
}

// CancelBundleTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelBundleTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelBundleTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelBundleTask_Call {
	return &EC2_CancelBundleTask_Call{Call: _e.mock.On("CancelBundleTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelBundleTask_Call) Run(run func(ctx context.Context, params *ec2.CancelBundleTaskInput, optFns ...func(*ec2.Options))) *EC2_CancelBundleTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelBundleTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelBundleTask_Call) Return(_a0 *ec2.CancelBundleTaskOutput, _a1 error) *EC2_CancelBundleTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelBundleTask_Call) RunAndReturn(run func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error)) *EC2_CancelBundleTask_Call {
	_c.Call.Return(run)
	return _c
}

// CancelCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelCapacityReservation(ctx context.Context, params *ec2.CancelCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelCapacityReservation")
	}

	var r0 *ec2.CancelCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) *ec2.CancelCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelCapacityReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelCapacityReservation'
type EC2_CancelCapacityReservation_Call struct {
	*mock.Call
}

// CancelCapacityReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelCapacityReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelCapacityReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelCapacityReservation_Call {
	return &EC2_CancelCapacityReservation_Call{Call: _e.mock.On("CancelCapacityReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelCapacityReservation_Call) Run(run func(ctx context.Context, params *ec2.CancelCapacityReservationInput, optFns ...func(*ec2.Options))) *EC2_CancelCapacityReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelCapacityReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelCapacityReservation_Call) Return(_a0 *ec2.CancelCapacityReservationOutput, _a1 error) *EC2_CancelCapacityReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelCapacityReservation_Call) RunAndReturn(run func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error)) *EC2_CancelCapacityReservation_Call {
	_c.Call.Return(run)
	return _c
}

// CancelCapacityReservationFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelCapacityReservationFleets(ctx context.Context, params *ec2.CancelCapacityReservationFleetsInput, optFns ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelCapacityReservationFleets")
	}

	var r0 *ec2.CancelCapacityReservationFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) *ec2.CancelCapacityReservationFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelCapacityReservationFleets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelCapacityReservationFleets'
type EC2_CancelCapacityReservationFleets_Call struct {
	*mock.Call
}

// CancelCapacityReservationFleets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelCapacityReservationFleetsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelCapacityReservationFleets(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelCapacityReservationFleets_Call {
	return &EC2_CancelCapacityReservationFleets_Call{Call: _e.mock.On("CancelCapacityReservationFleets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelCapacityReservationFleets_Call) Run(run func(ctx context.Context, params *ec2.CancelCapacityReservationFleetsInput, optFns ...func(*ec2.Options))) *EC2_CancelCapacityReservationFleets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelCapacityReservationFleetsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelCapacityReservationFleets_Call) Return(_a0 *ec2.CancelCapacityReservationFleetsOutput, _a1 error) *EC2_CancelCapacityReservationFleets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelCapacityReservationFleets_Call) RunAndReturn(run func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error)) *EC2_CancelCapacityReservationFleets_Call {
	_c.Call.Return(run)
	return _c
}

// CancelConversionTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelConversionTask(ctx context.Context, params *ec2.CancelConversionTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelConversionTask")
	}

	var r0 *ec2.CancelConversionTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) *ec2.CancelConversionTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelConversionTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelConversionTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelConversionTask'
type EC2_CancelConversionTask_Call struct {
	*mock.Call
}

// CancelConversionTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelConversionTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelConversionTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelConversionTask_Call {
	return &EC2_CancelConversionTask_Call{Call: _e.mock.On("CancelConversionTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelConversionTask_Call) Run(run func(ctx context.Context, params *ec2.CancelConversionTaskInput, optFns ...func(*ec2.Options))) *EC2_CancelConversionTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelConversionTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelConversionTask_Call) Return(_a0 *ec2.CancelConversionTaskOutput, _a1 error) *EC2_CancelConversionTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelConversionTask_Call) RunAndReturn(run func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error)) *EC2_CancelConversionTask_Call {
	_c.Call.Return(run)
	return _c
}

// CancelExportTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelExportTask(ctx context.Context, params *ec2.CancelExportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelExportTask")
	}

	var r0 *ec2.CancelExportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) *ec2.CancelExportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelExportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelExportTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelExportTask'
type EC2_CancelExportTask_Call struct {
	*mock.Call
}

// CancelExportTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelExportTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelExportTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelExportTask_Call {
	return &EC2_CancelExportTask_Call{Call: _e.mock.On("CancelExportTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelExportTask_Call) Run(run func(ctx context.Context, params *ec2.CancelExportTaskInput, optFns ...func(*ec2.Options))) *EC2_CancelExportTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelExportTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelExportTask_Call) Return(_a0 *ec2.CancelExportTaskOutput, _a1 error) *EC2_CancelExportTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelExportTask_Call) RunAndReturn(run func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error)) *EC2_CancelExportTask_Call {
	_c.Call.Return(run)
	return _c
}

// CancelImportTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelImportTask(ctx context.Context, params *ec2.CancelImportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelImportTask")
	}

	var r0 *ec2.CancelImportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) *ec2.CancelImportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelImportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelImportTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelImportTask'
type EC2_CancelImportTask_Call struct {
	*mock.Call
}

// CancelImportTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelImportTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelImportTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelImportTask_Call {
	return &EC2_CancelImportTask_Call{Call: _e.mock.On("CancelImportTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelImportTask_Call) Run(run func(ctx context.Context, params *ec2.CancelImportTaskInput, optFns ...func(*ec2.Options))) *EC2_CancelImportTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelImportTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelImportTask_Call) Return(_a0 *ec2.CancelImportTaskOutput, _a1 error) *EC2_CancelImportTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelImportTask_Call) RunAndReturn(run func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error)) *EC2_CancelImportTask_Call {
	_c.Call.Return(run)
	return _c
}

// CancelReservedInstancesListing provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelReservedInstancesListing(ctx context.Context, params *ec2.CancelReservedInstancesListingInput, optFns ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelReservedInstancesListing")
	}

	var r0 *ec2.CancelReservedInstancesListingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) *ec2.CancelReservedInstancesListingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelReservedInstancesListingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelReservedInstancesListing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelReservedInstancesListing'
type EC2_CancelReservedInstancesListing_Call struct {
	*mock.Call
}

// CancelReservedInstancesListing is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelReservedInstancesListingInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelReservedInstancesListing(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelReservedInstancesListing_Call {
	return &EC2_CancelReservedInstancesListing_Call{Call: _e.mock.On("CancelReservedInstancesListing",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelReservedInstancesListing_Call) Run(run func(ctx context.Context, params *ec2.CancelReservedInstancesListingInput, optFns ...func(*ec2.Options))) *EC2_CancelReservedInstancesListing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelReservedInstancesListingInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelReservedInstancesListing_Call) Return(_a0 *ec2.CancelReservedInstancesListingOutput, _a1 error) *EC2_CancelReservedInstancesListing_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelReservedInstancesListing_Call) RunAndReturn(run func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error)) *EC2_CancelReservedInstancesListing_Call {
	_c.Call.Return(run)
	return _c
}

// CancelSpotFleetRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelSpotFleetRequests(ctx context.Context, params *ec2.CancelSpotFleetRequestsInput, optFns ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSpotFleetRequests")
	}

	var r0 *ec2.CancelSpotFleetRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) *ec2.CancelSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotFleetRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelSpotFleetRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelSpotFleetRequests'
type EC2_CancelSpotFleetRequests_Call struct {
	*mock.Call
}

// CancelSpotFleetRequests is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelSpotFleetRequestsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelSpotFleetRequests(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelSpotFleetRequests_Call {
	return &EC2_CancelSpotFleetRequests_Call{Call: _e.mock.On("CancelSpotFleetRequests",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelSpotFleetRequests_Call) Run(run func(ctx context.Context, params *ec2.CancelSpotFleetRequestsInput, optFns ...func(*ec2.Options))) *EC2_CancelSpotFleetRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelSpotFleetRequestsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelSpotFleetRequests_Call) Return(_a0 *ec2.CancelSpotFleetRequestsOutput, _a1 error) *EC2_CancelSpotFleetRequests_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelSpotFleetRequests_Call) RunAndReturn(run func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error)) *EC2_CancelSpotFleetRequests_Call {
	_c.Call.Return(run)
	return _c
}

// CancelSpotInstanceRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelSpotInstanceRequests(ctx context.Context, params *ec2.CancelSpotInstanceRequestsInput, optFns ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelSpotInstanceRequests")
	}

	var r0 *ec2.CancelSpotInstanceRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) *ec2.CancelSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotInstanceRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CancelSpotInstanceRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelSpotInstanceRequests'
type EC2_CancelSpotInstanceRequests_Call struct {
	*mock.Call
}

// CancelSpotInstanceRequests is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CancelSpotInstanceRequestsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CancelSpotInstanceRequests(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CancelSpotInstanceRequests_Call {
	return &EC2_CancelSpotInstanceRequests_Call{Call: _e.mock.On("CancelSpotInstanceRequests",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CancelSpotInstanceRequests_Call) Run(run func(ctx context.Context, params *ec2.CancelSpotInstanceRequestsInput, optFns ...func(*ec2.Options))) *EC2_CancelSpotInstanceRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CancelSpotInstanceRequestsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CancelSpotInstanceRequests_Call) Return(_a0 *ec2.CancelSpotInstanceRequestsOutput, _a1 error) *EC2_CancelSpotInstanceRequests_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CancelSpotInstanceRequests_Call) RunAndReturn(run func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error)) *EC2_CancelSpotInstanceRequests_Call {
	_c.Call.Return(run)
	return _c
}

// ConfirmProductInstance provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ConfirmProductInstance(ctx context.Context, params *ec2.ConfirmProductInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfirmProductInstance")
	}

	var r0 *ec2.ConfirmProductInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) *ec2.ConfirmProductInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ConfirmProductInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ConfirmProductInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfirmProductInstance'
type EC2_ConfirmProductInstance_Call struct {
	*mock.Call
}

// ConfirmProductInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ConfirmProductInstanceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ConfirmProductInstance(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ConfirmProductInstance_Call {
	return &EC2_ConfirmProductInstance_Call{Call: _e.mock.On("ConfirmProductInstance",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ConfirmProductInstance_Call) Run(run func(ctx context.Context, params *ec2.ConfirmProductInstanceInput, optFns ...func(*ec2.Options))) *EC2_ConfirmProductInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ConfirmProductInstanceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ConfirmProductInstance_Call) Return(_a0 *ec2.ConfirmProductInstanceOutput, _a1 error) *EC2_ConfirmProductInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ConfirmProductInstance_Call) RunAndReturn(run func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error)) *EC2_ConfirmProductInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CopyFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CopyFpgaImage(ctx context.Context, params *ec2.CopyFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyFpgaImage")
	}

	var r0 *ec2.CopyFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) *ec2.CopyFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CopyFpgaImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFpgaImage'
type EC2_CopyFpgaImage_Call struct {
	*mock.Call
}

// CopyFpgaImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CopyFpgaImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CopyFpgaImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CopyFpgaImage_Call {
	return &EC2_CopyFpgaImage_Call{Call: _e.mock.On("CopyFpgaImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CopyFpgaImage_Call) Run(run func(ctx context.Context, params *ec2.CopyFpgaImageInput, optFns ...func(*ec2.Options))) *EC2_CopyFpgaImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CopyFpgaImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CopyFpgaImage_Call) Return(_a0 *ec2.CopyFpgaImageOutput, _a1 error) *EC2_CopyFpgaImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CopyFpgaImage_Call) RunAndReturn(run func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error)) *EC2_CopyFpgaImage_Call {
	_c.Call.Return(run)
	return _c
}

// CopyImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CopyImage(ctx context.Context, params *ec2.CopyImageInput, optFns ...func(*ec2.Options)) (*ec2.CopyImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopyImage")
	}

	var r0 *ec2.CopyImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) (*ec2.CopyImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) *ec2.CopyImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CopyImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyImage'
type EC2_CopyImage_Call struct {
	*mock.Call
}

// CopyImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CopyImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CopyImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CopyImage_Call {
	return &EC2_CopyImage_Call{Call: _e.mock.On("CopyImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CopyImage_Call) Run(run func(ctx context.Context, params *ec2.CopyImageInput, optFns ...func(*ec2.Options))) *EC2_CopyImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CopyImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CopyImage_Call) Return(_a0 *ec2.CopyImageOutput, _a1 error) *EC2_CopyImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CopyImage_Call) RunAndReturn(run func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) (*ec2.CopyImageOutput, error)) *EC2_CopyImage_Call {
	_c.Call.Return(run)
	return _c
}

// CopySnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CopySnapshot(ctx context.Context, params *ec2.CopySnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CopySnapshot")
	}

	var r0 *ec2.CopySnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) *ec2.CopySnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopySnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CopySnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopySnapshot'
type EC2_CopySnapshot_Call struct {
	*mock.Call
}

// CopySnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CopySnapshotInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CopySnapshot(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CopySnapshot_Call {
	return &EC2_CopySnapshot_Call{Call: _e.mock.On("CopySnapshot",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CopySnapshot_Call) Run(run func(ctx context.Context, params *ec2.CopySnapshotInput, optFns ...func(*ec2.Options))) *EC2_CopySnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CopySnapshotInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CopySnapshot_Call) Return(_a0 *ec2.CopySnapshotOutput, _a1 error) *EC2_CopySnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CopySnapshot_Call) RunAndReturn(run func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error)) *EC2_CopySnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCapacityReservation(ctx context.Context, params *ec2.CreateCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCapacityReservation")
	}

	var r0 *ec2.CreateCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateCapacityReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCapacityReservation'
type EC2_CreateCapacityReservation_Call struct {
	*mock.Call
}

// CreateCapacityReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateCapacityReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateCapacityReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateCapacityReservation_Call {
	return &EC2_CreateCapacityReservation_Call{Call: _e.mock.On("CreateCapacityReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateCapacityReservation_Call) Run(run func(ctx context.Context, params *ec2.CreateCapacityReservationInput, optFns ...func(*ec2.Options))) *EC2_CreateCapacityReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateCapacityReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateCapacityReservation_Call) Return(_a0 *ec2.CreateCapacityReservationOutput, _a1 error) *EC2_CreateCapacityReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateCapacityReservation_Call) RunAndReturn(run func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error)) *EC2_CreateCapacityReservation_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCapacityReservationFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCapacityReservationFleet(ctx context.Context, params *ec2.CreateCapacityReservationFleetInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCapacityReservationFleet")
	}

	var r0 *ec2.CreateCapacityReservationFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateCapacityReservationFleet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCapacityReservationFleet'
type EC2_CreateCapacityReservationFleet_Call struct {
	*mock.Call
}

// CreateCapacityReservationFleet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateCapacityReservationFleetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateCapacityReservationFleet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateCapacityReservationFleet_Call {
	return &EC2_CreateCapacityReservationFleet_Call{Call: _e.mock.On("CreateCapacityReservationFleet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateCapacityReservationFleet_Call) Run(run func(ctx context.Context, params *ec2.CreateCapacityReservationFleetInput, optFns ...func(*ec2.Options))) *EC2_CreateCapacityReservationFleet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateCapacityReservationFleetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateCapacityReservationFleet_Call) Return(_a0 *ec2.CreateCapacityReservationFleetOutput, _a1 error) *EC2_CreateCapacityReservationFleet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateCapacityReservationFleet_Call) RunAndReturn(run func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error)) *EC2_CreateCapacityReservationFleet_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCarrierGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCarrierGateway(ctx context.Context, params *ec2.CreateCarrierGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCarrierGateway")
	}

	var r0 *ec2.CreateCarrierGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) *ec2.CreateCarrierGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCarrierGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateCarrierGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCarrierGateway'
type EC2_CreateCarrierGateway_Call struct {
	*mock.Call
}

// CreateCarrierGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateCarrierGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateCarrierGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateCarrierGateway_Call {
	return &EC2_CreateCarrierGateway_Call{Call: _e.mock.On("CreateCarrierGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateCarrierGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateCarrierGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateCarrierGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateCarrierGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateCarrierGateway_Call) Return(_a0 *ec2.CreateCarrierGatewayOutput, _a1 error) *EC2_CreateCarrierGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateCarrierGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error)) *EC2_CreateCarrierGateway_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateClientVpnEndpoint(ctx context.Context, params *ec2.CreateClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientVpnEndpoint")
	}

	var r0 *ec2.CreateClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.CreateClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateClientVpnEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClientVpnEndpoint'
type EC2_CreateClientVpnEndpoint_Call struct {
	*mock.Call
}

// CreateClientVpnEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateClientVpnEndpointInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateClientVpnEndpoint(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateClientVpnEndpoint_Call {
	return &EC2_CreateClientVpnEndpoint_Call{Call: _e.mock.On("CreateClientVpnEndpoint",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateClientVpnEndpoint_Call) Run(run func(ctx context.Context, params *ec2.CreateClientVpnEndpointInput, optFns ...func(*ec2.Options))) *EC2_CreateClientVpnEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateClientVpnEndpointInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateClientVpnEndpoint_Call) Return(_a0 *ec2.CreateClientVpnEndpointOutput, _a1 error) *EC2_CreateClientVpnEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateClientVpnEndpoint_Call) RunAndReturn(run func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error)) *EC2_CreateClientVpnEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClientVpnRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateClientVpnRoute(ctx context.Context, params *ec2.CreateClientVpnRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientVpnRoute")
	}

	var r0 *ec2.CreateClientVpnRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) *ec2.CreateClientVpnRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateClientVpnRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClientVpnRoute'
type EC2_CreateClientVpnRoute_Call struct {
	*mock.Call
}

// CreateClientVpnRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateClientVpnRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateClientVpnRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateClientVpnRoute_Call {
	return &EC2_CreateClientVpnRoute_Call{Call: _e.mock.On("CreateClientVpnRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateClientVpnRoute_Call) Run(run func(ctx context.Context, params *ec2.CreateClientVpnRouteInput, optFns ...func(*ec2.Options))) *EC2_CreateClientVpnRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateClientVpnRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateClientVpnRoute_Call) Return(_a0 *ec2.CreateClientVpnRouteOutput, _a1 error) *EC2_CreateClientVpnRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateClientVpnRoute_Call) RunAndReturn(run func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error)) *EC2_CreateClientVpnRoute_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCustomerGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCustomerGateway(ctx context.Context, params *ec2.CreateCustomerGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCustomerGateway")
	}

	var r0 *ec2.CreateCustomerGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) *ec2.CreateCustomerGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCustomerGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateCustomerGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCustomerGateway'
type EC2_CreateCustomerGateway_Call struct {
	*mock.Call
}

// CreateCustomerGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateCustomerGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateCustomerGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateCustomerGateway_Call {
	return &EC2_CreateCustomerGateway_Call{Call: _e.mock.On("CreateCustomerGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateCustomerGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateCustomerGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateCustomerGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateCustomerGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateCustomerGateway_Call) Return(_a0 *ec2.CreateCustomerGatewayOutput, _a1 error) *EC2_CreateCustomerGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateCustomerGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error)) *EC2_CreateCustomerGateway_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDefaultSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateDefaultSubnet(ctx context.Context, params *ec2.CreateDefaultSubnetInput, optFns ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDefaultSubnet")
	}

	var r0 *ec2.CreateDefaultSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) *ec2.CreateDefaultSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateDefaultSubnet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDefaultSubnet'
type EC2_CreateDefaultSubnet_Call struct {
	*mock.Call
}

// CreateDefaultSubnet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateDefaultSubnetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateDefaultSubnet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateDefaultSubnet_Call {
	return &EC2_CreateDefaultSubnet_Call{Call: _e.mock.On("CreateDefaultSubnet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateDefaultSubnet_Call) Run(run func(ctx context.Context, params *ec2.CreateDefaultSubnetInput, optFns ...func(*ec2.Options))) *EC2_CreateDefaultSubnet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateDefaultSubnetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateDefaultSubnet_Call) Return(_a0 *ec2.CreateDefaultSubnetOutput, _a1 error) *EC2_CreateDefaultSubnet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateDefaultSubnet_Call) RunAndReturn(run func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error)) *EC2_CreateDefaultSubnet_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDefaultVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateDefaultVpc(ctx context.Context, params *ec2.CreateDefaultVpcInput, optFns ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDefaultVpc")
	}

	var r0 *ec2.CreateDefaultVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) *ec2.CreateDefaultVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateDefaultVpc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDefaultVpc'
type EC2_CreateDefaultVpc_Call struct {
	*mock.Call
}

// CreateDefaultVpc is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateDefaultVpcInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateDefaultVpc(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateDefaultVpc_Call {
	return &EC2_CreateDefaultVpc_Call{Call: _e.mock.On("CreateDefaultVpc",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateDefaultVpc_Call) Run(run func(ctx context.Context, params *ec2.CreateDefaultVpcInput, optFns ...func(*ec2.Options))) *EC2_CreateDefaultVpc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateDefaultVpcInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateDefaultVpc_Call) Return(_a0 *ec2.CreateDefaultVpcOutput, _a1 error) *EC2_CreateDefaultVpc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateDefaultVpc_Call) RunAndReturn(run func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error)) *EC2_CreateDefaultVpc_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateDhcpOptions(ctx context.Context, params *ec2.CreateDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDhcpOptions")
	}

	var r0 *ec2.CreateDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) *ec2.CreateDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateDhcpOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDhcpOptions'
type EC2_CreateDhcpOptions_Call struct {
	*mock.Call
}

// CreateDhcpOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateDhcpOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateDhcpOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateDhcpOptions_Call {
	return &EC2_CreateDhcpOptions_Call{Call: _e.mock.On("CreateDhcpOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateDhcpOptions_Call) Run(run func(ctx context.Context, params *ec2.CreateDhcpOptionsInput, optFns ...func(*ec2.Options))) *EC2_CreateDhcpOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateDhcpOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateDhcpOptions_Call) Return(_a0 *ec2.CreateDhcpOptionsOutput, _a1 error) *EC2_CreateDhcpOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateDhcpOptions_Call) RunAndReturn(run func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error)) *EC2_CreateDhcpOptions_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEgressOnlyInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateEgressOnlyInternetGateway(ctx context.Context, params *ec2.CreateEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEgressOnlyInternetGateway")
	}

	var r0 *ec2.CreateEgressOnlyInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) *ec2.CreateEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateEgressOnlyInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateEgressOnlyInternetGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEgressOnlyInternetGateway'
type EC2_CreateEgressOnlyInternetGateway_Call struct {
	*mock.Call
}

// CreateEgressOnlyInternetGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateEgressOnlyInternetGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateEgressOnlyInternetGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateEgressOnlyInternetGateway_Call {
	return &EC2_CreateEgressOnlyInternetGateway_Call{Call: _e.mock.On("CreateEgressOnlyInternetGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateEgressOnlyInternetGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateEgressOnlyInternetGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateEgressOnlyInternetGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateEgressOnlyInternetGateway_Call) Return(_a0 *ec2.CreateEgressOnlyInternetGatewayOutput, _a1 error) *EC2_CreateEgressOnlyInternetGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateEgressOnlyInternetGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error)) *EC2_CreateEgressOnlyInternetGateway_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateFleet(ctx context.Context, params *ec2.CreateFleetInput, optFns ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFleet")
	}

	var r0 *ec2.CreateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) *ec2.CreateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateFleet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFleet'
type EC2_CreateFleet_Call struct {
	*mock.Call
}

// CreateFleet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateFleetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateFleet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateFleet_Call {
	return &EC2_CreateFleet_Call{Call: _e.mock.On("CreateFleet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateFleet_Call) Run(run func(ctx context.Context, params *ec2.CreateFleetInput, optFns ...func(*ec2.Options))) *EC2_CreateFleet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateFleetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateFleet_Call) Return(_a0 *ec2.CreateFleetOutput, _a1 error) *EC2_CreateFleet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateFleet_Call) RunAndReturn(run func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error)) *EC2_CreateFleet_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateFlowLogs(ctx context.Context, params *ec2.CreateFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlowLogs")
	}

	var r0 *ec2.CreateFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) *ec2.CreateFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateFlowLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFlowLogs'
type EC2_CreateFlowLogs_Call struct {
	*mock.Call
}

// CreateFlowLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateFlowLogsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateFlowLogs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateFlowLogs_Call {
	return &EC2_CreateFlowLogs_Call{Call: _e.mock.On("CreateFlowLogs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateFlowLogs_Call) Run(run func(ctx context.Context, params *ec2.CreateFlowLogsInput, optFns ...func(*ec2.Options))) *EC2_CreateFlowLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateFlowLogsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateFlowLogs_Call) Return(_a0 *ec2.CreateFlowLogsOutput, _a1 error) *EC2_CreateFlowLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateFlowLogs_Call) RunAndReturn(run func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error)) *EC2_CreateFlowLogs_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateFpgaImage(ctx context.Context, params *ec2.CreateFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFpgaImage")
	}

	var r0 *ec2.CreateFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) *ec2.CreateFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateFpgaImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFpgaImage'
type EC2_CreateFpgaImage_Call struct {
	*mock.Call
}

// CreateFpgaImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateFpgaImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateFpgaImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateFpgaImage_Call {
	return &EC2_CreateFpgaImage_Call{Call: _e.mock.On("CreateFpgaImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateFpgaImage_Call) Run(run func(ctx context.Context, params *ec2.CreateFpgaImageInput, optFns ...func(*ec2.Options))) *EC2_CreateFpgaImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateFpgaImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateFpgaImage_Call) Return(_a0 *ec2.CreateFpgaImageOutput, _a1 error) *EC2_CreateFpgaImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateFpgaImage_Call) RunAndReturn(run func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error)) *EC2_CreateFpgaImage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateImage(ctx context.Context, params *ec2.CreateImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateImage")
	}

	var r0 *ec2.CreateImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) (*ec2.CreateImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) *ec2.CreateImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateImage'
type EC2_CreateImage_Call struct {
	*mock.Call
}

// CreateImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateImage_Call {
	return &EC2_CreateImage_Call{Call: _e.mock.On("CreateImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateImage_Call) Run(run func(ctx context.Context, params *ec2.CreateImageInput, optFns ...func(*ec2.Options))) *EC2_CreateImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateImage_Call) Return(_a0 *ec2.CreateImageOutput, _a1 error) *EC2_CreateImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateImage_Call) RunAndReturn(run func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) (*ec2.CreateImageOutput, error)) *EC2_CreateImage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateInstanceEventWindow(ctx context.Context, params *ec2.CreateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstanceEventWindow")
	}

	var r0 *ec2.CreateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.CreateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateInstanceEventWindow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInstanceEventWindow'
type EC2_CreateInstanceEventWindow_Call struct {
	*mock.Call
}

// CreateInstanceEventWindow is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateInstanceEventWindowInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateInstanceEventWindow(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateInstanceEventWindow_Call {
	return &EC2_CreateInstanceEventWindow_Call{Call: _e.mock.On("CreateInstanceEventWindow",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateInstanceEventWindow_Call) Run(run func(ctx context.Context, params *ec2.CreateInstanceEventWindowInput, optFns ...func(*ec2.Options))) *EC2_CreateInstanceEventWindow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateInstanceEventWindowInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateInstanceEventWindow_Call) Return(_a0 *ec2.CreateInstanceEventWindowOutput, _a1 error) *EC2_CreateInstanceEventWindow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateInstanceEventWindow_Call) RunAndReturn(run func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error)) *EC2_CreateInstanceEventWindow_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInstanceExportTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateInstanceExportTask(ctx context.Context, params *ec2.CreateInstanceExportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInstanceExportTask")
	}

	var r0 *ec2.CreateInstanceExportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) *ec2.CreateInstanceExportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceExportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateInstanceExportTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInstanceExportTask'
type EC2_CreateInstanceExportTask_Call struct {
	*mock.Call
}

// CreateInstanceExportTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateInstanceExportTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateInstanceExportTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateInstanceExportTask_Call {
	return &EC2_CreateInstanceExportTask_Call{Call: _e.mock.On("CreateInstanceExportTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateInstanceExportTask_Call) Run(run func(ctx context.Context, params *ec2.CreateInstanceExportTaskInput, optFns ...func(*ec2.Options))) *EC2_CreateInstanceExportTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateInstanceExportTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateInstanceExportTask_Call) Return(_a0 *ec2.CreateInstanceExportTaskOutput, _a1 error) *EC2_CreateInstanceExportTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateInstanceExportTask_Call) RunAndReturn(run func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error)) *EC2_CreateInstanceExportTask_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateInternetGateway(ctx context.Context, params *ec2.CreateInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateInternetGateway")
	}

	var r0 *ec2.CreateInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) *ec2.CreateInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateInternetGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInternetGateway'
type EC2_CreateInternetGateway_Call struct {
	*mock.Call
}

// CreateInternetGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateInternetGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateInternetGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateInternetGateway_Call {
	return &EC2_CreateInternetGateway_Call{Call: _e.mock.On("CreateInternetGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateInternetGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateInternetGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateInternetGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateInternetGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateInternetGateway_Call) Return(_a0 *ec2.CreateInternetGatewayOutput, _a1 error) *EC2_CreateInternetGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateInternetGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error)) *EC2_CreateInternetGateway_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateIpam(ctx context.Context, params *ec2.CreateIpamInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpam")
	}

	var r0 *ec2.CreateIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) *ec2.CreateIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateIpam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIpam'
type EC2_CreateIpam_Call struct {
	*mock.Call
}

// CreateIpam is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateIpamInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateIpam(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateIpam_Call {
	return &EC2_CreateIpam_Call{Call: _e.mock.On("CreateIpam",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateIpam_Call) Run(run func(ctx context.Context, params *ec2.CreateIpamInput, optFns ...func(*ec2.Options))) *EC2_CreateIpam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateIpamInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateIpam_Call) Return(_a0 *ec2.CreateIpamOutput, _a1 error) *EC2_CreateIpam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateIpam_Call) RunAndReturn(run func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error)) *EC2_CreateIpam_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateIpamPool(ctx context.Context, params *ec2.CreateIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamPool")
	}

	var r0 *ec2.CreateIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) *ec2.CreateIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateIpamPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIpamPool'
type EC2_CreateIpamPool_Call struct {
	*mock.Call
}

// CreateIpamPool is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateIpamPoolInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateIpamPool(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateIpamPool_Call {
	return &EC2_CreateIpamPool_Call{Call: _e.mock.On("CreateIpamPool",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateIpamPool_Call) Run(run func(ctx context.Context, params *ec2.CreateIpamPoolInput, optFns ...func(*ec2.Options))) *EC2_CreateIpamPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateIpamPoolInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateIpamPool_Call) Return(_a0 *ec2.CreateIpamPoolOutput, _a1 error) *EC2_CreateIpamPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateIpamPool_Call) RunAndReturn(run func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error)) *EC2_CreateIpamPool_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateIpamScope(ctx context.Context, params *ec2.CreateIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIpamScope")
	}

	var r0 *ec2.CreateIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) *ec2.CreateIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateIpamScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIpamScope'
type EC2_CreateIpamScope_Call struct {
	*mock.Call
}

// CreateIpamScope is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateIpamScopeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateIpamScope(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateIpamScope_Call {
	return &EC2_CreateIpamScope_Call{Call: _e.mock.On("CreateIpamScope",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateIpamScope_Call) Run(run func(ctx context.Context, params *ec2.CreateIpamScopeInput, optFns ...func(*ec2.Options))) *EC2_CreateIpamScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateIpamScopeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateIpamScope_Call) Return(_a0 *ec2.CreateIpamScopeOutput, _a1 error) *EC2_CreateIpamScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateIpamScope_Call) RunAndReturn(run func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error)) *EC2_CreateIpamScope_Call {
	_c.Call.Return(run)
	return _c
}

// CreateKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateKeyPair(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateKeyPair")
	}

	var r0 *ec2.CreateKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) *ec2.CreateKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateKeyPair_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateKeyPair'
type EC2_CreateKeyPair_Call struct {
	*mock.Call
}

// CreateKeyPair is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateKeyPairInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateKeyPair(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateKeyPair_Call {
	return &EC2_CreateKeyPair_Call{Call: _e.mock.On("CreateKeyPair",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateKeyPair_Call) Run(run func(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options))) *EC2_CreateKeyPair_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateKeyPairInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateKeyPair_Call) Return(_a0 *ec2.CreateKeyPairOutput, _a1 error) *EC2_CreateKeyPair_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateKeyPair_Call) RunAndReturn(run func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error)) *EC2_CreateKeyPair_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLaunchTemplate(ctx context.Context, params *ec2.CreateLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLaunchTemplate")
	}

	var r0 *ec2.CreateLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) *ec2.CreateLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateLaunchTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLaunchTemplate'
type EC2_CreateLaunchTemplate_Call struct {
	*mock.Call
}

// CreateLaunchTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateLaunchTemplateInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateLaunchTemplate(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateLaunchTemplate_Call {
	return &EC2_CreateLaunchTemplate_Call{Call: _e.mock.On("CreateLaunchTemplate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateLaunchTemplate_Call) Run(run func(ctx context.Context, params *ec2.CreateLaunchTemplateInput, optFns ...func(*ec2.Options))) *EC2_CreateLaunchTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateLaunchTemplateInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateLaunchTemplate_Call) Return(_a0 *ec2.CreateLaunchTemplateOutput, _a1 error) *EC2_CreateLaunchTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateLaunchTemplate_Call) RunAndReturn(run func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error)) *EC2_CreateLaunchTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLaunchTemplateVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLaunchTemplateVersion(ctx context.Context, params *ec2.CreateLaunchTemplateVersionInput, optFns ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLaunchTemplateVersion")
	}

	var r0 *ec2.CreateLaunchTemplateVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) *ec2.CreateLaunchTemplateVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateLaunchTemplateVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLaunchTemplateVersion'
type EC2_CreateLaunchTemplateVersion_Call struct {
	*mock.Call
}

// CreateLaunchTemplateVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateLaunchTemplateVersionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateLaunchTemplateVersion(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateLaunchTemplateVersion_Call {
	return &EC2_CreateLaunchTemplateVersion_Call{Call: _e.mock.On("CreateLaunchTemplateVersion",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateLaunchTemplateVersion_Call) Run(run func(ctx context.Context, params *ec2.CreateLaunchTemplateVersionInput, optFns ...func(*ec2.Options))) *EC2_CreateLaunchTemplateVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateLaunchTemplateVersionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateLaunchTemplateVersion_Call) Return(_a0 *ec2.CreateLaunchTemplateVersionOutput, _a1 error) *EC2_CreateLaunchTemplateVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateLaunchTemplateVersion_Call) RunAndReturn(run func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error)) *EC2_CreateLaunchTemplateVersion_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLocalGatewayRoute(ctx context.Context, params *ec2.CreateLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayRoute")
	}

	var r0 *ec2.CreateLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateLocalGatewayRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLocalGatewayRoute'
type EC2_CreateLocalGatewayRoute_Call struct {
	*mock.Call
}

// CreateLocalGatewayRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateLocalGatewayRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateLocalGatewayRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateLocalGatewayRoute_Call {
	return &EC2_CreateLocalGatewayRoute_Call{Call: _e.mock.On("CreateLocalGatewayRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateLocalGatewayRoute_Call) Run(run func(ctx context.Context, params *ec2.CreateLocalGatewayRouteInput, optFns ...func(*ec2.Options))) *EC2_CreateLocalGatewayRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateLocalGatewayRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateLocalGatewayRoute_Call) Return(_a0 *ec2.CreateLocalGatewayRouteOutput, _a1 error) *EC2_CreateLocalGatewayRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateLocalGatewayRoute_Call) RunAndReturn(run func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error)) *EC2_CreateLocalGatewayRoute_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLocalGatewayRouteTableVpcAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLocalGatewayRouteTableVpcAssociation(ctx context.Context, params *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLocalGatewayRouteTableVpcAssociation")
	}

	var r0 *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateLocalGatewayRouteTableVpcAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLocalGatewayRouteTableVpcAssociation'
type EC2_CreateLocalGatewayRouteTableVpcAssociation_Call struct {
	*mock.Call
}

// CreateLocalGatewayRouteTableVpcAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateLocalGatewayRouteTableVpcAssociationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateLocalGatewayRouteTableVpcAssociation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call {
	return &EC2_CreateLocalGatewayRouteTableVpcAssociation_Call{Call: _e.mock.On("CreateLocalGatewayRouteTableVpcAssociation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call) Run(run func(ctx context.Context, params *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options))) *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateLocalGatewayRouteTableVpcAssociationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call) Return(_a0 *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, _a1 error) *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call) RunAndReturn(run func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error)) *EC2_CreateLocalGatewayRouteTableVpcAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// CreateManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateManagedPrefixList(ctx context.Context, params *ec2.CreateManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateManagedPrefixList")
	}

	var r0 *ec2.CreateManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) *ec2.CreateManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateManagedPrefixList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateManagedPrefixList'
type EC2_CreateManagedPrefixList_Call struct {
	*mock.Call
}

// CreateManagedPrefixList is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateManagedPrefixListInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateManagedPrefixList(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateManagedPrefixList_Call {
	return &EC2_CreateManagedPrefixList_Call{Call: _e.mock.On("CreateManagedPrefixList",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateManagedPrefixList_Call) Run(run func(ctx context.Context, params *ec2.CreateManagedPrefixListInput, optFns ...func(*ec2.Options))) *EC2_CreateManagedPrefixList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateManagedPrefixListInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateManagedPrefixList_Call) Return(_a0 *ec2.CreateManagedPrefixListOutput, _a1 error) *EC2_CreateManagedPrefixList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateManagedPrefixList_Call) RunAndReturn(run func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error)) *EC2_CreateManagedPrefixList_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNatGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNatGateway(ctx context.Context, params *ec2.CreateNatGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNatGateway")
	}

	var r0 *ec2.CreateNatGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) *ec2.CreateNatGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNatGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNatGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNatGateway'
type EC2_CreateNatGateway_Call struct {
	*mock.Call
}

// CreateNatGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNatGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNatGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNatGateway_Call {
	return &EC2_CreateNatGateway_Call{Call: _e.mock.On("CreateNatGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNatGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateNatGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateNatGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNatGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNatGateway_Call) Return(_a0 *ec2.CreateNatGatewayOutput, _a1 error) *EC2_CreateNatGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNatGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error)) *EC2_CreateNatGateway_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetworkAcl provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkAcl(ctx context.Context, params *ec2.CreateNetworkAclInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkAcl")
	}

	var r0 *ec2.CreateNetworkAclOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) *ec2.CreateNetworkAclOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNetworkAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkAcl'
type EC2_CreateNetworkAcl_Call struct {
	*mock.Call
}

// CreateNetworkAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNetworkAclInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNetworkAcl(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNetworkAcl_Call {
	return &EC2_CreateNetworkAcl_Call{Call: _e.mock.On("CreateNetworkAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNetworkAcl_Call) Run(run func(ctx context.Context, params *ec2.CreateNetworkAclInput, optFns ...func(*ec2.Options))) *EC2_CreateNetworkAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNetworkAclInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNetworkAcl_Call) Return(_a0 *ec2.CreateNetworkAclOutput, _a1 error) *EC2_CreateNetworkAcl_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNetworkAcl_Call) RunAndReturn(run func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error)) *EC2_CreateNetworkAcl_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkAclEntry(ctx context.Context, params *ec2.CreateNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkAclEntry")
	}

	var r0 *ec2.CreateNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.CreateNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNetworkAclEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkAclEntry'
type EC2_CreateNetworkAclEntry_Call struct {
	*mock.Call
}

// CreateNetworkAclEntry is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNetworkAclEntryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNetworkAclEntry(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNetworkAclEntry_Call {
	return &EC2_CreateNetworkAclEntry_Call{Call: _e.mock.On("CreateNetworkAclEntry",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNetworkAclEntry_Call) Run(run func(ctx context.Context, params *ec2.CreateNetworkAclEntryInput, optFns ...func(*ec2.Options))) *EC2_CreateNetworkAclEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNetworkAclEntryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNetworkAclEntry_Call) Return(_a0 *ec2.CreateNetworkAclEntryOutput, _a1 error) *EC2_CreateNetworkAclEntry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNetworkAclEntry_Call) RunAndReturn(run func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error)) *EC2_CreateNetworkAclEntry_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetworkInsightsAccessScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInsightsAccessScope(ctx context.Context, params *ec2.CreateNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInsightsAccessScope")
	}

	var r0 *ec2.CreateNetworkInsightsAccessScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) *ec2.CreateNetworkInsightsAccessScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInsightsAccessScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNetworkInsightsAccessScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkInsightsAccessScope'
type EC2_CreateNetworkInsightsAccessScope_Call struct {
	*mock.Call
}

// CreateNetworkInsightsAccessScope is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNetworkInsightsAccessScopeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNetworkInsightsAccessScope(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNetworkInsightsAccessScope_Call {
	return &EC2_CreateNetworkInsightsAccessScope_Call{Call: _e.mock.On("CreateNetworkInsightsAccessScope",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNetworkInsightsAccessScope_Call) Run(run func(ctx context.Context, params *ec2.CreateNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options))) *EC2_CreateNetworkInsightsAccessScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNetworkInsightsAccessScopeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNetworkInsightsAccessScope_Call) Return(_a0 *ec2.CreateNetworkInsightsAccessScopeOutput, _a1 error) *EC2_CreateNetworkInsightsAccessScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNetworkInsightsAccessScope_Call) RunAndReturn(run func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error)) *EC2_CreateNetworkInsightsAccessScope_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetworkInsightsPath provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInsightsPath(ctx context.Context, params *ec2.CreateNetworkInsightsPathInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInsightsPath")
	}

	var r0 *ec2.CreateNetworkInsightsPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) *ec2.CreateNetworkInsightsPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInsightsPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNetworkInsightsPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkInsightsPath'
type EC2_CreateNetworkInsightsPath_Call struct {
	*mock.Call
}

// CreateNetworkInsightsPath is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNetworkInsightsPathInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNetworkInsightsPath(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNetworkInsightsPath_Call {
	return &EC2_CreateNetworkInsightsPath_Call{Call: _e.mock.On("CreateNetworkInsightsPath",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNetworkInsightsPath_Call) Run(run func(ctx context.Context, params *ec2.CreateNetworkInsightsPathInput, optFns ...func(*ec2.Options))) *EC2_CreateNetworkInsightsPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNetworkInsightsPathInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNetworkInsightsPath_Call) Return(_a0 *ec2.CreateNetworkInsightsPathOutput, _a1 error) *EC2_CreateNetworkInsightsPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNetworkInsightsPath_Call) RunAndReturn(run func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error)) *EC2_CreateNetworkInsightsPath_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInterface(ctx context.Context, params *ec2.CreateNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInterface")
	}

	var r0 *ec2.CreateNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.CreateNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNetworkInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkInterface'
type EC2_CreateNetworkInterface_Call struct {
	*mock.Call
}

// CreateNetworkInterface is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNetworkInterfaceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNetworkInterface(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNetworkInterface_Call {
	return &EC2_CreateNetworkInterface_Call{Call: _e.mock.On("CreateNetworkInterface",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNetworkInterface_Call) Run(run func(ctx context.Context, params *ec2.CreateNetworkInterfaceInput, optFns ...func(*ec2.Options))) *EC2_CreateNetworkInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNetworkInterfaceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNetworkInterface_Call) Return(_a0 *ec2.CreateNetworkInterfaceOutput, _a1 error) *EC2_CreateNetworkInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNetworkInterface_Call) RunAndReturn(run func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error)) *EC2_CreateNetworkInterface_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetworkInterfacePermission provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInterfacePermission(ctx context.Context, params *ec2.CreateNetworkInterfacePermissionInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetworkInterfacePermission")
	}

	var r0 *ec2.CreateNetworkInterfacePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) *ec2.CreateNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfacePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateNetworkInterfacePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkInterfacePermission'
type EC2_CreateNetworkInterfacePermission_Call struct {
	*mock.Call
}

// CreateNetworkInterfacePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateNetworkInterfacePermissionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateNetworkInterfacePermission(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateNetworkInterfacePermission_Call {
	return &EC2_CreateNetworkInterfacePermission_Call{Call: _e.mock.On("CreateNetworkInterfacePermission",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateNetworkInterfacePermission_Call) Run(run func(ctx context.Context, params *ec2.CreateNetworkInterfacePermissionInput, optFns ...func(*ec2.Options))) *EC2_CreateNetworkInterfacePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateNetworkInterfacePermissionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateNetworkInterfacePermission_Call) Return(_a0 *ec2.CreateNetworkInterfacePermissionOutput, _a1 error) *EC2_CreateNetworkInterfacePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateNetworkInterfacePermission_Call) RunAndReturn(run func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error)) *EC2_CreateNetworkInterfacePermission_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePlacementGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreatePlacementGroup(ctx context.Context, params *ec2.CreatePlacementGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePlacementGroup")
	}

	var r0 *ec2.CreatePlacementGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) *ec2.CreatePlacementGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePlacementGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreatePlacementGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePlacementGroup'
type EC2_CreatePlacementGroup_Call struct {
	*mock.Call
}

// CreatePlacementGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreatePlacementGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreatePlacementGroup(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreatePlacementGroup_Call {
	return &EC2_CreatePlacementGroup_Call{Call: _e.mock.On("CreatePlacementGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreatePlacementGroup_Call) Run(run func(ctx context.Context, params *ec2.CreatePlacementGroupInput, optFns ...func(*ec2.Options))) *EC2_CreatePlacementGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreatePlacementGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreatePlacementGroup_Call) Return(_a0 *ec2.CreatePlacementGroupOutput, _a1 error) *EC2_CreatePlacementGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreatePlacementGroup_Call) RunAndReturn(run func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error)) *EC2_CreatePlacementGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePublicIpv4Pool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreatePublicIpv4Pool(ctx context.Context, params *ec2.CreatePublicIpv4PoolInput, optFns ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePublicIpv4Pool")
	}

	var r0 *ec2.CreatePublicIpv4PoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) *ec2.CreatePublicIpv4PoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePublicIpv4PoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreatePublicIpv4Pool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePublicIpv4Pool'
type EC2_CreatePublicIpv4Pool_Call struct {
	*mock.Call
}

// CreatePublicIpv4Pool is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreatePublicIpv4PoolInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreatePublicIpv4Pool(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreatePublicIpv4Pool_Call {
	return &EC2_CreatePublicIpv4Pool_Call{Call: _e.mock.On("CreatePublicIpv4Pool",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreatePublicIpv4Pool_Call) Run(run func(ctx context.Context, params *ec2.CreatePublicIpv4PoolInput, optFns ...func(*ec2.Options))) *EC2_CreatePublicIpv4Pool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreatePublicIpv4PoolInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreatePublicIpv4Pool_Call) Return(_a0 *ec2.CreatePublicIpv4PoolOutput, _a1 error) *EC2_CreatePublicIpv4Pool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreatePublicIpv4Pool_Call) RunAndReturn(run func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error)) *EC2_CreatePublicIpv4Pool_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReplaceRootVolumeTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateReplaceRootVolumeTask(ctx context.Context, params *ec2.CreateReplaceRootVolumeTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReplaceRootVolumeTask")
	}

	var r0 *ec2.CreateReplaceRootVolumeTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) *ec2.CreateReplaceRootVolumeTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReplaceRootVolumeTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateReplaceRootVolumeTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReplaceRootVolumeTask'
type EC2_CreateReplaceRootVolumeTask_Call struct {
	*mock.Call
}

// CreateReplaceRootVolumeTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateReplaceRootVolumeTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateReplaceRootVolumeTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateReplaceRootVolumeTask_Call {
	return &EC2_CreateReplaceRootVolumeTask_Call{Call: _e.mock.On("CreateReplaceRootVolumeTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateReplaceRootVolumeTask_Call) Run(run func(ctx context.Context, params *ec2.CreateReplaceRootVolumeTaskInput, optFns ...func(*ec2.Options))) *EC2_CreateReplaceRootVolumeTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateReplaceRootVolumeTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateReplaceRootVolumeTask_Call) Return(_a0 *ec2.CreateReplaceRootVolumeTaskOutput, _a1 error) *EC2_CreateReplaceRootVolumeTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateReplaceRootVolumeTask_Call) RunAndReturn(run func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error)) *EC2_CreateReplaceRootVolumeTask_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReservedInstancesListing provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateReservedInstancesListing(ctx context.Context, params *ec2.CreateReservedInstancesListingInput, optFns ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateReservedInstancesListing")
	}

	var r0 *ec2.CreateReservedInstancesListingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) *ec2.CreateReservedInstancesListingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReservedInstancesListingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateReservedInstancesListing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReservedInstancesListing'
type EC2_CreateReservedInstancesListing_Call struct {
	*mock.Call
}

// CreateReservedInstancesListing is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateReservedInstancesListingInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateReservedInstancesListing(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateReservedInstancesListing_Call {
	return &EC2_CreateReservedInstancesListing_Call{Call: _e.mock.On("CreateReservedInstancesListing",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateReservedInstancesListing_Call) Run(run func(ctx context.Context, params *ec2.CreateReservedInstancesListingInput, optFns ...func(*ec2.Options))) *EC2_CreateReservedInstancesListing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateReservedInstancesListingInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateReservedInstancesListing_Call) Return(_a0 *ec2.CreateReservedInstancesListingOutput, _a1 error) *EC2_CreateReservedInstancesListing_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateReservedInstancesListing_Call) RunAndReturn(run func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error)) *EC2_CreateReservedInstancesListing_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRestoreImageTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateRestoreImageTask(ctx context.Context, params *ec2.CreateRestoreImageTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRestoreImageTask")
	}

	var r0 *ec2.CreateRestoreImageTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) *ec2.CreateRestoreImageTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRestoreImageTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateRestoreImageTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRestoreImageTask'
type EC2_CreateRestoreImageTask_Call struct {
	*mock.Call
}

// CreateRestoreImageTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateRestoreImageTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateRestoreImageTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateRestoreImageTask_Call {
	return &EC2_CreateRestoreImageTask_Call{Call: _e.mock.On("CreateRestoreImageTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateRestoreImageTask_Call) Run(run func(ctx context.Context, params *ec2.CreateRestoreImageTaskInput, optFns ...func(*ec2.Options))) *EC2_CreateRestoreImageTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateRestoreImageTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateRestoreImageTask_Call) Return(_a0 *ec2.CreateRestoreImageTaskOutput, _a1 error) *EC2_CreateRestoreImageTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateRestoreImageTask_Call) RunAndReturn(run func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error)) *EC2_CreateRestoreImageTask_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateRoute(ctx context.Context, params *ec2.CreateRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRoute")
	}

	var r0 *ec2.CreateRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) *ec2.CreateRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRoute'
type EC2_CreateRoute_Call struct {
	*mock.Call
}

// CreateRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateRoute_Call {
	return &EC2_CreateRoute_Call{Call: _e.mock.On("CreateRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateRoute_Call) Run(run func(ctx context.Context, params *ec2.CreateRouteInput, optFns ...func(*ec2.Options))) *EC2_CreateRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateRoute_Call) Return(_a0 *ec2.CreateRouteOutput, _a1 error) *EC2_CreateRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateRoute_Call) RunAndReturn(run func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error)) *EC2_CreateRoute_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateRouteTable(ctx context.Context, params *ec2.CreateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRouteTable")
	}

	var r0 *ec2.CreateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) *ec2.CreateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRouteTable'
type EC2_CreateRouteTable_Call struct {
	*mock.Call
}

// CreateRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateRouteTable_Call {
	return &EC2_CreateRouteTable_Call{Call: _e.mock.On("CreateRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateRouteTable_Call) Run(run func(ctx context.Context, params *ec2.CreateRouteTableInput, optFns ...func(*ec2.Options))) *EC2_CreateRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateRouteTable_Call) Return(_a0 *ec2.CreateRouteTableOutput, _a1 error) *EC2_CreateRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error)) *EC2_CreateRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSecurityGroup(ctx context.Context, params *ec2.CreateSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSecurityGroup")
	}

	var r0 *ec2.CreateSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) *ec2.CreateSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateSecurityGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSecurityGroup'
type EC2_CreateSecurityGroup_Call struct {
	*mock.Call
}

// CreateSecurityGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSecurityGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateSecurityGroup(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateSecurityGroup_Call {
	return &EC2_CreateSecurityGroup_Call{Call: _e.mock.On("CreateSecurityGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateSecurityGroup_Call) Run(run func(ctx context.Context, params *ec2.CreateSecurityGroupInput, optFns ...func(*ec2.Options))) *EC2_CreateSecurityGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSecurityGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateSecurityGroup_Call) Return(_a0 *ec2.CreateSecurityGroupOutput, _a1 error) *EC2_CreateSecurityGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateSecurityGroup_Call) RunAndReturn(run func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error)) *EC2_CreateSecurityGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSnapshot(ctx context.Context, params *ec2.CreateSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 *ec2.CreateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) *ec2.CreateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnapshot'
type EC2_CreateSnapshot_Call struct {
	*mock.Call
}

// CreateSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSnapshotInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateSnapshot(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateSnapshot_Call {
	return &EC2_CreateSnapshot_Call{Call: _e.mock.On("CreateSnapshot",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateSnapshot_Call) Run(run func(ctx context.Context, params *ec2.CreateSnapshotInput, optFns ...func(*ec2.Options))) *EC2_CreateSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSnapshotInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateSnapshot_Call) Return(_a0 *ec2.CreateSnapshotOutput, _a1 error) *EC2_CreateSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateSnapshot_Call) RunAndReturn(run func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error)) *EC2_CreateSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSnapshots(ctx context.Context, params *ec2.CreateSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshots")
	}

	var r0 *ec2.CreateSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) *ec2.CreateSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateSnapshots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnapshots'
type EC2_CreateSnapshots_Call struct {
	*mock.Call
}

// CreateSnapshots is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSnapshotsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateSnapshots(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateSnapshots_Call {
	return &EC2_CreateSnapshots_Call{Call: _e.mock.On("CreateSnapshots",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateSnapshots_Call) Run(run func(ctx context.Context, params *ec2.CreateSnapshotsInput, optFns ...func(*ec2.Options))) *EC2_CreateSnapshots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSnapshotsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateSnapshots_Call) Return(_a0 *ec2.CreateSnapshotsOutput, _a1 error) *EC2_CreateSnapshots_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateSnapshots_Call) RunAndReturn(run func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error)) *EC2_CreateSnapshots_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSpotDatafeedSubscription(ctx context.Context, params *ec2.CreateSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSpotDatafeedSubscription")
	}

	var r0 *ec2.CreateSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.CreateSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateSpotDatafeedSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSpotDatafeedSubscription'
type EC2_CreateSpotDatafeedSubscription_Call struct {
	*mock.Call
}

// CreateSpotDatafeedSubscription is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSpotDatafeedSubscriptionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateSpotDatafeedSubscription(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateSpotDatafeedSubscription_Call {
	return &EC2_CreateSpotDatafeedSubscription_Call{Call: _e.mock.On("CreateSpotDatafeedSubscription",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateSpotDatafeedSubscription_Call) Run(run func(ctx context.Context, params *ec2.CreateSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options))) *EC2_CreateSpotDatafeedSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSpotDatafeedSubscriptionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateSpotDatafeedSubscription_Call) Return(_a0 *ec2.CreateSpotDatafeedSubscriptionOutput, _a1 error) *EC2_CreateSpotDatafeedSubscription_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateSpotDatafeedSubscription_Call) RunAndReturn(run func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error)) *EC2_CreateSpotDatafeedSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStoreImageTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateStoreImageTask(ctx context.Context, params *ec2.CreateStoreImageTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStoreImageTask")
	}

	var r0 *ec2.CreateStoreImageTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) *ec2.CreateStoreImageTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateStoreImageTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateStoreImageTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStoreImageTask'
type EC2_CreateStoreImageTask_Call struct {
	*mock.Call
}

// CreateStoreImageTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateStoreImageTaskInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateStoreImageTask(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateStoreImageTask_Call {
	return &EC2_CreateStoreImageTask_Call{Call: _e.mock.On("CreateStoreImageTask",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateStoreImageTask_Call) Run(run func(ctx context.Context, params *ec2.CreateStoreImageTaskInput, optFns ...func(*ec2.Options))) *EC2_CreateStoreImageTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateStoreImageTaskInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateStoreImageTask_Call) Return(_a0 *ec2.CreateStoreImageTaskOutput, _a1 error) *EC2_CreateStoreImageTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateStoreImageTask_Call) RunAndReturn(run func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error)) *EC2_CreateStoreImageTask_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSubnet(ctx context.Context, params *ec2.CreateSubnetInput, optFns ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnet")
	}

	var r0 *ec2.CreateSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) *ec2.CreateSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateSubnet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSubnet'
type EC2_CreateSubnet_Call struct {
	*mock.Call
}

// CreateSubnet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSubnetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateSubnet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateSubnet_Call {
	return &EC2_CreateSubnet_Call{Call: _e.mock.On("CreateSubnet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateSubnet_Call) Run(run func(ctx context.Context, params *ec2.CreateSubnetInput, optFns ...func(*ec2.Options))) *EC2_CreateSubnet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSubnetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateSubnet_Call) Return(_a0 *ec2.CreateSubnetOutput, _a1 error) *EC2_CreateSubnet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateSubnet_Call) RunAndReturn(run func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error)) *EC2_CreateSubnet_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSubnetCidrReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSubnetCidrReservation(ctx context.Context, params *ec2.CreateSubnetCidrReservationInput, optFns ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnetCidrReservation")
	}

	var r0 *ec2.CreateSubnetCidrReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) *ec2.CreateSubnetCidrReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetCidrReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateSubnetCidrReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSubnetCidrReservation'
type EC2_CreateSubnetCidrReservation_Call struct {
	*mock.Call
}

// CreateSubnetCidrReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSubnetCidrReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateSubnetCidrReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateSubnetCidrReservation_Call {
	return &EC2_CreateSubnetCidrReservation_Call{Call: _e.mock.On("CreateSubnetCidrReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateSubnetCidrReservation_Call) Run(run func(ctx context.Context, params *ec2.CreateSubnetCidrReservationInput, optFns ...func(*ec2.Options))) *EC2_CreateSubnetCidrReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSubnetCidrReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateSubnetCidrReservation_Call) Return(_a0 *ec2.CreateSubnetCidrReservationOutput, _a1 error) *EC2_CreateSubnetCidrReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateSubnetCidrReservation_Call) RunAndReturn(run func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error)) *EC2_CreateSubnetCidrReservation_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTags provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTags(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTags")
	}

	var r0 *ec2.CreateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) *ec2.CreateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTags'
type EC2_CreateTags_Call struct {
	*mock.Call
}

// CreateTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTagsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTags(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTags_Call {
	return &EC2_CreateTags_Call{Call: _e.mock.On("CreateTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTags_Call) Run(run func(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options))) *EC2_CreateTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTags_Call) Return(_a0 *ec2.CreateTagsOutput, _a1 error) *EC2_CreateTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTags_Call) RunAndReturn(run func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error)) *EC2_CreateTags_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTrafficMirrorFilter provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorFilter(ctx context.Context, params *ec2.CreateTrafficMirrorFilterInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorFilter")
	}

	var r0 *ec2.CreateTrafficMirrorFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTrafficMirrorFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTrafficMirrorFilter'
type EC2_CreateTrafficMirrorFilter_Call struct {
	*mock.Call
}

// CreateTrafficMirrorFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTrafficMirrorFilterInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTrafficMirrorFilter(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTrafficMirrorFilter_Call {
	return &EC2_CreateTrafficMirrorFilter_Call{Call: _e.mock.On("CreateTrafficMirrorFilter",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTrafficMirrorFilter_Call) Run(run func(ctx context.Context, params *ec2.CreateTrafficMirrorFilterInput, optFns ...func(*ec2.Options))) *EC2_CreateTrafficMirrorFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTrafficMirrorFilterInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTrafficMirrorFilter_Call) Return(_a0 *ec2.CreateTrafficMirrorFilterOutput, _a1 error) *EC2_CreateTrafficMirrorFilter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTrafficMirrorFilter_Call) RunAndReturn(run func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error)) *EC2_CreateTrafficMirrorFilter_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorFilterRule(ctx context.Context, params *ec2.CreateTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorFilterRule")
	}

	var r0 *ec2.CreateTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTrafficMirrorFilterRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTrafficMirrorFilterRule'
type EC2_CreateTrafficMirrorFilterRule_Call struct {
	*mock.Call
}

// CreateTrafficMirrorFilterRule is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTrafficMirrorFilterRuleInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTrafficMirrorFilterRule(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTrafficMirrorFilterRule_Call {
	return &EC2_CreateTrafficMirrorFilterRule_Call{Call: _e.mock.On("CreateTrafficMirrorFilterRule",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTrafficMirrorFilterRule_Call) Run(run func(ctx context.Context, params *ec2.CreateTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options))) *EC2_CreateTrafficMirrorFilterRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTrafficMirrorFilterRuleInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTrafficMirrorFilterRule_Call) Return(_a0 *ec2.CreateTrafficMirrorFilterRuleOutput, _a1 error) *EC2_CreateTrafficMirrorFilterRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTrafficMirrorFilterRule_Call) RunAndReturn(run func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error)) *EC2_CreateTrafficMirrorFilterRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorSession(ctx context.Context, params *ec2.CreateTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorSession")
	}

	var r0 *ec2.CreateTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTrafficMirrorSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTrafficMirrorSession'
type EC2_CreateTrafficMirrorSession_Call struct {
	*mock.Call
}

// CreateTrafficMirrorSession is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTrafficMirrorSessionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTrafficMirrorSession(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTrafficMirrorSession_Call {
	return &EC2_CreateTrafficMirrorSession_Call{Call: _e.mock.On("CreateTrafficMirrorSession",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTrafficMirrorSession_Call) Run(run func(ctx context.Context, params *ec2.CreateTrafficMirrorSessionInput, optFns ...func(*ec2.Options))) *EC2_CreateTrafficMirrorSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTrafficMirrorSessionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTrafficMirrorSession_Call) Return(_a0 *ec2.CreateTrafficMirrorSessionOutput, _a1 error) *EC2_CreateTrafficMirrorSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTrafficMirrorSession_Call) RunAndReturn(run func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error)) *EC2_CreateTrafficMirrorSession_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTrafficMirrorTarget provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorTarget(ctx context.Context, params *ec2.CreateTrafficMirrorTargetInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTrafficMirrorTarget")
	}

	var r0 *ec2.CreateTrafficMirrorTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTrafficMirrorTarget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTrafficMirrorTarget'
type EC2_CreateTrafficMirrorTarget_Call struct {
	*mock.Call
}

// CreateTrafficMirrorTarget is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTrafficMirrorTargetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTrafficMirrorTarget(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTrafficMirrorTarget_Call {
	return &EC2_CreateTrafficMirrorTarget_Call{Call: _e.mock.On("CreateTrafficMirrorTarget",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTrafficMirrorTarget_Call) Run(run func(ctx context.Context, params *ec2.CreateTrafficMirrorTargetInput, optFns ...func(*ec2.Options))) *EC2_CreateTrafficMirrorTarget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTrafficMirrorTargetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTrafficMirrorTarget_Call) Return(_a0 *ec2.CreateTrafficMirrorTargetOutput, _a1 error) *EC2_CreateTrafficMirrorTarget_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTrafficMirrorTarget_Call) RunAndReturn(run func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error)) *EC2_CreateTrafficMirrorTarget_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGateway(ctx context.Context, params *ec2.CreateTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGateway")
	}

	var r0 *ec2.CreateTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGateway'
type EC2_CreateTransitGateway_Call struct {
	*mock.Call
}

// CreateTransitGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGateway_Call {
	return &EC2_CreateTransitGateway_Call{Call: _e.mock.On("CreateTransitGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGateway_Call) Return(_a0 *ec2.CreateTransitGatewayOutput, _a1 error) *EC2_CreateTransitGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error)) *EC2_CreateTransitGateway_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayConnect provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayConnect(ctx context.Context, params *ec2.CreateTransitGatewayConnectInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayConnect")
	}

	var r0 *ec2.CreateTransitGatewayConnectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayConnectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayConnectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayConnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayConnect'
type EC2_CreateTransitGatewayConnect_Call struct {
	*mock.Call
}

// CreateTransitGatewayConnect is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayConnectInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayConnect(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayConnect_Call {
	return &EC2_CreateTransitGatewayConnect_Call{Call: _e.mock.On("CreateTransitGatewayConnect",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayConnect_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayConnectInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayConnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayConnectInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayConnect_Call) Return(_a0 *ec2.CreateTransitGatewayConnectOutput, _a1 error) *EC2_CreateTransitGatewayConnect_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayConnect_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error)) *EC2_CreateTransitGatewayConnect_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayConnectPeer provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayConnectPeer(ctx context.Context, params *ec2.CreateTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayConnectPeer")
	}

	var r0 *ec2.CreateTransitGatewayConnectPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayConnectPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayConnectPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayConnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayConnectPeer'
type EC2_CreateTransitGatewayConnectPeer_Call struct {
	*mock.Call
}

// CreateTransitGatewayConnectPeer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayConnectPeerInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayConnectPeer(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayConnectPeer_Call {
	return &EC2_CreateTransitGatewayConnectPeer_Call{Call: _e.mock.On("CreateTransitGatewayConnectPeer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayConnectPeer_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayConnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayConnectPeerInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayConnectPeer_Call) Return(_a0 *ec2.CreateTransitGatewayConnectPeerOutput, _a1 error) *EC2_CreateTransitGatewayConnectPeer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayConnectPeer_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error)) *EC2_CreateTransitGatewayConnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.CreateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayMulticastDomain")
	}

	var r0 *ec2.CreateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayMulticastDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayMulticastDomain'
type EC2_CreateTransitGatewayMulticastDomain_Call struct {
	*mock.Call
}

// CreateTransitGatewayMulticastDomain is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayMulticastDomainInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayMulticastDomain(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayMulticastDomain_Call {
	return &EC2_CreateTransitGatewayMulticastDomain_Call{Call: _e.mock.On("CreateTransitGatewayMulticastDomain",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayMulticastDomain_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayMulticastDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayMulticastDomainInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayMulticastDomain_Call) Return(_a0 *ec2.CreateTransitGatewayMulticastDomainOutput, _a1 error) *EC2_CreateTransitGatewayMulticastDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayMulticastDomain_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error)) *EC2_CreateTransitGatewayMulticastDomain_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.CreateTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.CreateTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayPeeringAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayPeeringAttachment'
type EC2_CreateTransitGatewayPeeringAttachment_Call struct {
	*mock.Call
}

// CreateTransitGatewayPeeringAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayPeeringAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayPeeringAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayPeeringAttachment_Call {
	return &EC2_CreateTransitGatewayPeeringAttachment_Call{Call: _e.mock.On("CreateTransitGatewayPeeringAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayPeeringAttachment_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayPeeringAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayPeeringAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayPeeringAttachment_Call) Return(_a0 *ec2.CreateTransitGatewayPeeringAttachmentOutput, _a1 error) *EC2_CreateTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayPeeringAttachment_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error)) *EC2_CreateTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayPrefixListReference(ctx context.Context, params *ec2.CreateTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayPrefixListReference")
	}

	var r0 *ec2.CreateTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayPrefixListReference_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayPrefixListReference'
type EC2_CreateTransitGatewayPrefixListReference_Call struct {
	*mock.Call
}

// CreateTransitGatewayPrefixListReference is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayPrefixListReferenceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayPrefixListReference(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayPrefixListReference_Call {
	return &EC2_CreateTransitGatewayPrefixListReference_Call{Call: _e.mock.On("CreateTransitGatewayPrefixListReference",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayPrefixListReference_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayPrefixListReference_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayPrefixListReferenceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayPrefixListReference_Call) Return(_a0 *ec2.CreateTransitGatewayPrefixListReferenceOutput, _a1 error) *EC2_CreateTransitGatewayPrefixListReference_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayPrefixListReference_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error)) *EC2_CreateTransitGatewayPrefixListReference_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayRoute(ctx context.Context, params *ec2.CreateTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayRoute")
	}

	var r0 *ec2.CreateTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayRoute'
type EC2_CreateTransitGatewayRoute_Call struct {
	*mock.Call
}

// CreateTransitGatewayRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayRoute_Call {
	return &EC2_CreateTransitGatewayRoute_Call{Call: _e.mock.On("CreateTransitGatewayRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayRoute_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayRouteInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayRoute_Call) Return(_a0 *ec2.CreateTransitGatewayRouteOutput, _a1 error) *EC2_CreateTransitGatewayRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayRoute_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error)) *EC2_CreateTransitGatewayRoute_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayRouteTable(ctx context.Context, params *ec2.CreateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayRouteTable")
	}

	var r0 *ec2.CreateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayRouteTable'
type EC2_CreateTransitGatewayRouteTable_Call struct {
	*mock.Call
}

// CreateTransitGatewayRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayRouteTable_Call {
	return &EC2_CreateTransitGatewayRouteTable_Call{Call: _e.mock.On("CreateTransitGatewayRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayRouteTable_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayRouteTable_Call) Return(_a0 *ec2.CreateTransitGatewayRouteTableOutput, _a1 error) *EC2_CreateTransitGatewayRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error)) *EC2_CreateTransitGatewayRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayVpcAttachment(ctx context.Context, params *ec2.CreateTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransitGatewayVpcAttachment")
	}

	var r0 *ec2.CreateTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateTransitGatewayVpcAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTransitGatewayVpcAttachment'
type EC2_CreateTransitGatewayVpcAttachment_Call struct {
	*mock.Call
}

// CreateTransitGatewayVpcAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTransitGatewayVpcAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateTransitGatewayVpcAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateTransitGatewayVpcAttachment_Call {
	return &EC2_CreateTransitGatewayVpcAttachment_Call{Call: _e.mock.On("CreateTransitGatewayVpcAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateTransitGatewayVpcAttachment_Call) Run(run func(ctx context.Context, params *ec2.CreateTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options))) *EC2_CreateTransitGatewayVpcAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTransitGatewayVpcAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateTransitGatewayVpcAttachment_Call) Return(_a0 *ec2.CreateTransitGatewayVpcAttachmentOutput, _a1 error) *EC2_CreateTransitGatewayVpcAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateTransitGatewayVpcAttachment_Call) RunAndReturn(run func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error)) *EC2_CreateTransitGatewayVpcAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVolume(ctx context.Context, params *ec2.CreateVolumeInput, optFns ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVolume")
	}

	var r0 *ec2.CreateVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) *ec2.CreateVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVolume'
type EC2_CreateVolume_Call struct {
	*mock.Call
}

// CreateVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVolumeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVolume(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVolume_Call {
	return &EC2_CreateVolume_Call{Call: _e.mock.On("CreateVolume",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVolume_Call) Run(run func(ctx context.Context, params *ec2.CreateVolumeInput, optFns ...func(*ec2.Options))) *EC2_CreateVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVolumeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVolume_Call) Return(_a0 *ec2.CreateVolumeOutput, _a1 error) *EC2_CreateVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVolume_Call) RunAndReturn(run func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error)) *EC2_CreateVolume_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpc(ctx context.Context, params *ec2.CreateVpcInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpc")
	}

	var r0 *ec2.CreateVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) *ec2.CreateVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpc'
type EC2_CreateVpc_Call struct {
	*mock.Call
}

// CreateVpc is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpcInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpc(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpc_Call {
	return &EC2_CreateVpc_Call{Call: _e.mock.On("CreateVpc",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpc_Call) Run(run func(ctx context.Context, params *ec2.CreateVpcInput, optFns ...func(*ec2.Options))) *EC2_CreateVpc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpcInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpc_Call) Return(_a0 *ec2.CreateVpcOutput, _a1 error) *EC2_CreateVpc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpc_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error)) *EC2_CreateVpc_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcEndpoint(ctx context.Context, params *ec2.CreateVpcEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpoint")
	}

	var r0 *ec2.CreateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpcEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpcEndpoint'
type EC2_CreateVpcEndpoint_Call struct {
	*mock.Call
}

// CreateVpcEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpcEndpointInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpcEndpoint(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpcEndpoint_Call {
	return &EC2_CreateVpcEndpoint_Call{Call: _e.mock.On("CreateVpcEndpoint",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpcEndpoint_Call) Run(run func(ctx context.Context, params *ec2.CreateVpcEndpointInput, optFns ...func(*ec2.Options))) *EC2_CreateVpcEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpcEndpointInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpcEndpoint_Call) Return(_a0 *ec2.CreateVpcEndpointOutput, _a1 error) *EC2_CreateVpcEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpcEndpoint_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error)) *EC2_CreateVpcEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpcEndpointConnectionNotification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcEndpointConnectionNotification(ctx context.Context, params *ec2.CreateVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpointConnectionNotification")
	}

	var r0 *ec2.CreateVpcEndpointConnectionNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointConnectionNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpcEndpointConnectionNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpcEndpointConnectionNotification'
type EC2_CreateVpcEndpointConnectionNotification_Call struct {
	*mock.Call
}

// CreateVpcEndpointConnectionNotification is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpcEndpointConnectionNotificationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpcEndpointConnectionNotification(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpcEndpointConnectionNotification_Call {
	return &EC2_CreateVpcEndpointConnectionNotification_Call{Call: _e.mock.On("CreateVpcEndpointConnectionNotification",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpcEndpointConnectionNotification_Call) Run(run func(ctx context.Context, params *ec2.CreateVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options))) *EC2_CreateVpcEndpointConnectionNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpcEndpointConnectionNotificationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpcEndpointConnectionNotification_Call) Return(_a0 *ec2.CreateVpcEndpointConnectionNotificationOutput, _a1 error) *EC2_CreateVpcEndpointConnectionNotification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpcEndpointConnectionNotification_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error)) *EC2_CreateVpcEndpointConnectionNotification_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpcEndpointServiceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcEndpointServiceConfiguration(ctx context.Context, params *ec2.CreateVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcEndpointServiceConfiguration")
	}

	var r0 *ec2.CreateVpcEndpointServiceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointServiceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpcEndpointServiceConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpcEndpointServiceConfiguration'
type EC2_CreateVpcEndpointServiceConfiguration_Call struct {
	*mock.Call
}

// CreateVpcEndpointServiceConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpcEndpointServiceConfigurationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpcEndpointServiceConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpcEndpointServiceConfiguration_Call {
	return &EC2_CreateVpcEndpointServiceConfiguration_Call{Call: _e.mock.On("CreateVpcEndpointServiceConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpcEndpointServiceConfiguration_Call) Run(run func(ctx context.Context, params *ec2.CreateVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options))) *EC2_CreateVpcEndpointServiceConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpcEndpointServiceConfigurationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpcEndpointServiceConfiguration_Call) Return(_a0 *ec2.CreateVpcEndpointServiceConfigurationOutput, _a1 error) *EC2_CreateVpcEndpointServiceConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpcEndpointServiceConfiguration_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error)) *EC2_CreateVpcEndpointServiceConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcPeeringConnection(ctx context.Context, params *ec2.CreateVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpcPeeringConnection")
	}

	var r0 *ec2.CreateVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.CreateVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpcPeeringConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpcPeeringConnection'
type EC2_CreateVpcPeeringConnection_Call struct {
	*mock.Call
}

// CreateVpcPeeringConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpcPeeringConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpcPeeringConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpcPeeringConnection_Call {
	return &EC2_CreateVpcPeeringConnection_Call{Call: _e.mock.On("CreateVpcPeeringConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpcPeeringConnection_Call) Run(run func(ctx context.Context, params *ec2.CreateVpcPeeringConnectionInput, optFns ...func(*ec2.Options))) *EC2_CreateVpcPeeringConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpcPeeringConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpcPeeringConnection_Call) Return(_a0 *ec2.CreateVpcPeeringConnectionOutput, _a1 error) *EC2_CreateVpcPeeringConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpcPeeringConnection_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error)) *EC2_CreateVpcPeeringConnection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpnConnection(ctx context.Context, params *ec2.CreateVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnConnection")
	}

	var r0 *ec2.CreateVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) *ec2.CreateVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpnConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpnConnection'
type EC2_CreateVpnConnection_Call struct {
	*mock.Call
}

// CreateVpnConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpnConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpnConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpnConnection_Call {
	return &EC2_CreateVpnConnection_Call{Call: _e.mock.On("CreateVpnConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpnConnection_Call) Run(run func(ctx context.Context, params *ec2.CreateVpnConnectionInput, optFns ...func(*ec2.Options))) *EC2_CreateVpnConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpnConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpnConnection_Call) Return(_a0 *ec2.CreateVpnConnectionOutput, _a1 error) *EC2_CreateVpnConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpnConnection_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error)) *EC2_CreateVpnConnection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpnConnectionRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpnConnectionRoute(ctx context.Context, params *ec2.CreateVpnConnectionRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnConnectionRoute")
	}

	var r0 *ec2.CreateVpnConnectionRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) *ec2.CreateVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpnConnectionRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpnConnectionRoute'
type EC2_CreateVpnConnectionRoute_Call struct {
	*mock.Call
}

// CreateVpnConnectionRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpnConnectionRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpnConnectionRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpnConnectionRoute_Call {
	return &EC2_CreateVpnConnectionRoute_Call{Call: _e.mock.On("CreateVpnConnectionRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpnConnectionRoute_Call) Run(run func(ctx context.Context, params *ec2.CreateVpnConnectionRouteInput, optFns ...func(*ec2.Options))) *EC2_CreateVpnConnectionRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpnConnectionRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpnConnectionRoute_Call) Return(_a0 *ec2.CreateVpnConnectionRouteOutput, _a1 error) *EC2_CreateVpnConnectionRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpnConnectionRoute_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error)) *EC2_CreateVpnConnectionRoute_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpnGateway(ctx context.Context, params *ec2.CreateVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateVpnGateway")
	}

	var r0 *ec2.CreateVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) *ec2.CreateVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_CreateVpnGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVpnGateway'
type EC2_CreateVpnGateway_Call struct {
	*mock.Call
}

// CreateVpnGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateVpnGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) CreateVpnGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_CreateVpnGateway_Call {
	return &EC2_CreateVpnGateway_Call{Call: _e.mock.On("CreateVpnGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_CreateVpnGateway_Call) Run(run func(ctx context.Context, params *ec2.CreateVpnGatewayInput, optFns ...func(*ec2.Options))) *EC2_CreateVpnGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateVpnGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_CreateVpnGateway_Call) Return(_a0 *ec2.CreateVpnGatewayOutput, _a1 error) *EC2_CreateVpnGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_CreateVpnGateway_Call) RunAndReturn(run func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error)) *EC2_CreateVpnGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCarrierGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteCarrierGateway(ctx context.Context, params *ec2.DeleteCarrierGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCarrierGateway")
	}

	var r0 *ec2.DeleteCarrierGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) *ec2.DeleteCarrierGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCarrierGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteCarrierGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCarrierGateway'
type EC2_DeleteCarrierGateway_Call struct {
	*mock.Call
}

// DeleteCarrierGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteCarrierGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteCarrierGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteCarrierGateway_Call {
	return &EC2_DeleteCarrierGateway_Call{Call: _e.mock.On("DeleteCarrierGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteCarrierGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteCarrierGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteCarrierGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteCarrierGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteCarrierGateway_Call) Return(_a0 *ec2.DeleteCarrierGatewayOutput, _a1 error) *EC2_DeleteCarrierGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteCarrierGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error)) *EC2_DeleteCarrierGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteClientVpnEndpoint(ctx context.Context, params *ec2.DeleteClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClientVpnEndpoint")
	}

	var r0 *ec2.DeleteClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.DeleteClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteClientVpnEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteClientVpnEndpoint'
type EC2_DeleteClientVpnEndpoint_Call struct {
	*mock.Call
}

// DeleteClientVpnEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteClientVpnEndpointInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteClientVpnEndpoint(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteClientVpnEndpoint_Call {
	return &EC2_DeleteClientVpnEndpoint_Call{Call: _e.mock.On("DeleteClientVpnEndpoint",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteClientVpnEndpoint_Call) Run(run func(ctx context.Context, params *ec2.DeleteClientVpnEndpointInput, optFns ...func(*ec2.Options))) *EC2_DeleteClientVpnEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteClientVpnEndpointInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteClientVpnEndpoint_Call) Return(_a0 *ec2.DeleteClientVpnEndpointOutput, _a1 error) *EC2_DeleteClientVpnEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteClientVpnEndpoint_Call) RunAndReturn(run func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error)) *EC2_DeleteClientVpnEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteClientVpnRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteClientVpnRoute(ctx context.Context, params *ec2.DeleteClientVpnRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClientVpnRoute")
	}

	var r0 *ec2.DeleteClientVpnRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) *ec2.DeleteClientVpnRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteClientVpnRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteClientVpnRoute'
type EC2_DeleteClientVpnRoute_Call struct {
	*mock.Call
}

// DeleteClientVpnRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteClientVpnRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteClientVpnRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteClientVpnRoute_Call {
	return &EC2_DeleteClientVpnRoute_Call{Call: _e.mock.On("DeleteClientVpnRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteClientVpnRoute_Call) Run(run func(ctx context.Context, params *ec2.DeleteClientVpnRouteInput, optFns ...func(*ec2.Options))) *EC2_DeleteClientVpnRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteClientVpnRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteClientVpnRoute_Call) Return(_a0 *ec2.DeleteClientVpnRouteOutput, _a1 error) *EC2_DeleteClientVpnRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteClientVpnRoute_Call) RunAndReturn(run func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error)) *EC2_DeleteClientVpnRoute_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCustomerGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteCustomerGateway(ctx context.Context, params *ec2.DeleteCustomerGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomerGateway")
	}

	var r0 *ec2.DeleteCustomerGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) *ec2.DeleteCustomerGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCustomerGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteCustomerGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCustomerGateway'
type EC2_DeleteCustomerGateway_Call struct {
	*mock.Call
}

// DeleteCustomerGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteCustomerGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteCustomerGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteCustomerGateway_Call {
	return &EC2_DeleteCustomerGateway_Call{Call: _e.mock.On("DeleteCustomerGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteCustomerGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteCustomerGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteCustomerGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteCustomerGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteCustomerGateway_Call) Return(_a0 *ec2.DeleteCustomerGatewayOutput, _a1 error) *EC2_DeleteCustomerGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteCustomerGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error)) *EC2_DeleteCustomerGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteDhcpOptions(ctx context.Context, params *ec2.DeleteDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDhcpOptions")
	}

	var r0 *ec2.DeleteDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) *ec2.DeleteDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteDhcpOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDhcpOptions'
type EC2_DeleteDhcpOptions_Call struct {
	*mock.Call
}

// DeleteDhcpOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteDhcpOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteDhcpOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteDhcpOptions_Call {
	return &EC2_DeleteDhcpOptions_Call{Call: _e.mock.On("DeleteDhcpOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteDhcpOptions_Call) Run(run func(ctx context.Context, params *ec2.DeleteDhcpOptionsInput, optFns ...func(*ec2.Options))) *EC2_DeleteDhcpOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteDhcpOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteDhcpOptions_Call) Return(_a0 *ec2.DeleteDhcpOptionsOutput, _a1 error) *EC2_DeleteDhcpOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteDhcpOptions_Call) RunAndReturn(run func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error)) *EC2_DeleteDhcpOptions_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEgressOnlyInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteEgressOnlyInternetGateway(ctx context.Context, params *ec2.DeleteEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEgressOnlyInternetGateway")
	}

	var r0 *ec2.DeleteEgressOnlyInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) *ec2.DeleteEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteEgressOnlyInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteEgressOnlyInternetGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEgressOnlyInternetGateway'
type EC2_DeleteEgressOnlyInternetGateway_Call struct {
	*mock.Call
}

// DeleteEgressOnlyInternetGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteEgressOnlyInternetGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteEgressOnlyInternetGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteEgressOnlyInternetGateway_Call {
	return &EC2_DeleteEgressOnlyInternetGateway_Call{Call: _e.mock.On("DeleteEgressOnlyInternetGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteEgressOnlyInternetGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteEgressOnlyInternetGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteEgressOnlyInternetGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteEgressOnlyInternetGateway_Call) Return(_a0 *ec2.DeleteEgressOnlyInternetGatewayOutput, _a1 error) *EC2_DeleteEgressOnlyInternetGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteEgressOnlyInternetGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error)) *EC2_DeleteEgressOnlyInternetGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteFleets(ctx context.Context, params *ec2.DeleteFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFleets")
	}

	var r0 *ec2.DeleteFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) *ec2.DeleteFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteFleets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFleets'
type EC2_DeleteFleets_Call struct {
	*mock.Call
}

// DeleteFleets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteFleetsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteFleets(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteFleets_Call {
	return &EC2_DeleteFleets_Call{Call: _e.mock.On("DeleteFleets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteFleets_Call) Run(run func(ctx context.Context, params *ec2.DeleteFleetsInput, optFns ...func(*ec2.Options))) *EC2_DeleteFleets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteFleetsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteFleets_Call) Return(_a0 *ec2.DeleteFleetsOutput, _a1 error) *EC2_DeleteFleets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteFleets_Call) RunAndReturn(run func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error)) *EC2_DeleteFleets_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteFlowLogs(ctx context.Context, params *ec2.DeleteFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFlowLogs")
	}

	var r0 *ec2.DeleteFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) *ec2.DeleteFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteFlowLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFlowLogs'
type EC2_DeleteFlowLogs_Call struct {
	*mock.Call
}

// DeleteFlowLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteFlowLogsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteFlowLogs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteFlowLogs_Call {
	return &EC2_DeleteFlowLogs_Call{Call: _e.mock.On("DeleteFlowLogs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteFlowLogs_Call) Run(run func(ctx context.Context, params *ec2.DeleteFlowLogsInput, optFns ...func(*ec2.Options))) *EC2_DeleteFlowLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteFlowLogsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteFlowLogs_Call) Return(_a0 *ec2.DeleteFlowLogsOutput, _a1 error) *EC2_DeleteFlowLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteFlowLogs_Call) RunAndReturn(run func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error)) *EC2_DeleteFlowLogs_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteFpgaImage(ctx context.Context, params *ec2.DeleteFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFpgaImage")
	}

	var r0 *ec2.DeleteFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) *ec2.DeleteFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteFpgaImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFpgaImage'
type EC2_DeleteFpgaImage_Call struct {
	*mock.Call
}

// DeleteFpgaImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteFpgaImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteFpgaImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteFpgaImage_Call {
	return &EC2_DeleteFpgaImage_Call{Call: _e.mock.On("DeleteFpgaImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteFpgaImage_Call) Run(run func(ctx context.Context, params *ec2.DeleteFpgaImageInput, optFns ...func(*ec2.Options))) *EC2_DeleteFpgaImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteFpgaImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteFpgaImage_Call) Return(_a0 *ec2.DeleteFpgaImageOutput, _a1 error) *EC2_DeleteFpgaImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteFpgaImage_Call) RunAndReturn(run func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error)) *EC2_DeleteFpgaImage_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteInstanceEventWindow(ctx context.Context, params *ec2.DeleteInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInstanceEventWindow")
	}

	var r0 *ec2.DeleteInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.DeleteInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteInstanceEventWindow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInstanceEventWindow'
type EC2_DeleteInstanceEventWindow_Call struct {
	*mock.Call
}

// DeleteInstanceEventWindow is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteInstanceEventWindowInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteInstanceEventWindow(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteInstanceEventWindow_Call {
	return &EC2_DeleteInstanceEventWindow_Call{Call: _e.mock.On("DeleteInstanceEventWindow",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteInstanceEventWindow_Call) Run(run func(ctx context.Context, params *ec2.DeleteInstanceEventWindowInput, optFns ...func(*ec2.Options))) *EC2_DeleteInstanceEventWindow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteInstanceEventWindowInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteInstanceEventWindow_Call) Return(_a0 *ec2.DeleteInstanceEventWindowOutput, _a1 error) *EC2_DeleteInstanceEventWindow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteInstanceEventWindow_Call) RunAndReturn(run func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error)) *EC2_DeleteInstanceEventWindow_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteInternetGateway(ctx context.Context, params *ec2.DeleteInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteInternetGateway")
	}

	var r0 *ec2.DeleteInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) *ec2.DeleteInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteInternetGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteInternetGateway'
type EC2_DeleteInternetGateway_Call struct {
	*mock.Call
}

// DeleteInternetGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteInternetGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteInternetGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteInternetGateway_Call {
	return &EC2_DeleteInternetGateway_Call{Call: _e.mock.On("DeleteInternetGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteInternetGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteInternetGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteInternetGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteInternetGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteInternetGateway_Call) Return(_a0 *ec2.DeleteInternetGatewayOutput, _a1 error) *EC2_DeleteInternetGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteInternetGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error)) *EC2_DeleteInternetGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteIpam(ctx context.Context, params *ec2.DeleteIpamInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpam")
	}

	var r0 *ec2.DeleteIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) *ec2.DeleteIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteIpam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIpam'
type EC2_DeleteIpam_Call struct {
	*mock.Call
}

// DeleteIpam is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteIpamInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteIpam(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteIpam_Call {
	return &EC2_DeleteIpam_Call{Call: _e.mock.On("DeleteIpam",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteIpam_Call) Run(run func(ctx context.Context, params *ec2.DeleteIpamInput, optFns ...func(*ec2.Options))) *EC2_DeleteIpam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteIpamInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteIpam_Call) Return(_a0 *ec2.DeleteIpamOutput, _a1 error) *EC2_DeleteIpam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteIpam_Call) RunAndReturn(run func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error)) *EC2_DeleteIpam_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteIpamPool(ctx context.Context, params *ec2.DeleteIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamPool")
	}

	var r0 *ec2.DeleteIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) *ec2.DeleteIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteIpamPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIpamPool'
type EC2_DeleteIpamPool_Call struct {
	*mock.Call
}

// DeleteIpamPool is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteIpamPoolInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteIpamPool(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteIpamPool_Call {
	return &EC2_DeleteIpamPool_Call{Call: _e.mock.On("DeleteIpamPool",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteIpamPool_Call) Run(run func(ctx context.Context, params *ec2.DeleteIpamPoolInput, optFns ...func(*ec2.Options))) *EC2_DeleteIpamPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteIpamPoolInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteIpamPool_Call) Return(_a0 *ec2.DeleteIpamPoolOutput, _a1 error) *EC2_DeleteIpamPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteIpamPool_Call) RunAndReturn(run func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error)) *EC2_DeleteIpamPool_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteIpamScope(ctx context.Context, params *ec2.DeleteIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIpamScope")
	}

	var r0 *ec2.DeleteIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) *ec2.DeleteIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteIpamScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIpamScope'
type EC2_DeleteIpamScope_Call struct {
	*mock.Call
}

// DeleteIpamScope is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteIpamScopeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteIpamScope(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteIpamScope_Call {
	return &EC2_DeleteIpamScope_Call{Call: _e.mock.On("DeleteIpamScope",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteIpamScope_Call) Run(run func(ctx context.Context, params *ec2.DeleteIpamScopeInput, optFns ...func(*ec2.Options))) *EC2_DeleteIpamScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteIpamScopeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteIpamScope_Call) Return(_a0 *ec2.DeleteIpamScopeOutput, _a1 error) *EC2_DeleteIpamScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteIpamScope_Call) RunAndReturn(run func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error)) *EC2_DeleteIpamScope_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteKeyPair(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKeyPair")
	}

	var r0 *ec2.DeleteKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) *ec2.DeleteKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteKeyPair_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKeyPair'
type EC2_DeleteKeyPair_Call struct {
	*mock.Call
}

// DeleteKeyPair is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteKeyPairInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteKeyPair(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteKeyPair_Call {
	return &EC2_DeleteKeyPair_Call{Call: _e.mock.On("DeleteKeyPair",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteKeyPair_Call) Run(run func(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options))) *EC2_DeleteKeyPair_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteKeyPairInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteKeyPair_Call) Return(_a0 *ec2.DeleteKeyPairOutput, _a1 error) *EC2_DeleteKeyPair_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteKeyPair_Call) RunAndReturn(run func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error)) *EC2_DeleteKeyPair_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLaunchTemplate(ctx context.Context, params *ec2.DeleteLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLaunchTemplate")
	}

	var r0 *ec2.DeleteLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) *ec2.DeleteLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteLaunchTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLaunchTemplate'
type EC2_DeleteLaunchTemplate_Call struct {
	*mock.Call
}

// DeleteLaunchTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteLaunchTemplateInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteLaunchTemplate(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteLaunchTemplate_Call {
	return &EC2_DeleteLaunchTemplate_Call{Call: _e.mock.On("DeleteLaunchTemplate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteLaunchTemplate_Call) Run(run func(ctx context.Context, params *ec2.DeleteLaunchTemplateInput, optFns ...func(*ec2.Options))) *EC2_DeleteLaunchTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteLaunchTemplateInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteLaunchTemplate_Call) Return(_a0 *ec2.DeleteLaunchTemplateOutput, _a1 error) *EC2_DeleteLaunchTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteLaunchTemplate_Call) RunAndReturn(run func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error)) *EC2_DeleteLaunchTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLaunchTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLaunchTemplateVersions(ctx context.Context, params *ec2.DeleteLaunchTemplateVersionsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLaunchTemplateVersions")
	}

	var r0 *ec2.DeleteLaunchTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) *ec2.DeleteLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteLaunchTemplateVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLaunchTemplateVersions'
type EC2_DeleteLaunchTemplateVersions_Call struct {
	*mock.Call
}

// DeleteLaunchTemplateVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteLaunchTemplateVersionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteLaunchTemplateVersions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteLaunchTemplateVersions_Call {
	return &EC2_DeleteLaunchTemplateVersions_Call{Call: _e.mock.On("DeleteLaunchTemplateVersions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteLaunchTemplateVersions_Call) Run(run func(ctx context.Context, params *ec2.DeleteLaunchTemplateVersionsInput, optFns ...func(*ec2.Options))) *EC2_DeleteLaunchTemplateVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteLaunchTemplateVersionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteLaunchTemplateVersions_Call) Return(_a0 *ec2.DeleteLaunchTemplateVersionsOutput, _a1 error) *EC2_DeleteLaunchTemplateVersions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteLaunchTemplateVersions_Call) RunAndReturn(run func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error)) *EC2_DeleteLaunchTemplateVersions_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLocalGatewayRoute(ctx context.Context, params *ec2.DeleteLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayRoute")
	}

	var r0 *ec2.DeleteLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteLocalGatewayRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLocalGatewayRoute'
type EC2_DeleteLocalGatewayRoute_Call struct {
	*mock.Call
}

// DeleteLocalGatewayRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteLocalGatewayRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteLocalGatewayRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteLocalGatewayRoute_Call {
	return &EC2_DeleteLocalGatewayRoute_Call{Call: _e.mock.On("DeleteLocalGatewayRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteLocalGatewayRoute_Call) Run(run func(ctx context.Context, params *ec2.DeleteLocalGatewayRouteInput, optFns ...func(*ec2.Options))) *EC2_DeleteLocalGatewayRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteLocalGatewayRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteLocalGatewayRoute_Call) Return(_a0 *ec2.DeleteLocalGatewayRouteOutput, _a1 error) *EC2_DeleteLocalGatewayRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteLocalGatewayRoute_Call) RunAndReturn(run func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error)) *EC2_DeleteLocalGatewayRoute_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLocalGatewayRouteTableVpcAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLocalGatewayRouteTableVpcAssociation(ctx context.Context, params *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLocalGatewayRouteTableVpcAssociation")
	}

	var r0 *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLocalGatewayRouteTableVpcAssociation'
type EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call struct {
	*mock.Call
}

// DeleteLocalGatewayRouteTableVpcAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteLocalGatewayRouteTableVpcAssociation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call {
	return &EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call{Call: _e.mock.On("DeleteLocalGatewayRouteTableVpcAssociation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call) Run(run func(ctx context.Context, params *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options))) *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteLocalGatewayRouteTableVpcAssociationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call) Return(_a0 *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, _a1 error) *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call) RunAndReturn(run func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error)) *EC2_DeleteLocalGatewayRouteTableVpcAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteManagedPrefixList(ctx context.Context, params *ec2.DeleteManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteManagedPrefixList")
	}

	var r0 *ec2.DeleteManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) *ec2.DeleteManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteManagedPrefixList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteManagedPrefixList'
type EC2_DeleteManagedPrefixList_Call struct {
	*mock.Call
}

// DeleteManagedPrefixList is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteManagedPrefixListInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteManagedPrefixList(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteManagedPrefixList_Call {
	return &EC2_DeleteManagedPrefixList_Call{Call: _e.mock.On("DeleteManagedPrefixList",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteManagedPrefixList_Call) Run(run func(ctx context.Context, params *ec2.DeleteManagedPrefixListInput, optFns ...func(*ec2.Options))) *EC2_DeleteManagedPrefixList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteManagedPrefixListInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteManagedPrefixList_Call) Return(_a0 *ec2.DeleteManagedPrefixListOutput, _a1 error) *EC2_DeleteManagedPrefixList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteManagedPrefixList_Call) RunAndReturn(run func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error)) *EC2_DeleteManagedPrefixList_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNatGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNatGateway(ctx context.Context, params *ec2.DeleteNatGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNatGateway")
	}

	var r0 *ec2.DeleteNatGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) *ec2.DeleteNatGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNatGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNatGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNatGateway'
type EC2_DeleteNatGateway_Call struct {
	*mock.Call
}

// DeleteNatGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNatGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNatGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNatGateway_Call {
	return &EC2_DeleteNatGateway_Call{Call: _e.mock.On("DeleteNatGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNatGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteNatGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteNatGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNatGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNatGateway_Call) Return(_a0 *ec2.DeleteNatGatewayOutput, _a1 error) *EC2_DeleteNatGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNatGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error)) *EC2_DeleteNatGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkAcl provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkAcl(ctx context.Context, params *ec2.DeleteNetworkAclInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkAcl")
	}

	var r0 *ec2.DeleteNetworkAclOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) *ec2.DeleteNetworkAclOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkAcl'
type EC2_DeleteNetworkAcl_Call struct {
	*mock.Call
}

// DeleteNetworkAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkAclInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkAcl(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkAcl_Call {
	return &EC2_DeleteNetworkAcl_Call{Call: _e.mock.On("DeleteNetworkAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkAcl_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkAclInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkAclInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkAcl_Call) Return(_a0 *ec2.DeleteNetworkAclOutput, _a1 error) *EC2_DeleteNetworkAcl_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkAcl_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error)) *EC2_DeleteNetworkAcl_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkAclEntry(ctx context.Context, params *ec2.DeleteNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkAclEntry")
	}

	var r0 *ec2.DeleteNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.DeleteNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkAclEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkAclEntry'
type EC2_DeleteNetworkAclEntry_Call struct {
	*mock.Call
}

// DeleteNetworkAclEntry is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkAclEntryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkAclEntry(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkAclEntry_Call {
	return &EC2_DeleteNetworkAclEntry_Call{Call: _e.mock.On("DeleteNetworkAclEntry",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkAclEntry_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkAclEntryInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkAclEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkAclEntryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkAclEntry_Call) Return(_a0 *ec2.DeleteNetworkAclEntryOutput, _a1 error) *EC2_DeleteNetworkAclEntry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkAclEntry_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error)) *EC2_DeleteNetworkAclEntry_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkInsightsAccessScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsAccessScope(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsAccessScope")
	}

	var r0 *ec2.DeleteNetworkInsightsAccessScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAccessScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAccessScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkInsightsAccessScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkInsightsAccessScope'
type EC2_DeleteNetworkInsightsAccessScope_Call struct {
	*mock.Call
}

// DeleteNetworkInsightsAccessScope is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkInsightsAccessScopeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkInsightsAccessScope(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkInsightsAccessScope_Call {
	return &EC2_DeleteNetworkInsightsAccessScope_Call{Call: _e.mock.On("DeleteNetworkInsightsAccessScope",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkInsightsAccessScope_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkInsightsAccessScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkInsightsAccessScopeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkInsightsAccessScope_Call) Return(_a0 *ec2.DeleteNetworkInsightsAccessScopeOutput, _a1 error) *EC2_DeleteNetworkInsightsAccessScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkInsightsAccessScope_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error)) *EC2_DeleteNetworkInsightsAccessScope_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkInsightsAccessScopeAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsAccessScopeAnalysis(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsAccessScopeAnalysis")
	}

	var r0 *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkInsightsAccessScopeAnalysis'
type EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call struct {
	*mock.Call
}

// DeleteNetworkInsightsAccessScopeAnalysis is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkInsightsAccessScopeAnalysis(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call {
	return &EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call{Call: _e.mock.On("DeleteNetworkInsightsAccessScopeAnalysis",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkInsightsAccessScopeAnalysisInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call) Return(_a0 *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, _a1 error) *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error)) *EC2_DeleteNetworkInsightsAccessScopeAnalysis_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkInsightsAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsAnalysis(ctx context.Context, params *ec2.DeleteNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsAnalysis")
	}

	var r0 *ec2.DeleteNetworkInsightsAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkInsightsAnalysis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkInsightsAnalysis'
type EC2_DeleteNetworkInsightsAnalysis_Call struct {
	*mock.Call
}

// DeleteNetworkInsightsAnalysis is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkInsightsAnalysisInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkInsightsAnalysis(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkInsightsAnalysis_Call {
	return &EC2_DeleteNetworkInsightsAnalysis_Call{Call: _e.mock.On("DeleteNetworkInsightsAnalysis",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkInsightsAnalysis_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkInsightsAnalysis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkInsightsAnalysisInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkInsightsAnalysis_Call) Return(_a0 *ec2.DeleteNetworkInsightsAnalysisOutput, _a1 error) *EC2_DeleteNetworkInsightsAnalysis_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkInsightsAnalysis_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error)) *EC2_DeleteNetworkInsightsAnalysis_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkInsightsPath provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsPath(ctx context.Context, params *ec2.DeleteNetworkInsightsPathInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInsightsPath")
	}

	var r0 *ec2.DeleteNetworkInsightsPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkInsightsPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkInsightsPath'
type EC2_DeleteNetworkInsightsPath_Call struct {
	*mock.Call
}

// DeleteNetworkInsightsPath is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkInsightsPathInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkInsightsPath(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkInsightsPath_Call {
	return &EC2_DeleteNetworkInsightsPath_Call{Call: _e.mock.On("DeleteNetworkInsightsPath",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkInsightsPath_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkInsightsPathInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkInsightsPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkInsightsPathInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkInsightsPath_Call) Return(_a0 *ec2.DeleteNetworkInsightsPathOutput, _a1 error) *EC2_DeleteNetworkInsightsPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkInsightsPath_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error)) *EC2_DeleteNetworkInsightsPath_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInterface(ctx context.Context, params *ec2.DeleteNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInterface")
	}

	var r0 *ec2.DeleteNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkInterface'
type EC2_DeleteNetworkInterface_Call struct {
	*mock.Call
}

// DeleteNetworkInterface is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkInterfaceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkInterface(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkInterface_Call {
	return &EC2_DeleteNetworkInterface_Call{Call: _e.mock.On("DeleteNetworkInterface",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkInterface_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkInterfaceInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkInterfaceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkInterface_Call) Return(_a0 *ec2.DeleteNetworkInterfaceOutput, _a1 error) *EC2_DeleteNetworkInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkInterface_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error)) *EC2_DeleteNetworkInterface_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNetworkInterfacePermission provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInterfacePermission(ctx context.Context, params *ec2.DeleteNetworkInterfacePermissionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetworkInterfacePermission")
	}

	var r0 *ec2.DeleteNetworkInterfacePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfacePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteNetworkInterfacePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNetworkInterfacePermission'
type EC2_DeleteNetworkInterfacePermission_Call struct {
	*mock.Call
}

// DeleteNetworkInterfacePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteNetworkInterfacePermissionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteNetworkInterfacePermission(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteNetworkInterfacePermission_Call {
	return &EC2_DeleteNetworkInterfacePermission_Call{Call: _e.mock.On("DeleteNetworkInterfacePermission",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteNetworkInterfacePermission_Call) Run(run func(ctx context.Context, params *ec2.DeleteNetworkInterfacePermissionInput, optFns ...func(*ec2.Options))) *EC2_DeleteNetworkInterfacePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteNetworkInterfacePermissionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteNetworkInterfacePermission_Call) Return(_a0 *ec2.DeleteNetworkInterfacePermissionOutput, _a1 error) *EC2_DeleteNetworkInterfacePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteNetworkInterfacePermission_Call) RunAndReturn(run func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error)) *EC2_DeleteNetworkInterfacePermission_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePlacementGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeletePlacementGroup(ctx context.Context, params *ec2.DeletePlacementGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePlacementGroup")
	}

	var r0 *ec2.DeletePlacementGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) *ec2.DeletePlacementGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePlacementGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeletePlacementGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePlacementGroup'
type EC2_DeletePlacementGroup_Call struct {
	*mock.Call
}

// DeletePlacementGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeletePlacementGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeletePlacementGroup(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeletePlacementGroup_Call {
	return &EC2_DeletePlacementGroup_Call{Call: _e.mock.On("DeletePlacementGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeletePlacementGroup_Call) Run(run func(ctx context.Context, params *ec2.DeletePlacementGroupInput, optFns ...func(*ec2.Options))) *EC2_DeletePlacementGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeletePlacementGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeletePlacementGroup_Call) Return(_a0 *ec2.DeletePlacementGroupOutput, _a1 error) *EC2_DeletePlacementGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeletePlacementGroup_Call) RunAndReturn(run func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error)) *EC2_DeletePlacementGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePublicIpv4Pool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeletePublicIpv4Pool(ctx context.Context, params *ec2.DeletePublicIpv4PoolInput, optFns ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePublicIpv4Pool")
	}

	var r0 *ec2.DeletePublicIpv4PoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) *ec2.DeletePublicIpv4PoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePublicIpv4PoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeletePublicIpv4Pool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePublicIpv4Pool'
type EC2_DeletePublicIpv4Pool_Call struct {
	*mock.Call
}

// DeletePublicIpv4Pool is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeletePublicIpv4PoolInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeletePublicIpv4Pool(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeletePublicIpv4Pool_Call {
	return &EC2_DeletePublicIpv4Pool_Call{Call: _e.mock.On("DeletePublicIpv4Pool",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeletePublicIpv4Pool_Call) Run(run func(ctx context.Context, params *ec2.DeletePublicIpv4PoolInput, optFns ...func(*ec2.Options))) *EC2_DeletePublicIpv4Pool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeletePublicIpv4PoolInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeletePublicIpv4Pool_Call) Return(_a0 *ec2.DeletePublicIpv4PoolOutput, _a1 error) *EC2_DeletePublicIpv4Pool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeletePublicIpv4Pool_Call) RunAndReturn(run func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error)) *EC2_DeletePublicIpv4Pool_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteQueuedReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteQueuedReservedInstances(ctx context.Context, params *ec2.DeleteQueuedReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteQueuedReservedInstances")
	}

	var r0 *ec2.DeleteQueuedReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) *ec2.DeleteQueuedReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteQueuedReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteQueuedReservedInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteQueuedReservedInstances'
type EC2_DeleteQueuedReservedInstances_Call struct {
	*mock.Call
}

// DeleteQueuedReservedInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteQueuedReservedInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteQueuedReservedInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteQueuedReservedInstances_Call {
	return &EC2_DeleteQueuedReservedInstances_Call{Call: _e.mock.On("DeleteQueuedReservedInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteQueuedReservedInstances_Call) Run(run func(ctx context.Context, params *ec2.DeleteQueuedReservedInstancesInput, optFns ...func(*ec2.Options))) *EC2_DeleteQueuedReservedInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteQueuedReservedInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteQueuedReservedInstances_Call) Return(_a0 *ec2.DeleteQueuedReservedInstancesOutput, _a1 error) *EC2_DeleteQueuedReservedInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteQueuedReservedInstances_Call) RunAndReturn(run func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error)) *EC2_DeleteQueuedReservedInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteRoute(ctx context.Context, params *ec2.DeleteRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRoute")
	}

	var r0 *ec2.DeleteRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) *ec2.DeleteRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRoute'
type EC2_DeleteRoute_Call struct {
	*mock.Call
}

// DeleteRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteRoute_Call {
	return &EC2_DeleteRoute_Call{Call: _e.mock.On("DeleteRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteRoute_Call) Run(run func(ctx context.Context, params *ec2.DeleteRouteInput, optFns ...func(*ec2.Options))) *EC2_DeleteRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteRoute_Call) Return(_a0 *ec2.DeleteRouteOutput, _a1 error) *EC2_DeleteRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteRoute_Call) RunAndReturn(run func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error)) *EC2_DeleteRoute_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteRouteTable(ctx context.Context, params *ec2.DeleteRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRouteTable")
	}

	var r0 *ec2.DeleteRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRouteTable'
type EC2_DeleteRouteTable_Call struct {
	*mock.Call
}

// DeleteRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteRouteTable_Call {
	return &EC2_DeleteRouteTable_Call{Call: _e.mock.On("DeleteRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteRouteTable_Call) Run(run func(ctx context.Context, params *ec2.DeleteRouteTableInput, optFns ...func(*ec2.Options))) *EC2_DeleteRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteRouteTable_Call) Return(_a0 *ec2.DeleteRouteTableOutput, _a1 error) *EC2_DeleteRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error)) *EC2_DeleteRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSecurityGroup(ctx context.Context, params *ec2.DeleteSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecurityGroup")
	}

	var r0 *ec2.DeleteSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) *ec2.DeleteSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteSecurityGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSecurityGroup'
type EC2_DeleteSecurityGroup_Call struct {
	*mock.Call
}

// DeleteSecurityGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteSecurityGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteSecurityGroup(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteSecurityGroup_Call {
	return &EC2_DeleteSecurityGroup_Call{Call: _e.mock.On("DeleteSecurityGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteSecurityGroup_Call) Run(run func(ctx context.Context, params *ec2.DeleteSecurityGroupInput, optFns ...func(*ec2.Options))) *EC2_DeleteSecurityGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteSecurityGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteSecurityGroup_Call) Return(_a0 *ec2.DeleteSecurityGroupOutput, _a1 error) *EC2_DeleteSecurityGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteSecurityGroup_Call) RunAndReturn(run func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error)) *EC2_DeleteSecurityGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSnapshot(ctx context.Context, params *ec2.DeleteSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnapshot")
	}

	var r0 *ec2.DeleteSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) *ec2.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSnapshot'
type EC2_DeleteSnapshot_Call struct {
	*mock.Call
}

// DeleteSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteSnapshotInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteSnapshot(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteSnapshot_Call {
	return &EC2_DeleteSnapshot_Call{Call: _e.mock.On("DeleteSnapshot",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteSnapshot_Call) Run(run func(ctx context.Context, params *ec2.DeleteSnapshotInput, optFns ...func(*ec2.Options))) *EC2_DeleteSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteSnapshotInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteSnapshot_Call) Return(_a0 *ec2.DeleteSnapshotOutput, _a1 error) *EC2_DeleteSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteSnapshot_Call) RunAndReturn(run func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error)) *EC2_DeleteSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSpotDatafeedSubscription(ctx context.Context, params *ec2.DeleteSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSpotDatafeedSubscription")
	}

	var r0 *ec2.DeleteSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.DeleteSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteSpotDatafeedSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSpotDatafeedSubscription'
type EC2_DeleteSpotDatafeedSubscription_Call struct {
	*mock.Call
}

// DeleteSpotDatafeedSubscription is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteSpotDatafeedSubscriptionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteSpotDatafeedSubscription(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteSpotDatafeedSubscription_Call {
	return &EC2_DeleteSpotDatafeedSubscription_Call{Call: _e.mock.On("DeleteSpotDatafeedSubscription",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteSpotDatafeedSubscription_Call) Run(run func(ctx context.Context, params *ec2.DeleteSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options))) *EC2_DeleteSpotDatafeedSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteSpotDatafeedSubscriptionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteSpotDatafeedSubscription_Call) Return(_a0 *ec2.DeleteSpotDatafeedSubscriptionOutput, _a1 error) *EC2_DeleteSpotDatafeedSubscription_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteSpotDatafeedSubscription_Call) RunAndReturn(run func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error)) *EC2_DeleteSpotDatafeedSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSubnet(ctx context.Context, params *ec2.DeleteSubnetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnet")
	}

	var r0 *ec2.DeleteSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) *ec2.DeleteSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteSubnet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSubnet'
type EC2_DeleteSubnet_Call struct {
	*mock.Call
}

// DeleteSubnet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteSubnetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteSubnet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteSubnet_Call {
	return &EC2_DeleteSubnet_Call{Call: _e.mock.On("DeleteSubnet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteSubnet_Call) Run(run func(ctx context.Context, params *ec2.DeleteSubnetInput, optFns ...func(*ec2.Options))) *EC2_DeleteSubnet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteSubnetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteSubnet_Call) Return(_a0 *ec2.DeleteSubnetOutput, _a1 error) *EC2_DeleteSubnet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteSubnet_Call) RunAndReturn(run func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error)) *EC2_DeleteSubnet_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSubnetCidrReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSubnetCidrReservation(ctx context.Context, params *ec2.DeleteSubnetCidrReservationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnetCidrReservation")
	}

	var r0 *ec2.DeleteSubnetCidrReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) *ec2.DeleteSubnetCidrReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetCidrReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteSubnetCidrReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSubnetCidrReservation'
type EC2_DeleteSubnetCidrReservation_Call struct {
	*mock.Call
}

// DeleteSubnetCidrReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteSubnetCidrReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteSubnetCidrReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteSubnetCidrReservation_Call {
	return &EC2_DeleteSubnetCidrReservation_Call{Call: _e.mock.On("DeleteSubnetCidrReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteSubnetCidrReservation_Call) Run(run func(ctx context.Context, params *ec2.DeleteSubnetCidrReservationInput, optFns ...func(*ec2.Options))) *EC2_DeleteSubnetCidrReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteSubnetCidrReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteSubnetCidrReservation_Call) Return(_a0 *ec2.DeleteSubnetCidrReservationOutput, _a1 error) *EC2_DeleteSubnetCidrReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteSubnetCidrReservation_Call) RunAndReturn(run func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error)) *EC2_DeleteSubnetCidrReservation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTags(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTags")
	}

	var r0 *ec2.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) *ec2.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTags'
type EC2_DeleteTags_Call struct {
	*mock.Call
}

// DeleteTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTagsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTags(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTags_Call {
	return &EC2_DeleteTags_Call{Call: _e.mock.On("DeleteTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTags_Call) Run(run func(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options))) *EC2_DeleteTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTags_Call) Return(_a0 *ec2.DeleteTagsOutput, _a1 error) *EC2_DeleteTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTags_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error)) *EC2_DeleteTags_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTrafficMirrorFilter provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorFilter(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorFilter")
	}

	var r0 *ec2.DeleteTrafficMirrorFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTrafficMirrorFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTrafficMirrorFilter'
type EC2_DeleteTrafficMirrorFilter_Call struct {
	*mock.Call
}

// DeleteTrafficMirrorFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTrafficMirrorFilterInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTrafficMirrorFilter(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTrafficMirrorFilter_Call {
	return &EC2_DeleteTrafficMirrorFilter_Call{Call: _e.mock.On("DeleteTrafficMirrorFilter",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTrafficMirrorFilter_Call) Run(run func(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterInput, optFns ...func(*ec2.Options))) *EC2_DeleteTrafficMirrorFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTrafficMirrorFilterInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTrafficMirrorFilter_Call) Return(_a0 *ec2.DeleteTrafficMirrorFilterOutput, _a1 error) *EC2_DeleteTrafficMirrorFilter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTrafficMirrorFilter_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error)) *EC2_DeleteTrafficMirrorFilter_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorFilterRule(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorFilterRule")
	}

	var r0 *ec2.DeleteTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTrafficMirrorFilterRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTrafficMirrorFilterRule'
type EC2_DeleteTrafficMirrorFilterRule_Call struct {
	*mock.Call
}

// DeleteTrafficMirrorFilterRule is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTrafficMirrorFilterRuleInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTrafficMirrorFilterRule(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTrafficMirrorFilterRule_Call {
	return &EC2_DeleteTrafficMirrorFilterRule_Call{Call: _e.mock.On("DeleteTrafficMirrorFilterRule",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTrafficMirrorFilterRule_Call) Run(run func(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options))) *EC2_DeleteTrafficMirrorFilterRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTrafficMirrorFilterRuleInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTrafficMirrorFilterRule_Call) Return(_a0 *ec2.DeleteTrafficMirrorFilterRuleOutput, _a1 error) *EC2_DeleteTrafficMirrorFilterRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTrafficMirrorFilterRule_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error)) *EC2_DeleteTrafficMirrorFilterRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorSession(ctx context.Context, params *ec2.DeleteTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorSession")
	}

	var r0 *ec2.DeleteTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTrafficMirrorSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTrafficMirrorSession'
type EC2_DeleteTrafficMirrorSession_Call struct {
	*mock.Call
}

// DeleteTrafficMirrorSession is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTrafficMirrorSessionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTrafficMirrorSession(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTrafficMirrorSession_Call {
	return &EC2_DeleteTrafficMirrorSession_Call{Call: _e.mock.On("DeleteTrafficMirrorSession",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTrafficMirrorSession_Call) Run(run func(ctx context.Context, params *ec2.DeleteTrafficMirrorSessionInput, optFns ...func(*ec2.Options))) *EC2_DeleteTrafficMirrorSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTrafficMirrorSessionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTrafficMirrorSession_Call) Return(_a0 *ec2.DeleteTrafficMirrorSessionOutput, _a1 error) *EC2_DeleteTrafficMirrorSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTrafficMirrorSession_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error)) *EC2_DeleteTrafficMirrorSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTrafficMirrorTarget provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorTarget(ctx context.Context, params *ec2.DeleteTrafficMirrorTargetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTrafficMirrorTarget")
	}

	var r0 *ec2.DeleteTrafficMirrorTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTrafficMirrorTarget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTrafficMirrorTarget'
type EC2_DeleteTrafficMirrorTarget_Call struct {
	*mock.Call
}

// DeleteTrafficMirrorTarget is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTrafficMirrorTargetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTrafficMirrorTarget(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTrafficMirrorTarget_Call {
	return &EC2_DeleteTrafficMirrorTarget_Call{Call: _e.mock.On("DeleteTrafficMirrorTarget",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTrafficMirrorTarget_Call) Run(run func(ctx context.Context, params *ec2.DeleteTrafficMirrorTargetInput, optFns ...func(*ec2.Options))) *EC2_DeleteTrafficMirrorTarget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTrafficMirrorTargetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTrafficMirrorTarget_Call) Return(_a0 *ec2.DeleteTrafficMirrorTargetOutput, _a1 error) *EC2_DeleteTrafficMirrorTarget_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTrafficMirrorTarget_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error)) *EC2_DeleteTrafficMirrorTarget_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGateway(ctx context.Context, params *ec2.DeleteTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGateway")
	}

	var r0 *ec2.DeleteTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGateway'
type EC2_DeleteTransitGateway_Call struct {
	*mock.Call
}

// DeleteTransitGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGateway_Call {
	return &EC2_DeleteTransitGateway_Call{Call: _e.mock.On("DeleteTransitGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGateway_Call) Return(_a0 *ec2.DeleteTransitGatewayOutput, _a1 error) *EC2_DeleteTransitGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error)) *EC2_DeleteTransitGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayConnect provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayConnect(ctx context.Context, params *ec2.DeleteTransitGatewayConnectInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayConnect")
	}

	var r0 *ec2.DeleteTransitGatewayConnectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayConnectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayConnectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayConnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayConnect'
type EC2_DeleteTransitGatewayConnect_Call struct {
	*mock.Call
}

// DeleteTransitGatewayConnect is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayConnectInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayConnect(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayConnect_Call {
	return &EC2_DeleteTransitGatewayConnect_Call{Call: _e.mock.On("DeleteTransitGatewayConnect",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayConnect_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayConnectInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayConnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayConnectInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayConnect_Call) Return(_a0 *ec2.DeleteTransitGatewayConnectOutput, _a1 error) *EC2_DeleteTransitGatewayConnect_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayConnect_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error)) *EC2_DeleteTransitGatewayConnect_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayConnectPeer provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayConnectPeer(ctx context.Context, params *ec2.DeleteTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayConnectPeer")
	}

	var r0 *ec2.DeleteTransitGatewayConnectPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayConnectPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayConnectPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayConnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayConnectPeer'
type EC2_DeleteTransitGatewayConnectPeer_Call struct {
	*mock.Call
}

// DeleteTransitGatewayConnectPeer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayConnectPeerInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayConnectPeer(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayConnectPeer_Call {
	return &EC2_DeleteTransitGatewayConnectPeer_Call{Call: _e.mock.On("DeleteTransitGatewayConnectPeer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayConnectPeer_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayConnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayConnectPeerInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayConnectPeer_Call) Return(_a0 *ec2.DeleteTransitGatewayConnectPeerOutput, _a1 error) *EC2_DeleteTransitGatewayConnectPeer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayConnectPeer_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error)) *EC2_DeleteTransitGatewayConnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayMulticastDomain(ctx context.Context, params *ec2.DeleteTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayMulticastDomain")
	}

	var r0 *ec2.DeleteTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayMulticastDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayMulticastDomain'
type EC2_DeleteTransitGatewayMulticastDomain_Call struct {
	*mock.Call
}

// DeleteTransitGatewayMulticastDomain is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayMulticastDomainInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayMulticastDomain(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayMulticastDomain_Call {
	return &EC2_DeleteTransitGatewayMulticastDomain_Call{Call: _e.mock.On("DeleteTransitGatewayMulticastDomain",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayMulticastDomain_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayMulticastDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayMulticastDomainInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayMulticastDomain_Call) Return(_a0 *ec2.DeleteTransitGatewayMulticastDomainOutput, _a1 error) *EC2_DeleteTransitGatewayMulticastDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayMulticastDomain_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error)) *EC2_DeleteTransitGatewayMulticastDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.DeleteTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.DeleteTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayPeeringAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayPeeringAttachment'
type EC2_DeleteTransitGatewayPeeringAttachment_Call struct {
	*mock.Call
}

// DeleteTransitGatewayPeeringAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayPeeringAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayPeeringAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayPeeringAttachment_Call {
	return &EC2_DeleteTransitGatewayPeeringAttachment_Call{Call: _e.mock.On("DeleteTransitGatewayPeeringAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayPeeringAttachment_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayPeeringAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayPeeringAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayPeeringAttachment_Call) Return(_a0 *ec2.DeleteTransitGatewayPeeringAttachmentOutput, _a1 error) *EC2_DeleteTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayPeeringAttachment_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error)) *EC2_DeleteTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayPrefixListReference(ctx context.Context, params *ec2.DeleteTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayPrefixListReference")
	}

	var r0 *ec2.DeleteTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayPrefixListReference_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayPrefixListReference'
type EC2_DeleteTransitGatewayPrefixListReference_Call struct {
	*mock.Call
}

// DeleteTransitGatewayPrefixListReference is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayPrefixListReferenceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayPrefixListReference(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayPrefixListReference_Call {
	return &EC2_DeleteTransitGatewayPrefixListReference_Call{Call: _e.mock.On("DeleteTransitGatewayPrefixListReference",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayPrefixListReference_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayPrefixListReference_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayPrefixListReferenceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayPrefixListReference_Call) Return(_a0 *ec2.DeleteTransitGatewayPrefixListReferenceOutput, _a1 error) *EC2_DeleteTransitGatewayPrefixListReference_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayPrefixListReference_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error)) *EC2_DeleteTransitGatewayPrefixListReference_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayRoute(ctx context.Context, params *ec2.DeleteTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayRoute")
	}

	var r0 *ec2.DeleteTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayRoute'
type EC2_DeleteTransitGatewayRoute_Call struct {
	*mock.Call
}

// DeleteTransitGatewayRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayRoute_Call {
	return &EC2_DeleteTransitGatewayRoute_Call{Call: _e.mock.On("DeleteTransitGatewayRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayRoute_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayRouteInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayRoute_Call) Return(_a0 *ec2.DeleteTransitGatewayRouteOutput, _a1 error) *EC2_DeleteTransitGatewayRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayRoute_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error)) *EC2_DeleteTransitGatewayRoute_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayRouteTable(ctx context.Context, params *ec2.DeleteTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayRouteTable")
	}

	var r0 *ec2.DeleteTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayRouteTable'
type EC2_DeleteTransitGatewayRouteTable_Call struct {
	*mock.Call
}

// DeleteTransitGatewayRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayRouteTable_Call {
	return &EC2_DeleteTransitGatewayRouteTable_Call{Call: _e.mock.On("DeleteTransitGatewayRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayRouteTable_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayRouteTableInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayRouteTable_Call) Return(_a0 *ec2.DeleteTransitGatewayRouteTableOutput, _a1 error) *EC2_DeleteTransitGatewayRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error)) *EC2_DeleteTransitGatewayRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayVpcAttachment(ctx context.Context, params *ec2.DeleteTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTransitGatewayVpcAttachment")
	}

	var r0 *ec2.DeleteTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteTransitGatewayVpcAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTransitGatewayVpcAttachment'
type EC2_DeleteTransitGatewayVpcAttachment_Call struct {
	*mock.Call
}

// DeleteTransitGatewayVpcAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTransitGatewayVpcAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteTransitGatewayVpcAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteTransitGatewayVpcAttachment_Call {
	return &EC2_DeleteTransitGatewayVpcAttachment_Call{Call: _e.mock.On("DeleteTransitGatewayVpcAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteTransitGatewayVpcAttachment_Call) Run(run func(ctx context.Context, params *ec2.DeleteTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options))) *EC2_DeleteTransitGatewayVpcAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTransitGatewayVpcAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteTransitGatewayVpcAttachment_Call) Return(_a0 *ec2.DeleteTransitGatewayVpcAttachmentOutput, _a1 error) *EC2_DeleteTransitGatewayVpcAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteTransitGatewayVpcAttachment_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error)) *EC2_DeleteTransitGatewayVpcAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVolume(ctx context.Context, params *ec2.DeleteVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVolume")
	}

	var r0 *ec2.DeleteVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) *ec2.DeleteVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVolume'
type EC2_DeleteVolume_Call struct {
	*mock.Call
}

// DeleteVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVolumeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVolume(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVolume_Call {
	return &EC2_DeleteVolume_Call{Call: _e.mock.On("DeleteVolume",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVolume_Call) Run(run func(ctx context.Context, params *ec2.DeleteVolumeInput, optFns ...func(*ec2.Options))) *EC2_DeleteVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVolumeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVolume_Call) Return(_a0 *ec2.DeleteVolumeOutput, _a1 error) *EC2_DeleteVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVolume_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error)) *EC2_DeleteVolume_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpc(ctx context.Context, params *ec2.DeleteVpcInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpc")
	}

	var r0 *ec2.DeleteVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) *ec2.DeleteVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpc'
type EC2_DeleteVpc_Call struct {
	*mock.Call
}

// DeleteVpc is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpcInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpc(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpc_Call {
	return &EC2_DeleteVpc_Call{Call: _e.mock.On("DeleteVpc",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpc_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpcInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpcInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpc_Call) Return(_a0 *ec2.DeleteVpcOutput, _a1 error) *EC2_DeleteVpc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpc_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error)) *EC2_DeleteVpc_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpcEndpointConnectionNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcEndpointConnectionNotifications(ctx context.Context, params *ec2.DeleteVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpointConnectionNotifications")
	}

	var r0 *ec2.DeleteVpcEndpointConnectionNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointConnectionNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpcEndpointConnectionNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpcEndpointConnectionNotifications'
type EC2_DeleteVpcEndpointConnectionNotifications_Call struct {
	*mock.Call
}

// DeleteVpcEndpointConnectionNotifications is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpcEndpointConnectionNotificationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpcEndpointConnectionNotifications(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpcEndpointConnectionNotifications_Call {
	return &EC2_DeleteVpcEndpointConnectionNotifications_Call{Call: _e.mock.On("DeleteVpcEndpointConnectionNotifications",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpcEndpointConnectionNotifications_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpcEndpointConnectionNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpcEndpointConnectionNotificationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpcEndpointConnectionNotifications_Call) Return(_a0 *ec2.DeleteVpcEndpointConnectionNotificationsOutput, _a1 error) *EC2_DeleteVpcEndpointConnectionNotifications_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpcEndpointConnectionNotifications_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error)) *EC2_DeleteVpcEndpointConnectionNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpcEndpointServiceConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcEndpointServiceConfigurations(ctx context.Context, params *ec2.DeleteVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpointServiceConfigurations")
	}

	var r0 *ec2.DeleteVpcEndpointServiceConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointServiceConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpcEndpointServiceConfigurations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpcEndpointServiceConfigurations'
type EC2_DeleteVpcEndpointServiceConfigurations_Call struct {
	*mock.Call
}

// DeleteVpcEndpointServiceConfigurations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpcEndpointServiceConfigurationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpcEndpointServiceConfigurations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpcEndpointServiceConfigurations_Call {
	return &EC2_DeleteVpcEndpointServiceConfigurations_Call{Call: _e.mock.On("DeleteVpcEndpointServiceConfigurations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpcEndpointServiceConfigurations_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpcEndpointServiceConfigurations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpcEndpointServiceConfigurationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpcEndpointServiceConfigurations_Call) Return(_a0 *ec2.DeleteVpcEndpointServiceConfigurationsOutput, _a1 error) *EC2_DeleteVpcEndpointServiceConfigurations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpcEndpointServiceConfigurations_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error)) *EC2_DeleteVpcEndpointServiceConfigurations_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcEndpoints(ctx context.Context, params *ec2.DeleteVpcEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcEndpoints")
	}

	var r0 *ec2.DeleteVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpcEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpcEndpoints'
type EC2_DeleteVpcEndpoints_Call struct {
	*mock.Call
}

// DeleteVpcEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpcEndpointsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpcEndpoints(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpcEndpoints_Call {
	return &EC2_DeleteVpcEndpoints_Call{Call: _e.mock.On("DeleteVpcEndpoints",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpcEndpoints_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpcEndpointsInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpcEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpcEndpointsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpcEndpoints_Call) Return(_a0 *ec2.DeleteVpcEndpointsOutput, _a1 error) *EC2_DeleteVpcEndpoints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpcEndpoints_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error)) *EC2_DeleteVpcEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcPeeringConnection(ctx context.Context, params *ec2.DeleteVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpcPeeringConnection")
	}

	var r0 *ec2.DeleteVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.DeleteVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpcPeeringConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpcPeeringConnection'
type EC2_DeleteVpcPeeringConnection_Call struct {
	*mock.Call
}

// DeleteVpcPeeringConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpcPeeringConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpcPeeringConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpcPeeringConnection_Call {
	return &EC2_DeleteVpcPeeringConnection_Call{Call: _e.mock.On("DeleteVpcPeeringConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpcPeeringConnection_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpcPeeringConnectionInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpcPeeringConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpcPeeringConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpcPeeringConnection_Call) Return(_a0 *ec2.DeleteVpcPeeringConnectionOutput, _a1 error) *EC2_DeleteVpcPeeringConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpcPeeringConnection_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error)) *EC2_DeleteVpcPeeringConnection_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpnConnection(ctx context.Context, params *ec2.DeleteVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnConnection")
	}

	var r0 *ec2.DeleteVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) *ec2.DeleteVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpnConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpnConnection'
type EC2_DeleteVpnConnection_Call struct {
	*mock.Call
}

// DeleteVpnConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpnConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpnConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpnConnection_Call {
	return &EC2_DeleteVpnConnection_Call{Call: _e.mock.On("DeleteVpnConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpnConnection_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpnConnectionInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpnConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpnConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpnConnection_Call) Return(_a0 *ec2.DeleteVpnConnectionOutput, _a1 error) *EC2_DeleteVpnConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpnConnection_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error)) *EC2_DeleteVpnConnection_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpnConnectionRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpnConnectionRoute(ctx context.Context, params *ec2.DeleteVpnConnectionRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnConnectionRoute")
	}

	var r0 *ec2.DeleteVpnConnectionRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) *ec2.DeleteVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpnConnectionRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpnConnectionRoute'
type EC2_DeleteVpnConnectionRoute_Call struct {
	*mock.Call
}

// DeleteVpnConnectionRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpnConnectionRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpnConnectionRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpnConnectionRoute_Call {
	return &EC2_DeleteVpnConnectionRoute_Call{Call: _e.mock.On("DeleteVpnConnectionRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpnConnectionRoute_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpnConnectionRouteInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpnConnectionRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpnConnectionRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpnConnectionRoute_Call) Return(_a0 *ec2.DeleteVpnConnectionRouteOutput, _a1 error) *EC2_DeleteVpnConnectionRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpnConnectionRoute_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error)) *EC2_DeleteVpnConnectionRoute_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpnGateway(ctx context.Context, params *ec2.DeleteVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVpnGateway")
	}

	var r0 *ec2.DeleteVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) *ec2.DeleteVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeleteVpnGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVpnGateway'
type EC2_DeleteVpnGateway_Call struct {
	*mock.Call
}

// DeleteVpnGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteVpnGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeleteVpnGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeleteVpnGateway_Call {
	return &EC2_DeleteVpnGateway_Call{Call: _e.mock.On("DeleteVpnGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeleteVpnGateway_Call) Run(run func(ctx context.Context, params *ec2.DeleteVpnGatewayInput, optFns ...func(*ec2.Options))) *EC2_DeleteVpnGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteVpnGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeleteVpnGateway_Call) Return(_a0 *ec2.DeleteVpnGatewayOutput, _a1 error) *EC2_DeleteVpnGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeleteVpnGateway_Call) RunAndReturn(run func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error)) *EC2_DeleteVpnGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DeprovisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeprovisionByoipCidr(ctx context.Context, params *ec2.DeprovisionByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionByoipCidr")
	}

	var r0 *ec2.DeprovisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeprovisionByoipCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeprovisionByoipCidr'
type EC2_DeprovisionByoipCidr_Call struct {
	*mock.Call
}

// DeprovisionByoipCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeprovisionByoipCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeprovisionByoipCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeprovisionByoipCidr_Call {
	return &EC2_DeprovisionByoipCidr_Call{Call: _e.mock.On("DeprovisionByoipCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeprovisionByoipCidr_Call) Run(run func(ctx context.Context, params *ec2.DeprovisionByoipCidrInput, optFns ...func(*ec2.Options))) *EC2_DeprovisionByoipCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeprovisionByoipCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeprovisionByoipCidr_Call) Return(_a0 *ec2.DeprovisionByoipCidrOutput, _a1 error) *EC2_DeprovisionByoipCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeprovisionByoipCidr_Call) RunAndReturn(run func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error)) *EC2_DeprovisionByoipCidr_Call {
	_c.Call.Return(run)
	return _c
}

// DeprovisionIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeprovisionIpamPoolCidr(ctx context.Context, params *ec2.DeprovisionIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionIpamPoolCidr")
	}

	var r0 *ec2.DeprovisionIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeprovisionIpamPoolCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeprovisionIpamPoolCidr'
type EC2_DeprovisionIpamPoolCidr_Call struct {
	*mock.Call
}

// DeprovisionIpamPoolCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeprovisionIpamPoolCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeprovisionIpamPoolCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeprovisionIpamPoolCidr_Call {
	return &EC2_DeprovisionIpamPoolCidr_Call{Call: _e.mock.On("DeprovisionIpamPoolCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeprovisionIpamPoolCidr_Call) Run(run func(ctx context.Context, params *ec2.DeprovisionIpamPoolCidrInput, optFns ...func(*ec2.Options))) *EC2_DeprovisionIpamPoolCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeprovisionIpamPoolCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeprovisionIpamPoolCidr_Call) Return(_a0 *ec2.DeprovisionIpamPoolCidrOutput, _a1 error) *EC2_DeprovisionIpamPoolCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeprovisionIpamPoolCidr_Call) RunAndReturn(run func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error)) *EC2_DeprovisionIpamPoolCidr_Call {
	_c.Call.Return(run)
	return _c
}

// DeprovisionPublicIpv4PoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeprovisionPublicIpv4PoolCidr(ctx context.Context, params *ec2.DeprovisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeprovisionPublicIpv4PoolCidr")
	}

	var r0 *ec2.DeprovisionPublicIpv4PoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionPublicIpv4PoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionPublicIpv4PoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeprovisionPublicIpv4PoolCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeprovisionPublicIpv4PoolCidr'
type EC2_DeprovisionPublicIpv4PoolCidr_Call struct {
	*mock.Call
}

// DeprovisionPublicIpv4PoolCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeprovisionPublicIpv4PoolCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeprovisionPublicIpv4PoolCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeprovisionPublicIpv4PoolCidr_Call {
	return &EC2_DeprovisionPublicIpv4PoolCidr_Call{Call: _e.mock.On("DeprovisionPublicIpv4PoolCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeprovisionPublicIpv4PoolCidr_Call) Run(run func(ctx context.Context, params *ec2.DeprovisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options))) *EC2_DeprovisionPublicIpv4PoolCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeprovisionPublicIpv4PoolCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeprovisionPublicIpv4PoolCidr_Call) Return(_a0 *ec2.DeprovisionPublicIpv4PoolCidrOutput, _a1 error) *EC2_DeprovisionPublicIpv4PoolCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeprovisionPublicIpv4PoolCidr_Call) RunAndReturn(run func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error)) *EC2_DeprovisionPublicIpv4PoolCidr_Call {
	_c.Call.Return(run)
	return _c
}

// DeregisterImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterImage(ctx context.Context, params *ec2.DeregisterImageInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterImage")
	}

	var r0 *ec2.DeregisterImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) *ec2.DeregisterImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeregisterImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeregisterImage'
type EC2_DeregisterImage_Call struct {
	*mock.Call
}

// DeregisterImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeregisterImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeregisterImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeregisterImage_Call {
	return &EC2_DeregisterImage_Call{Call: _e.mock.On("DeregisterImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeregisterImage_Call) Run(run func(ctx context.Context, params *ec2.DeregisterImageInput, optFns ...func(*ec2.Options))) *EC2_DeregisterImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeregisterImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeregisterImage_Call) Return(_a0 *ec2.DeregisterImageOutput, _a1 error) *EC2_DeregisterImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeregisterImage_Call) RunAndReturn(run func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error)) *EC2_DeregisterImage_Call {
	_c.Call.Return(run)
	return _c
}

// DeregisterInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterInstanceEventNotificationAttributes(ctx context.Context, params *ec2.DeregisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterInstanceEventNotificationAttributes")
	}

	var r0 *ec2.DeregisterInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.DeregisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeregisterInstanceEventNotificationAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeregisterInstanceEventNotificationAttributes'
type EC2_DeregisterInstanceEventNotificationAttributes_Call struct {
	*mock.Call
}

// DeregisterInstanceEventNotificationAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeregisterInstanceEventNotificationAttributesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeregisterInstanceEventNotificationAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeregisterInstanceEventNotificationAttributes_Call {
	return &EC2_DeregisterInstanceEventNotificationAttributes_Call{Call: _e.mock.On("DeregisterInstanceEventNotificationAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeregisterInstanceEventNotificationAttributes_Call) Run(run func(ctx context.Context, params *ec2.DeregisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options))) *EC2_DeregisterInstanceEventNotificationAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeregisterInstanceEventNotificationAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeregisterInstanceEventNotificationAttributes_Call) Return(_a0 *ec2.DeregisterInstanceEventNotificationAttributesOutput, _a1 error) *EC2_DeregisterInstanceEventNotificationAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeregisterInstanceEventNotificationAttributes_Call) RunAndReturn(run func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error)) *EC2_DeregisterInstanceEventNotificationAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// DeregisterTransitGatewayMulticastGroupMembers provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterTransitGatewayMulticastGroupMembers(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterTransitGatewayMulticastGroupMembers")
	}

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeregisterTransitGatewayMulticastGroupMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeregisterTransitGatewayMulticastGroupMembers'
type EC2_DeregisterTransitGatewayMulticastGroupMembers_Call struct {
	*mock.Call
}

// DeregisterTransitGatewayMulticastGroupMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeregisterTransitGatewayMulticastGroupMembersInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeregisterTransitGatewayMulticastGroupMembers(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call {
	return &EC2_DeregisterTransitGatewayMulticastGroupMembers_Call{Call: _e.mock.On("DeregisterTransitGatewayMulticastGroupMembers",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call) Run(run func(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options))) *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeregisterTransitGatewayMulticastGroupMembersInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call) Return(_a0 *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, _a1 error) *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call) RunAndReturn(run func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error)) *EC2_DeregisterTransitGatewayMulticastGroupMembers_Call {
	_c.Call.Return(run)
	return _c
}

// DeregisterTransitGatewayMulticastGroupSources provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterTransitGatewayMulticastGroupSources(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterTransitGatewayMulticastGroupSources")
	}

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DeregisterTransitGatewayMulticastGroupSources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeregisterTransitGatewayMulticastGroupSources'
type EC2_DeregisterTransitGatewayMulticastGroupSources_Call struct {
	*mock.Call
}

// DeregisterTransitGatewayMulticastGroupSources is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DeregisterTransitGatewayMulticastGroupSources(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DeregisterTransitGatewayMulticastGroupSources_Call {
	return &EC2_DeregisterTransitGatewayMulticastGroupSources_Call{Call: _e.mock.On("DeregisterTransitGatewayMulticastGroupSources",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DeregisterTransitGatewayMulticastGroupSources_Call) Run(run func(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options))) *EC2_DeregisterTransitGatewayMulticastGroupSources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeregisterTransitGatewayMulticastGroupSourcesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DeregisterTransitGatewayMulticastGroupSources_Call) Return(_a0 *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, _a1 error) *EC2_DeregisterTransitGatewayMulticastGroupSources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DeregisterTransitGatewayMulticastGroupSources_Call) RunAndReturn(run func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error)) *EC2_DeregisterTransitGatewayMulticastGroupSources_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAccountAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAccountAttributes(ctx context.Context, params *ec2.DescribeAccountAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccountAttributes")
	}

	var r0 *ec2.DescribeAccountAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) *ec2.DescribeAccountAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAccountAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeAccountAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAccountAttributes'
type EC2_DescribeAccountAttributes_Call struct {
	*mock.Call
}

// DescribeAccountAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeAccountAttributesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeAccountAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeAccountAttributes_Call {
	return &EC2_DescribeAccountAttributes_Call{Call: _e.mock.On("DescribeAccountAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeAccountAttributes_Call) Run(run func(ctx context.Context, params *ec2.DescribeAccountAttributesInput, optFns ...func(*ec2.Options))) *EC2_DescribeAccountAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeAccountAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeAccountAttributes_Call) Return(_a0 *ec2.DescribeAccountAttributesOutput, _a1 error) *EC2_DescribeAccountAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeAccountAttributes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error)) *EC2_DescribeAccountAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAddresses(ctx context.Context, params *ec2.DescribeAddressesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddresses")
	}

	var r0 *ec2.DescribeAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) *ec2.DescribeAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAddresses'
type EC2_DescribeAddresses_Call struct {
	*mock.Call
}

// DescribeAddresses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeAddressesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeAddresses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeAddresses_Call {
	return &EC2_DescribeAddresses_Call{Call: _e.mock.On("DescribeAddresses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeAddresses_Call) Run(run func(ctx context.Context, params *ec2.DescribeAddressesInput, optFns ...func(*ec2.Options))) *EC2_DescribeAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeAddressesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeAddresses_Call) Return(_a0 *ec2.DescribeAddressesOutput, _a1 error) *EC2_DescribeAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeAddresses_Call) RunAndReturn(run func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error)) *EC2_DescribeAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAddressesAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAddressesAttribute(ctx context.Context, params *ec2.DescribeAddressesAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddressesAttribute")
	}

	var r0 *ec2.DescribeAddressesAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) *ec2.DescribeAddressesAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeAddressesAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAddressesAttribute'
type EC2_DescribeAddressesAttribute_Call struct {
	*mock.Call
}

// DescribeAddressesAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeAddressesAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeAddressesAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeAddressesAttribute_Call {
	return &EC2_DescribeAddressesAttribute_Call{Call: _e.mock.On("DescribeAddressesAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeAddressesAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeAddressesAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeAddressesAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeAddressesAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeAddressesAttribute_Call) Return(_a0 *ec2.DescribeAddressesAttributeOutput, _a1 error) *EC2_DescribeAddressesAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeAddressesAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error)) *EC2_DescribeAddressesAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAggregateIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAggregateIdFormat(ctx context.Context, params *ec2.DescribeAggregateIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAggregateIdFormat")
	}

	var r0 *ec2.DescribeAggregateIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeAggregateIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAggregateIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeAggregateIdFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAggregateIdFormat'
type EC2_DescribeAggregateIdFormat_Call struct {
	*mock.Call
}

// DescribeAggregateIdFormat is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeAggregateIdFormatInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeAggregateIdFormat(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeAggregateIdFormat_Call {
	return &EC2_DescribeAggregateIdFormat_Call{Call: _e.mock.On("DescribeAggregateIdFormat",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeAggregateIdFormat_Call) Run(run func(ctx context.Context, params *ec2.DescribeAggregateIdFormatInput, optFns ...func(*ec2.Options))) *EC2_DescribeAggregateIdFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeAggregateIdFormatInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeAggregateIdFormat_Call) Return(_a0 *ec2.DescribeAggregateIdFormatOutput, _a1 error) *EC2_DescribeAggregateIdFormat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeAggregateIdFormat_Call) RunAndReturn(run func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error)) *EC2_DescribeAggregateIdFormat_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAvailabilityZones provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAvailabilityZones(ctx context.Context, params *ec2.DescribeAvailabilityZonesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAvailabilityZones")
	}

	var r0 *ec2.DescribeAvailabilityZonesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) *ec2.DescribeAvailabilityZonesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAvailabilityZonesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeAvailabilityZones_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAvailabilityZones'
type EC2_DescribeAvailabilityZones_Call struct {
	*mock.Call
}

// DescribeAvailabilityZones is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeAvailabilityZonesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeAvailabilityZones(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeAvailabilityZones_Call {
	return &EC2_DescribeAvailabilityZones_Call{Call: _e.mock.On("DescribeAvailabilityZones",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeAvailabilityZones_Call) Run(run func(ctx context.Context, params *ec2.DescribeAvailabilityZonesInput, optFns ...func(*ec2.Options))) *EC2_DescribeAvailabilityZones_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeAvailabilityZonesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeAvailabilityZones_Call) Return(_a0 *ec2.DescribeAvailabilityZonesOutput, _a1 error) *EC2_DescribeAvailabilityZones_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeAvailabilityZones_Call) RunAndReturn(run func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error)) *EC2_DescribeAvailabilityZones_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeBundleTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeBundleTasks(ctx context.Context, params *ec2.DescribeBundleTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeBundleTasks")
	}

	var r0 *ec2.DescribeBundleTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) *ec2.DescribeBundleTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeBundleTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeBundleTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeBundleTasks'
type EC2_DescribeBundleTasks_Call struct {
	*mock.Call
}

// DescribeBundleTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeBundleTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeBundleTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeBundleTasks_Call {
	return &EC2_DescribeBundleTasks_Call{Call: _e.mock.On("DescribeBundleTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeBundleTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeBundleTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeBundleTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeBundleTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeBundleTasks_Call) Return(_a0 *ec2.DescribeBundleTasksOutput, _a1 error) *EC2_DescribeBundleTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeBundleTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error)) *EC2_DescribeBundleTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeByoipCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeByoipCidrs(ctx context.Context, params *ec2.DescribeByoipCidrsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeByoipCidrs")
	}

	var r0 *ec2.DescribeByoipCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) *ec2.DescribeByoipCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeByoipCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeByoipCidrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeByoipCidrs'
type EC2_DescribeByoipCidrs_Call struct {
	*mock.Call
}

// DescribeByoipCidrs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeByoipCidrsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeByoipCidrs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeByoipCidrs_Call {
	return &EC2_DescribeByoipCidrs_Call{Call: _e.mock.On("DescribeByoipCidrs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeByoipCidrs_Call) Run(run func(ctx context.Context, params *ec2.DescribeByoipCidrsInput, optFns ...func(*ec2.Options))) *EC2_DescribeByoipCidrs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeByoipCidrsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeByoipCidrs_Call) Return(_a0 *ec2.DescribeByoipCidrsOutput, _a1 error) *EC2_DescribeByoipCidrs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeByoipCidrs_Call) RunAndReturn(run func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error)) *EC2_DescribeByoipCidrs_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCapacityReservationFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCapacityReservationFleets(ctx context.Context, params *ec2.DescribeCapacityReservationFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityReservationFleets")
	}

	var r0 *ec2.DescribeCapacityReservationFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeCapacityReservationFleets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCapacityReservationFleets'
type EC2_DescribeCapacityReservationFleets_Call struct {
	*mock.Call
}

// DescribeCapacityReservationFleets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeCapacityReservationFleetsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeCapacityReservationFleets(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeCapacityReservationFleets_Call {
	return &EC2_DescribeCapacityReservationFleets_Call{Call: _e.mock.On("DescribeCapacityReservationFleets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeCapacityReservationFleets_Call) Run(run func(ctx context.Context, params *ec2.DescribeCapacityReservationFleetsInput, optFns ...func(*ec2.Options))) *EC2_DescribeCapacityReservationFleets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeCapacityReservationFleetsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeCapacityReservationFleets_Call) Return(_a0 *ec2.DescribeCapacityReservationFleetsOutput, _a1 error) *EC2_DescribeCapacityReservationFleets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeCapacityReservationFleets_Call) RunAndReturn(run func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error)) *EC2_DescribeCapacityReservationFleets_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCapacityReservations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCapacityReservations(ctx context.Context, params *ec2.DescribeCapacityReservationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCapacityReservations")
	}

	var r0 *ec2.DescribeCapacityReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeCapacityReservations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCapacityReservations'
type EC2_DescribeCapacityReservations_Call struct {
	*mock.Call
}

// DescribeCapacityReservations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeCapacityReservationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeCapacityReservations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeCapacityReservations_Call {
	return &EC2_DescribeCapacityReservations_Call{Call: _e.mock.On("DescribeCapacityReservations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeCapacityReservations_Call) Run(run func(ctx context.Context, params *ec2.DescribeCapacityReservationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeCapacityReservations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeCapacityReservationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeCapacityReservations_Call) Return(_a0 *ec2.DescribeCapacityReservationsOutput, _a1 error) *EC2_DescribeCapacityReservations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeCapacityReservations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error)) *EC2_DescribeCapacityReservations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCarrierGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCarrierGateways(ctx context.Context, params *ec2.DescribeCarrierGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCarrierGateways")
	}

	var r0 *ec2.DescribeCarrierGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeCarrierGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCarrierGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeCarrierGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCarrierGateways'
type EC2_DescribeCarrierGateways_Call struct {
	*mock.Call
}

// DescribeCarrierGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeCarrierGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeCarrierGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeCarrierGateways_Call {
	return &EC2_DescribeCarrierGateways_Call{Call: _e.mock.On("DescribeCarrierGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeCarrierGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeCarrierGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeCarrierGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeCarrierGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeCarrierGateways_Call) Return(_a0 *ec2.DescribeCarrierGatewaysOutput, _a1 error) *EC2_DescribeCarrierGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeCarrierGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error)) *EC2_DescribeCarrierGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClassicLinkInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClassicLinkInstances(ctx context.Context, params *ec2.DescribeClassicLinkInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClassicLinkInstances")
	}

	var r0 *ec2.DescribeClassicLinkInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) *ec2.DescribeClassicLinkInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClassicLinkInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeClassicLinkInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClassicLinkInstances'
type EC2_DescribeClassicLinkInstances_Call struct {
	*mock.Call
}

// DescribeClassicLinkInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeClassicLinkInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeClassicLinkInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeClassicLinkInstances_Call {
	return &EC2_DescribeClassicLinkInstances_Call{Call: _e.mock.On("DescribeClassicLinkInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeClassicLinkInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeClassicLinkInstancesInput, optFns ...func(*ec2.Options))) *EC2_DescribeClassicLinkInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeClassicLinkInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeClassicLinkInstances_Call) Return(_a0 *ec2.DescribeClassicLinkInstancesOutput, _a1 error) *EC2_DescribeClassicLinkInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeClassicLinkInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error)) *EC2_DescribeClassicLinkInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClientVpnAuthorizationRules provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnAuthorizationRules(ctx context.Context, params *ec2.DescribeClientVpnAuthorizationRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnAuthorizationRules")
	}

	var r0 *ec2.DescribeClientVpnAuthorizationRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnAuthorizationRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnAuthorizationRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeClientVpnAuthorizationRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClientVpnAuthorizationRules'
type EC2_DescribeClientVpnAuthorizationRules_Call struct {
	*mock.Call
}

// DescribeClientVpnAuthorizationRules is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeClientVpnAuthorizationRulesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeClientVpnAuthorizationRules(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeClientVpnAuthorizationRules_Call {
	return &EC2_DescribeClientVpnAuthorizationRules_Call{Call: _e.mock.On("DescribeClientVpnAuthorizationRules",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeClientVpnAuthorizationRules_Call) Run(run func(ctx context.Context, params *ec2.DescribeClientVpnAuthorizationRulesInput, optFns ...func(*ec2.Options))) *EC2_DescribeClientVpnAuthorizationRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeClientVpnAuthorizationRulesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeClientVpnAuthorizationRules_Call) Return(_a0 *ec2.DescribeClientVpnAuthorizationRulesOutput, _a1 error) *EC2_DescribeClientVpnAuthorizationRules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeClientVpnAuthorizationRules_Call) RunAndReturn(run func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error)) *EC2_DescribeClientVpnAuthorizationRules_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClientVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnConnections(ctx context.Context, params *ec2.DescribeClientVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnConnections")
	}

	var r0 *ec2.DescribeClientVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeClientVpnConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClientVpnConnections'
type EC2_DescribeClientVpnConnections_Call struct {
	*mock.Call
}

// DescribeClientVpnConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeClientVpnConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeClientVpnConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeClientVpnConnections_Call {
	return &EC2_DescribeClientVpnConnections_Call{Call: _e.mock.On("DescribeClientVpnConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeClientVpnConnections_Call) Run(run func(ctx context.Context, params *ec2.DescribeClientVpnConnectionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeClientVpnConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeClientVpnConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeClientVpnConnections_Call) Return(_a0 *ec2.DescribeClientVpnConnectionsOutput, _a1 error) *EC2_DescribeClientVpnConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeClientVpnConnections_Call) RunAndReturn(run func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error)) *EC2_DescribeClientVpnConnections_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClientVpnEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnEndpoints(ctx context.Context, params *ec2.DescribeClientVpnEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnEndpoints")
	}

	var r0 *ec2.DescribeClientVpnEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeClientVpnEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClientVpnEndpoints'
type EC2_DescribeClientVpnEndpoints_Call struct {
	*mock.Call
}

// DescribeClientVpnEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeClientVpnEndpointsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeClientVpnEndpoints(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeClientVpnEndpoints_Call {
	return &EC2_DescribeClientVpnEndpoints_Call{Call: _e.mock.On("DescribeClientVpnEndpoints",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeClientVpnEndpoints_Call) Run(run func(ctx context.Context, params *ec2.DescribeClientVpnEndpointsInput, optFns ...func(*ec2.Options))) *EC2_DescribeClientVpnEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeClientVpnEndpointsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeClientVpnEndpoints_Call) Return(_a0 *ec2.DescribeClientVpnEndpointsOutput, _a1 error) *EC2_DescribeClientVpnEndpoints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeClientVpnEndpoints_Call) RunAndReturn(run func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error)) *EC2_DescribeClientVpnEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClientVpnRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnRoutes(ctx context.Context, params *ec2.DescribeClientVpnRoutesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnRoutes")
	}

	var r0 *ec2.DescribeClientVpnRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeClientVpnRoutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClientVpnRoutes'
type EC2_DescribeClientVpnRoutes_Call struct {
	*mock.Call
}

// DescribeClientVpnRoutes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeClientVpnRoutesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeClientVpnRoutes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeClientVpnRoutes_Call {
	return &EC2_DescribeClientVpnRoutes_Call{Call: _e.mock.On("DescribeClientVpnRoutes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeClientVpnRoutes_Call) Run(run func(ctx context.Context, params *ec2.DescribeClientVpnRoutesInput, optFns ...func(*ec2.Options))) *EC2_DescribeClientVpnRoutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeClientVpnRoutesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeClientVpnRoutes_Call) Return(_a0 *ec2.DescribeClientVpnRoutesOutput, _a1 error) *EC2_DescribeClientVpnRoutes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeClientVpnRoutes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error)) *EC2_DescribeClientVpnRoutes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeClientVpnTargetNetworks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnTargetNetworks(ctx context.Context, params *ec2.DescribeClientVpnTargetNetworksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeClientVpnTargetNetworks")
	}

	var r0 *ec2.DescribeClientVpnTargetNetworksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnTargetNetworksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnTargetNetworksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeClientVpnTargetNetworks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeClientVpnTargetNetworks'
type EC2_DescribeClientVpnTargetNetworks_Call struct {
	*mock.Call
}

// DescribeClientVpnTargetNetworks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeClientVpnTargetNetworksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeClientVpnTargetNetworks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeClientVpnTargetNetworks_Call {
	return &EC2_DescribeClientVpnTargetNetworks_Call{Call: _e.mock.On("DescribeClientVpnTargetNetworks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeClientVpnTargetNetworks_Call) Run(run func(ctx context.Context, params *ec2.DescribeClientVpnTargetNetworksInput, optFns ...func(*ec2.Options))) *EC2_DescribeClientVpnTargetNetworks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeClientVpnTargetNetworksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeClientVpnTargetNetworks_Call) Return(_a0 *ec2.DescribeClientVpnTargetNetworksOutput, _a1 error) *EC2_DescribeClientVpnTargetNetworks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeClientVpnTargetNetworks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error)) *EC2_DescribeClientVpnTargetNetworks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCoipPools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCoipPools(ctx context.Context, params *ec2.DescribeCoipPoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCoipPools")
	}

	var r0 *ec2.DescribeCoipPoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) *ec2.DescribeCoipPoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCoipPoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeCoipPools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCoipPools'
type EC2_DescribeCoipPools_Call struct {
	*mock.Call
}

// DescribeCoipPools is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeCoipPoolsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeCoipPools(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeCoipPools_Call {
	return &EC2_DescribeCoipPools_Call{Call: _e.mock.On("DescribeCoipPools",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeCoipPools_Call) Run(run func(ctx context.Context, params *ec2.DescribeCoipPoolsInput, optFns ...func(*ec2.Options))) *EC2_DescribeCoipPools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeCoipPoolsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeCoipPools_Call) Return(_a0 *ec2.DescribeCoipPoolsOutput, _a1 error) *EC2_DescribeCoipPools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeCoipPools_Call) RunAndReturn(run func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error)) *EC2_DescribeCoipPools_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeConversionTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeConversionTasks(ctx context.Context, params *ec2.DescribeConversionTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeConversionTasks")
	}

	var r0 *ec2.DescribeConversionTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) *ec2.DescribeConversionTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeConversionTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeConversionTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeConversionTasks'
type EC2_DescribeConversionTasks_Call struct {
	*mock.Call
}

// DescribeConversionTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeConversionTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeConversionTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeConversionTasks_Call {
	return &EC2_DescribeConversionTasks_Call{Call: _e.mock.On("DescribeConversionTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeConversionTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeConversionTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeConversionTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeConversionTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeConversionTasks_Call) Return(_a0 *ec2.DescribeConversionTasksOutput, _a1 error) *EC2_DescribeConversionTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeConversionTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error)) *EC2_DescribeConversionTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCustomerGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCustomerGateways(ctx context.Context, params *ec2.DescribeCustomerGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCustomerGateways")
	}

	var r0 *ec2.DescribeCustomerGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeCustomerGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCustomerGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeCustomerGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCustomerGateways'
type EC2_DescribeCustomerGateways_Call struct {
	*mock.Call
}

// DescribeCustomerGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeCustomerGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeCustomerGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeCustomerGateways_Call {
	return &EC2_DescribeCustomerGateways_Call{Call: _e.mock.On("DescribeCustomerGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeCustomerGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeCustomerGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeCustomerGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeCustomerGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeCustomerGateways_Call) Return(_a0 *ec2.DescribeCustomerGatewaysOutput, _a1 error) *EC2_DescribeCustomerGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeCustomerGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error)) *EC2_DescribeCustomerGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeDhcpOptions(ctx context.Context, params *ec2.DescribeDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDhcpOptions")
	}

	var r0 *ec2.DescribeDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) *ec2.DescribeDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeDhcpOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeDhcpOptions'
type EC2_DescribeDhcpOptions_Call struct {
	*mock.Call
}

// DescribeDhcpOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeDhcpOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeDhcpOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeDhcpOptions_Call {
	return &EC2_DescribeDhcpOptions_Call{Call: _e.mock.On("DescribeDhcpOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeDhcpOptions_Call) Run(run func(ctx context.Context, params *ec2.DescribeDhcpOptionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeDhcpOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeDhcpOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeDhcpOptions_Call) Return(_a0 *ec2.DescribeDhcpOptionsOutput, _a1 error) *EC2_DescribeDhcpOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeDhcpOptions_Call) RunAndReturn(run func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error)) *EC2_DescribeDhcpOptions_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeEgressOnlyInternetGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeEgressOnlyInternetGateways(ctx context.Context, params *ec2.DescribeEgressOnlyInternetGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEgressOnlyInternetGateways")
	}

	var r0 *ec2.DescribeEgressOnlyInternetGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeEgressOnlyInternetGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeEgressOnlyInternetGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeEgressOnlyInternetGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeEgressOnlyInternetGateways'
type EC2_DescribeEgressOnlyInternetGateways_Call struct {
	*mock.Call
}

// DescribeEgressOnlyInternetGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeEgressOnlyInternetGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeEgressOnlyInternetGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeEgressOnlyInternetGateways_Call {
	return &EC2_DescribeEgressOnlyInternetGateways_Call{Call: _e.mock.On("DescribeEgressOnlyInternetGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeEgressOnlyInternetGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeEgressOnlyInternetGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeEgressOnlyInternetGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeEgressOnlyInternetGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeEgressOnlyInternetGateways_Call) Return(_a0 *ec2.DescribeEgressOnlyInternetGatewaysOutput, _a1 error) *EC2_DescribeEgressOnlyInternetGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeEgressOnlyInternetGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error)) *EC2_DescribeEgressOnlyInternetGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeElasticGpus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeElasticGpus(ctx context.Context, params *ec2.DescribeElasticGpusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeElasticGpus")
	}

	var r0 *ec2.DescribeElasticGpusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) *ec2.DescribeElasticGpusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeElasticGpusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeElasticGpus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeElasticGpus'
type EC2_DescribeElasticGpus_Call struct {
	*mock.Call
}

// DescribeElasticGpus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeElasticGpusInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeElasticGpus(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeElasticGpus_Call {
	return &EC2_DescribeElasticGpus_Call{Call: _e.mock.On("DescribeElasticGpus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeElasticGpus_Call) Run(run func(ctx context.Context, params *ec2.DescribeElasticGpusInput, optFns ...func(*ec2.Options))) *EC2_DescribeElasticGpus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeElasticGpusInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeElasticGpus_Call) Return(_a0 *ec2.DescribeElasticGpusOutput, _a1 error) *EC2_DescribeElasticGpus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeElasticGpus_Call) RunAndReturn(run func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error)) *EC2_DescribeElasticGpus_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeExportImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeExportImageTasks(ctx context.Context, params *ec2.DescribeExportImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExportImageTasks")
	}

	var r0 *ec2.DescribeExportImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeExportImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeExportImageTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeExportImageTasks'
type EC2_DescribeExportImageTasks_Call struct {
	*mock.Call
}

// DescribeExportImageTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeExportImageTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeExportImageTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeExportImageTasks_Call {
	return &EC2_DescribeExportImageTasks_Call{Call: _e.mock.On("DescribeExportImageTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeExportImageTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeExportImageTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeExportImageTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeExportImageTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeExportImageTasks_Call) Return(_a0 *ec2.DescribeExportImageTasksOutput, _a1 error) *EC2_DescribeExportImageTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeExportImageTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error)) *EC2_DescribeExportImageTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeExportTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeExportTasks(ctx context.Context, params *ec2.DescribeExportTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeExportTasks")
	}

	var r0 *ec2.DescribeExportTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) *ec2.DescribeExportTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeExportTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeExportTasks'
type EC2_DescribeExportTasks_Call struct {
	*mock.Call
}

// DescribeExportTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeExportTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeExportTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeExportTasks_Call {
	return &EC2_DescribeExportTasks_Call{Call: _e.mock.On("DescribeExportTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeExportTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeExportTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeExportTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeExportTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeExportTasks_Call) Return(_a0 *ec2.DescribeExportTasksOutput, _a1 error) *EC2_DescribeExportTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeExportTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error)) *EC2_DescribeExportTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFastLaunchImages provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFastLaunchImages(ctx context.Context, params *ec2.DescribeFastLaunchImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFastLaunchImages")
	}

	var r0 *ec2.DescribeFastLaunchImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) *ec2.DescribeFastLaunchImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastLaunchImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFastLaunchImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFastLaunchImages'
type EC2_DescribeFastLaunchImages_Call struct {
	*mock.Call
}

// DescribeFastLaunchImages is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFastLaunchImagesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFastLaunchImages(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFastLaunchImages_Call {
	return &EC2_DescribeFastLaunchImages_Call{Call: _e.mock.On("DescribeFastLaunchImages",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFastLaunchImages_Call) Run(run func(ctx context.Context, params *ec2.DescribeFastLaunchImagesInput, optFns ...func(*ec2.Options))) *EC2_DescribeFastLaunchImages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFastLaunchImagesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFastLaunchImages_Call) Return(_a0 *ec2.DescribeFastLaunchImagesOutput, _a1 error) *EC2_DescribeFastLaunchImages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFastLaunchImages_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error)) *EC2_DescribeFastLaunchImages_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFastSnapshotRestores(ctx context.Context, params *ec2.DescribeFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFastSnapshotRestores")
	}

	var r0 *ec2.DescribeFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.DescribeFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFastSnapshotRestores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFastSnapshotRestores'
type EC2_DescribeFastSnapshotRestores_Call struct {
	*mock.Call
}

// DescribeFastSnapshotRestores is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFastSnapshotRestoresInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFastSnapshotRestores(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFastSnapshotRestores_Call {
	return &EC2_DescribeFastSnapshotRestores_Call{Call: _e.mock.On("DescribeFastSnapshotRestores",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFastSnapshotRestores_Call) Run(run func(ctx context.Context, params *ec2.DescribeFastSnapshotRestoresInput, optFns ...func(*ec2.Options))) *EC2_DescribeFastSnapshotRestores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFastSnapshotRestoresInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFastSnapshotRestores_Call) Return(_a0 *ec2.DescribeFastSnapshotRestoresOutput, _a1 error) *EC2_DescribeFastSnapshotRestores_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFastSnapshotRestores_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error)) *EC2_DescribeFastSnapshotRestores_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFleetHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFleetHistory(ctx context.Context, params *ec2.DescribeFleetHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetHistory")
	}

	var r0 *ec2.DescribeFleetHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) *ec2.DescribeFleetHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFleetHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFleetHistory'
type EC2_DescribeFleetHistory_Call struct {
	*mock.Call
}

// DescribeFleetHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFleetHistoryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFleetHistory(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFleetHistory_Call {
	return &EC2_DescribeFleetHistory_Call{Call: _e.mock.On("DescribeFleetHistory",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFleetHistory_Call) Run(run func(ctx context.Context, params *ec2.DescribeFleetHistoryInput, optFns ...func(*ec2.Options))) *EC2_DescribeFleetHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFleetHistoryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFleetHistory_Call) Return(_a0 *ec2.DescribeFleetHistoryOutput, _a1 error) *EC2_DescribeFleetHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFleetHistory_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error)) *EC2_DescribeFleetHistory_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFleetInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFleetInstances(ctx context.Context, params *ec2.DescribeFleetInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleetInstances")
	}

	var r0 *ec2.DescribeFleetInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) *ec2.DescribeFleetInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFleetInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFleetInstances'
type EC2_DescribeFleetInstances_Call struct {
	*mock.Call
}

// DescribeFleetInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFleetInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFleetInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFleetInstances_Call {
	return &EC2_DescribeFleetInstances_Call{Call: _e.mock.On("DescribeFleetInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFleetInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeFleetInstancesInput, optFns ...func(*ec2.Options))) *EC2_DescribeFleetInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFleetInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFleetInstances_Call) Return(_a0 *ec2.DescribeFleetInstancesOutput, _a1 error) *EC2_DescribeFleetInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFleetInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error)) *EC2_DescribeFleetInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFleets(ctx context.Context, params *ec2.DescribeFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFleets")
	}

	var r0 *ec2.DescribeFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) *ec2.DescribeFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFleets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFleets'
type EC2_DescribeFleets_Call struct {
	*mock.Call
}

// DescribeFleets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFleetsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFleets(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFleets_Call {
	return &EC2_DescribeFleets_Call{Call: _e.mock.On("DescribeFleets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFleets_Call) Run(run func(ctx context.Context, params *ec2.DescribeFleetsInput, optFns ...func(*ec2.Options))) *EC2_DescribeFleets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFleetsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFleets_Call) Return(_a0 *ec2.DescribeFleetsOutput, _a1 error) *EC2_DescribeFleets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFleets_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error)) *EC2_DescribeFleets_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFlowLogs(ctx context.Context, params *ec2.DescribeFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFlowLogs")
	}

	var r0 *ec2.DescribeFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) *ec2.DescribeFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFlowLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFlowLogs'
type EC2_DescribeFlowLogs_Call struct {
	*mock.Call
}

// DescribeFlowLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFlowLogsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFlowLogs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFlowLogs_Call {
	return &EC2_DescribeFlowLogs_Call{Call: _e.mock.On("DescribeFlowLogs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFlowLogs_Call) Run(run func(ctx context.Context, params *ec2.DescribeFlowLogsInput, optFns ...func(*ec2.Options))) *EC2_DescribeFlowLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFlowLogsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFlowLogs_Call) Return(_a0 *ec2.DescribeFlowLogsOutput, _a1 error) *EC2_DescribeFlowLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFlowLogs_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error)) *EC2_DescribeFlowLogs_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFpgaImageAttribute(ctx context.Context, params *ec2.DescribeFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFpgaImageAttribute")
	}

	var r0 *ec2.DescribeFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.DescribeFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFpgaImageAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFpgaImageAttribute'
type EC2_DescribeFpgaImageAttribute_Call struct {
	*mock.Call
}

// DescribeFpgaImageAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFpgaImageAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFpgaImageAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFpgaImageAttribute_Call {
	return &EC2_DescribeFpgaImageAttribute_Call{Call: _e.mock.On("DescribeFpgaImageAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFpgaImageAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeFpgaImageAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeFpgaImageAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFpgaImageAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFpgaImageAttribute_Call) Return(_a0 *ec2.DescribeFpgaImageAttributeOutput, _a1 error) *EC2_DescribeFpgaImageAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFpgaImageAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error)) *EC2_DescribeFpgaImageAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeFpgaImages provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFpgaImages(ctx context.Context, params *ec2.DescribeFpgaImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFpgaImages")
	}

	var r0 *ec2.DescribeFpgaImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) *ec2.DescribeFpgaImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeFpgaImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeFpgaImages'
type EC2_DescribeFpgaImages_Call struct {
	*mock.Call
}

// DescribeFpgaImages is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeFpgaImagesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeFpgaImages(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeFpgaImages_Call {
	return &EC2_DescribeFpgaImages_Call{Call: _e.mock.On("DescribeFpgaImages",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeFpgaImages_Call) Run(run func(ctx context.Context, params *ec2.DescribeFpgaImagesInput, optFns ...func(*ec2.Options))) *EC2_DescribeFpgaImages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeFpgaImagesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeFpgaImages_Call) Return(_a0 *ec2.DescribeFpgaImagesOutput, _a1 error) *EC2_DescribeFpgaImages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeFpgaImages_Call) RunAndReturn(run func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error)) *EC2_DescribeFpgaImages_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeHostReservationOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeHostReservationOfferings(ctx context.Context, params *ec2.DescribeHostReservationOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHostReservationOfferings")
	}

	var r0 *ec2.DescribeHostReservationOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeHostReservationOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeHostReservationOfferings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeHostReservationOfferings'
type EC2_DescribeHostReservationOfferings_Call struct {
	*mock.Call
}

// DescribeHostReservationOfferings is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeHostReservationOfferingsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeHostReservationOfferings(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeHostReservationOfferings_Call {
	return &EC2_DescribeHostReservationOfferings_Call{Call: _e.mock.On("DescribeHostReservationOfferings",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeHostReservationOfferings_Call) Run(run func(ctx context.Context, params *ec2.DescribeHostReservationOfferingsInput, optFns ...func(*ec2.Options))) *EC2_DescribeHostReservationOfferings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeHostReservationOfferingsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeHostReservationOfferings_Call) Return(_a0 *ec2.DescribeHostReservationOfferingsOutput, _a1 error) *EC2_DescribeHostReservationOfferings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeHostReservationOfferings_Call) RunAndReturn(run func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error)) *EC2_DescribeHostReservationOfferings_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeHostReservations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeHostReservations(ctx context.Context, params *ec2.DescribeHostReservationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHostReservations")
	}

	var r0 *ec2.DescribeHostReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) *ec2.DescribeHostReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeHostReservations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeHostReservations'
type EC2_DescribeHostReservations_Call struct {
	*mock.Call
}

// DescribeHostReservations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeHostReservationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeHostReservations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeHostReservations_Call {
	return &EC2_DescribeHostReservations_Call{Call: _e.mock.On("DescribeHostReservations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeHostReservations_Call) Run(run func(ctx context.Context, params *ec2.DescribeHostReservationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeHostReservations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeHostReservationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeHostReservations_Call) Return(_a0 *ec2.DescribeHostReservationsOutput, _a1 error) *EC2_DescribeHostReservations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeHostReservations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error)) *EC2_DescribeHostReservations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeHosts(ctx context.Context, params *ec2.DescribeHostsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHosts")
	}

	var r0 *ec2.DescribeHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) *ec2.DescribeHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeHosts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeHosts'
type EC2_DescribeHosts_Call struct {
	*mock.Call
}

// DescribeHosts is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeHostsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeHosts(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeHosts_Call {
	return &EC2_DescribeHosts_Call{Call: _e.mock.On("DescribeHosts",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeHosts_Call) Run(run func(ctx context.Context, params *ec2.DescribeHostsInput, optFns ...func(*ec2.Options))) *EC2_DescribeHosts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeHostsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeHosts_Call) Return(_a0 *ec2.DescribeHostsOutput, _a1 error) *EC2_DescribeHosts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeHosts_Call) RunAndReturn(run func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error)) *EC2_DescribeHosts_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIamInstanceProfileAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIamInstanceProfileAssociations(ctx context.Context, params *ec2.DescribeIamInstanceProfileAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIamInstanceProfileAssociations")
	}

	var r0 *ec2.DescribeIamInstanceProfileAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeIamInstanceProfileAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIamInstanceProfileAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIamInstanceProfileAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIamInstanceProfileAssociations'
type EC2_DescribeIamInstanceProfileAssociations_Call struct {
	*mock.Call
}

// DescribeIamInstanceProfileAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIamInstanceProfileAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIamInstanceProfileAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIamInstanceProfileAssociations_Call {
	return &EC2_DescribeIamInstanceProfileAssociations_Call{Call: _e.mock.On("DescribeIamInstanceProfileAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIamInstanceProfileAssociations_Call) Run(run func(ctx context.Context, params *ec2.DescribeIamInstanceProfileAssociationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeIamInstanceProfileAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIamInstanceProfileAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIamInstanceProfileAssociations_Call) Return(_a0 *ec2.DescribeIamInstanceProfileAssociationsOutput, _a1 error) *EC2_DescribeIamInstanceProfileAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIamInstanceProfileAssociations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error)) *EC2_DescribeIamInstanceProfileAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIdFormat(ctx context.Context, params *ec2.DescribeIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIdFormat")
	}

	var r0 *ec2.DescribeIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIdFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIdFormat'
type EC2_DescribeIdFormat_Call struct {
	*mock.Call
}

// DescribeIdFormat is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIdFormatInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIdFormat(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIdFormat_Call {
	return &EC2_DescribeIdFormat_Call{Call: _e.mock.On("DescribeIdFormat",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIdFormat_Call) Run(run func(ctx context.Context, params *ec2.DescribeIdFormatInput, optFns ...func(*ec2.Options))) *EC2_DescribeIdFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIdFormatInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIdFormat_Call) Return(_a0 *ec2.DescribeIdFormatOutput, _a1 error) *EC2_DescribeIdFormat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIdFormat_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error)) *EC2_DescribeIdFormat_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIdentityIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIdentityIdFormat(ctx context.Context, params *ec2.DescribeIdentityIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIdentityIdFormat")
	}

	var r0 *ec2.DescribeIdentityIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeIdentityIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdentityIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIdentityIdFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIdentityIdFormat'
type EC2_DescribeIdentityIdFormat_Call struct {
	*mock.Call
}

// DescribeIdentityIdFormat is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIdentityIdFormatInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIdentityIdFormat(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIdentityIdFormat_Call {
	return &EC2_DescribeIdentityIdFormat_Call{Call: _e.mock.On("DescribeIdentityIdFormat",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIdentityIdFormat_Call) Run(run func(ctx context.Context, params *ec2.DescribeIdentityIdFormatInput, optFns ...func(*ec2.Options))) *EC2_DescribeIdentityIdFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIdentityIdFormatInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIdentityIdFormat_Call) Return(_a0 *ec2.DescribeIdentityIdFormatOutput, _a1 error) *EC2_DescribeIdentityIdFormat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIdentityIdFormat_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error)) *EC2_DescribeIdentityIdFormat_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImageAttribute(ctx context.Context, params *ec2.DescribeImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImageAttribute")
	}

	var r0 *ec2.DescribeImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) *ec2.DescribeImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeImageAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeImageAttribute'
type EC2_DescribeImageAttribute_Call struct {
	*mock.Call
}

// DescribeImageAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeImageAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeImageAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeImageAttribute_Call {
	return &EC2_DescribeImageAttribute_Call{Call: _e.mock.On("DescribeImageAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeImageAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeImageAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeImageAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeImageAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeImageAttribute_Call) Return(_a0 *ec2.DescribeImageAttributeOutput, _a1 error) *EC2_DescribeImageAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeImageAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error)) *EC2_DescribeImageAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeImages provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImages(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImages")
	}

	var r0 *ec2.DescribeImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) *ec2.DescribeImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeImages'
type EC2_DescribeImages_Call struct {
	*mock.Call
}

// DescribeImages is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeImagesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeImages(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeImages_Call {
	return &EC2_DescribeImages_Call{Call: _e.mock.On("DescribeImages",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeImages_Call) Run(run func(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options))) *EC2_DescribeImages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeImagesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeImages_Call) Return(_a0 *ec2.DescribeImagesOutput, _a1 error) *EC2_DescribeImages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeImages_Call) RunAndReturn(run func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error)) *EC2_DescribeImages_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeImportImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImportImageTasks(ctx context.Context, params *ec2.DescribeImportImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImportImageTasks")
	}

	var r0 *ec2.DescribeImportImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeImportImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeImportImageTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeImportImageTasks'
type EC2_DescribeImportImageTasks_Call struct {
	*mock.Call
}

// DescribeImportImageTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeImportImageTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeImportImageTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeImportImageTasks_Call {
	return &EC2_DescribeImportImageTasks_Call{Call: _e.mock.On("DescribeImportImageTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeImportImageTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeImportImageTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeImportImageTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeImportImageTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeImportImageTasks_Call) Return(_a0 *ec2.DescribeImportImageTasksOutput, _a1 error) *EC2_DescribeImportImageTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeImportImageTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error)) *EC2_DescribeImportImageTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeImportSnapshotTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImportSnapshotTasks(ctx context.Context, params *ec2.DescribeImportSnapshotTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeImportSnapshotTasks")
	}

	var r0 *ec2.DescribeImportSnapshotTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) *ec2.DescribeImportSnapshotTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportSnapshotTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeImportSnapshotTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeImportSnapshotTasks'
type EC2_DescribeImportSnapshotTasks_Call struct {
	*mock.Call
}

// DescribeImportSnapshotTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeImportSnapshotTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeImportSnapshotTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeImportSnapshotTasks_Call {
	return &EC2_DescribeImportSnapshotTasks_Call{Call: _e.mock.On("DescribeImportSnapshotTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeImportSnapshotTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeImportSnapshotTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeImportSnapshotTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeImportSnapshotTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeImportSnapshotTasks_Call) Return(_a0 *ec2.DescribeImportSnapshotTasksOutput, _a1 error) *EC2_DescribeImportSnapshotTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeImportSnapshotTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error)) *EC2_DescribeImportSnapshotTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceAttribute(ctx context.Context, params *ec2.DescribeInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceAttribute")
	}

	var r0 *ec2.DescribeInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) *ec2.DescribeInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceAttribute'
type EC2_DescribeInstanceAttribute_Call struct {
	*mock.Call
}

// DescribeInstanceAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceAttribute_Call {
	return &EC2_DescribeInstanceAttribute_Call{Call: _e.mock.On("DescribeInstanceAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceAttribute_Call) Return(_a0 *ec2.DescribeInstanceAttributeOutput, _a1 error) *EC2_DescribeInstanceAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error)) *EC2_DescribeInstanceAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceCreditSpecifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceCreditSpecifications(ctx context.Context, params *ec2.DescribeInstanceCreditSpecificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceCreditSpecifications")
	}

	var r0 *ec2.DescribeInstanceCreditSpecificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceCreditSpecificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceCreditSpecificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceCreditSpecifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceCreditSpecifications'
type EC2_DescribeInstanceCreditSpecifications_Call struct {
	*mock.Call
}

// DescribeInstanceCreditSpecifications is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceCreditSpecificationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceCreditSpecifications(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceCreditSpecifications_Call {
	return &EC2_DescribeInstanceCreditSpecifications_Call{Call: _e.mock.On("DescribeInstanceCreditSpecifications",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceCreditSpecifications_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceCreditSpecificationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceCreditSpecifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceCreditSpecificationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceCreditSpecifications_Call) Return(_a0 *ec2.DescribeInstanceCreditSpecificationsOutput, _a1 error) *EC2_DescribeInstanceCreditSpecifications_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceCreditSpecifications_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error)) *EC2_DescribeInstanceCreditSpecifications_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceEventNotificationAttributes(ctx context.Context, params *ec2.DescribeInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceEventNotificationAttributes")
	}

	var r0 *ec2.DescribeInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceEventNotificationAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceEventNotificationAttributes'
type EC2_DescribeInstanceEventNotificationAttributes_Call struct {
	*mock.Call
}

// DescribeInstanceEventNotificationAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceEventNotificationAttributesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceEventNotificationAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceEventNotificationAttributes_Call {
	return &EC2_DescribeInstanceEventNotificationAttributes_Call{Call: _e.mock.On("DescribeInstanceEventNotificationAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceEventNotificationAttributes_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceEventNotificationAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceEventNotificationAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceEventNotificationAttributes_Call) Return(_a0 *ec2.DescribeInstanceEventNotificationAttributesOutput, _a1 error) *EC2_DescribeInstanceEventNotificationAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceEventNotificationAttributes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error)) *EC2_DescribeInstanceEventNotificationAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceEventWindows provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceEventWindows(ctx context.Context, params *ec2.DescribeInstanceEventWindowsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceEventWindows")
	}

	var r0 *ec2.DescribeInstanceEventWindowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceEventWindowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventWindowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceEventWindows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceEventWindows'
type EC2_DescribeInstanceEventWindows_Call struct {
	*mock.Call
}

// DescribeInstanceEventWindows is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceEventWindowsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceEventWindows(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceEventWindows_Call {
	return &EC2_DescribeInstanceEventWindows_Call{Call: _e.mock.On("DescribeInstanceEventWindows",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceEventWindows_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceEventWindowsInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceEventWindows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceEventWindowsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceEventWindows_Call) Return(_a0 *ec2.DescribeInstanceEventWindowsOutput, _a1 error) *EC2_DescribeInstanceEventWindows_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceEventWindows_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error)) *EC2_DescribeInstanceEventWindows_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceStatus(ctx context.Context, params *ec2.DescribeInstanceStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceStatus")
	}

	var r0 *ec2.DescribeInstanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) *ec2.DescribeInstanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceStatus'
type EC2_DescribeInstanceStatus_Call struct {
	*mock.Call
}

// DescribeInstanceStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceStatusInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceStatus(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceStatus_Call {
	return &EC2_DescribeInstanceStatus_Call{Call: _e.mock.On("DescribeInstanceStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceStatus_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceStatusInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceStatusInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceStatus_Call) Return(_a0 *ec2.DescribeInstanceStatusOutput, _a1 error) *EC2_DescribeInstanceStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceStatus_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error)) *EC2_DescribeInstanceStatus_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceTypeOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceTypeOfferings(ctx context.Context, params *ec2.DescribeInstanceTypeOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTypeOfferings")
	}

	var r0 *ec2.DescribeInstanceTypeOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypeOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypeOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceTypeOfferings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceTypeOfferings'
type EC2_DescribeInstanceTypeOfferings_Call struct {
	*mock.Call
}

// DescribeInstanceTypeOfferings is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceTypeOfferingsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceTypeOfferings(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceTypeOfferings_Call {
	return &EC2_DescribeInstanceTypeOfferings_Call{Call: _e.mock.On("DescribeInstanceTypeOfferings",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceTypeOfferings_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceTypeOfferingsInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceTypeOfferings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceTypeOfferingsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceTypeOfferings_Call) Return(_a0 *ec2.DescribeInstanceTypeOfferingsOutput, _a1 error) *EC2_DescribeInstanceTypeOfferings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceTypeOfferings_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error)) *EC2_DescribeInstanceTypeOfferings_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceTypes(ctx context.Context, params *ec2.DescribeInstanceTypesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTypes")
	}

	var r0 *ec2.DescribeInstanceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstanceTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceTypes'
type EC2_DescribeInstanceTypes_Call struct {
	*mock.Call
}

// DescribeInstanceTypes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceTypesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstanceTypes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstanceTypes_Call {
	return &EC2_DescribeInstanceTypes_Call{Call: _e.mock.On("DescribeInstanceTypes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstanceTypes_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceTypesInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstanceTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceTypesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstanceTypes_Call) Return(_a0 *ec2.DescribeInstanceTypesOutput, _a1 error) *EC2_DescribeInstanceTypes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstanceTypes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error)) *EC2_DescribeInstanceTypes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstances(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstances")
	}

	var r0 *ec2.DescribeInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) *ec2.DescribeInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstances'
type EC2_DescribeInstances_Call struct {
	*mock.Call
}

// DescribeInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInstances_Call {
	return &EC2_DescribeInstances_Call{Call: _e.mock.On("DescribeInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options))) *EC2_DescribeInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInstances_Call) Return(_a0 *ec2.DescribeInstancesOutput, _a1 error) *EC2_DescribeInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error)) *EC2_DescribeInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInternetGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInternetGateways(ctx context.Context, params *ec2.DescribeInternetGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInternetGateways")
	}

	var r0 *ec2.DescribeInternetGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeInternetGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInternetGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeInternetGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInternetGateways'
type EC2_DescribeInternetGateways_Call struct {
	*mock.Call
}

// DescribeInternetGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInternetGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeInternetGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeInternetGateways_Call {
	return &EC2_DescribeInternetGateways_Call{Call: _e.mock.On("DescribeInternetGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeInternetGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeInternetGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeInternetGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInternetGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeInternetGateways_Call) Return(_a0 *ec2.DescribeInternetGatewaysOutput, _a1 error) *EC2_DescribeInternetGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeInternetGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error)) *EC2_DescribeInternetGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIpamPools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpamPools(ctx context.Context, params *ec2.DescribeIpamPoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamPools")
	}

	var r0 *ec2.DescribeIpamPoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) *ec2.DescribeIpamPoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamPoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIpamPools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIpamPools'
type EC2_DescribeIpamPools_Call struct {
	*mock.Call
}

// DescribeIpamPools is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIpamPoolsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIpamPools(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIpamPools_Call {
	return &EC2_DescribeIpamPools_Call{Call: _e.mock.On("DescribeIpamPools",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIpamPools_Call) Run(run func(ctx context.Context, params *ec2.DescribeIpamPoolsInput, optFns ...func(*ec2.Options))) *EC2_DescribeIpamPools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIpamPoolsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIpamPools_Call) Return(_a0 *ec2.DescribeIpamPoolsOutput, _a1 error) *EC2_DescribeIpamPools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIpamPools_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error)) *EC2_DescribeIpamPools_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIpamScopes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpamScopes(ctx context.Context, params *ec2.DescribeIpamScopesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpamScopes")
	}

	var r0 *ec2.DescribeIpamScopesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) *ec2.DescribeIpamScopesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamScopesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIpamScopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIpamScopes'
type EC2_DescribeIpamScopes_Call struct {
	*mock.Call
}

// DescribeIpamScopes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIpamScopesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIpamScopes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIpamScopes_Call {
	return &EC2_DescribeIpamScopes_Call{Call: _e.mock.On("DescribeIpamScopes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIpamScopes_Call) Run(run func(ctx context.Context, params *ec2.DescribeIpamScopesInput, optFns ...func(*ec2.Options))) *EC2_DescribeIpamScopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIpamScopesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIpamScopes_Call) Return(_a0 *ec2.DescribeIpamScopesOutput, _a1 error) *EC2_DescribeIpamScopes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIpamScopes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error)) *EC2_DescribeIpamScopes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIpams provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpams(ctx context.Context, params *ec2.DescribeIpamsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpams")
	}

	var r0 *ec2.DescribeIpamsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) *ec2.DescribeIpamsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIpams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIpams'
type EC2_DescribeIpams_Call struct {
	*mock.Call
}

// DescribeIpams is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIpamsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIpams(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIpams_Call {
	return &EC2_DescribeIpams_Call{Call: _e.mock.On("DescribeIpams",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIpams_Call) Run(run func(ctx context.Context, params *ec2.DescribeIpamsInput, optFns ...func(*ec2.Options))) *EC2_DescribeIpams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIpamsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIpams_Call) Return(_a0 *ec2.DescribeIpamsOutput, _a1 error) *EC2_DescribeIpams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIpams_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error)) *EC2_DescribeIpams_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIpv6Pools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpv6Pools(ctx context.Context, params *ec2.DescribeIpv6PoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIpv6Pools")
	}

	var r0 *ec2.DescribeIpv6PoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) *ec2.DescribeIpv6PoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpv6PoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeIpv6Pools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIpv6Pools'
type EC2_DescribeIpv6Pools_Call struct {
	*mock.Call
}

// DescribeIpv6Pools is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeIpv6PoolsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeIpv6Pools(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeIpv6Pools_Call {
	return &EC2_DescribeIpv6Pools_Call{Call: _e.mock.On("DescribeIpv6Pools",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeIpv6Pools_Call) Run(run func(ctx context.Context, params *ec2.DescribeIpv6PoolsInput, optFns ...func(*ec2.Options))) *EC2_DescribeIpv6Pools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeIpv6PoolsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeIpv6Pools_Call) Return(_a0 *ec2.DescribeIpv6PoolsOutput, _a1 error) *EC2_DescribeIpv6Pools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeIpv6Pools_Call) RunAndReturn(run func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error)) *EC2_DescribeIpv6Pools_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeKeyPairs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeKeyPairs(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeKeyPairs")
	}

	var r0 *ec2.DescribeKeyPairsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) *ec2.DescribeKeyPairsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeKeyPairsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeKeyPairs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeKeyPairs'
type EC2_DescribeKeyPairs_Call struct {
	*mock.Call
}

// DescribeKeyPairs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeKeyPairsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeKeyPairs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeKeyPairs_Call {
	return &EC2_DescribeKeyPairs_Call{Call: _e.mock.On("DescribeKeyPairs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeKeyPairs_Call) Run(run func(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options))) *EC2_DescribeKeyPairs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeKeyPairsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeKeyPairs_Call) Return(_a0 *ec2.DescribeKeyPairsOutput, _a1 error) *EC2_DescribeKeyPairs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeKeyPairs_Call) RunAndReturn(run func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error)) *EC2_DescribeKeyPairs_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLaunchTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLaunchTemplateVersions(ctx context.Context, params *ec2.DescribeLaunchTemplateVersionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLaunchTemplateVersions")
	}

	var r0 *ec2.DescribeLaunchTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) *ec2.DescribeLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLaunchTemplateVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLaunchTemplateVersions'
type EC2_DescribeLaunchTemplateVersions_Call struct {
	*mock.Call
}

// DescribeLaunchTemplateVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLaunchTemplateVersionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLaunchTemplateVersions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLaunchTemplateVersions_Call {
	return &EC2_DescribeLaunchTemplateVersions_Call{Call: _e.mock.On("DescribeLaunchTemplateVersions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLaunchTemplateVersions_Call) Run(run func(ctx context.Context, params *ec2.DescribeLaunchTemplateVersionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeLaunchTemplateVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLaunchTemplateVersionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLaunchTemplateVersions_Call) Return(_a0 *ec2.DescribeLaunchTemplateVersionsOutput, _a1 error) *EC2_DescribeLaunchTemplateVersions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLaunchTemplateVersions_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error)) *EC2_DescribeLaunchTemplateVersions_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLaunchTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLaunchTemplates(ctx context.Context, params *ec2.DescribeLaunchTemplatesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLaunchTemplates")
	}

	var r0 *ec2.DescribeLaunchTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) *ec2.DescribeLaunchTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLaunchTemplates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLaunchTemplates'
type EC2_DescribeLaunchTemplates_Call struct {
	*mock.Call
}

// DescribeLaunchTemplates is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLaunchTemplatesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLaunchTemplates(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLaunchTemplates_Call {
	return &EC2_DescribeLaunchTemplates_Call{Call: _e.mock.On("DescribeLaunchTemplates",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLaunchTemplates_Call) Run(run func(ctx context.Context, params *ec2.DescribeLaunchTemplatesInput, optFns ...func(*ec2.Options))) *EC2_DescribeLaunchTemplates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLaunchTemplatesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLaunchTemplates_Call) Return(_a0 *ec2.DescribeLaunchTemplatesOutput, _a1 error) *EC2_DescribeLaunchTemplates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLaunchTemplates_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error)) *EC2_DescribeLaunchTemplates_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations")
	}

	var r0 *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations'
type EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call struct {
	*mock.Call
}

// DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call {
	return &EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call{Call: _e.mock.On("DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call) Run(run func(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call) Return(_a0 *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, _a1 error) *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error)) *EC2_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLocalGatewayRouteTableVpcAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayRouteTableVpcAssociations(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayRouteTableVpcAssociations")
	}

	var r0 *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLocalGatewayRouteTableVpcAssociations'
type EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call struct {
	*mock.Call
}

// DescribeLocalGatewayRouteTableVpcAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLocalGatewayRouteTableVpcAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call {
	return &EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call{Call: _e.mock.On("DescribeLocalGatewayRouteTableVpcAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call) Run(run func(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call) Return(_a0 *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, _a1 error) *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error)) *EC2_DescribeLocalGatewayRouteTableVpcAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLocalGatewayRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayRouteTables(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayRouteTables")
	}

	var r0 *ec2.DescribeLocalGatewayRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLocalGatewayRouteTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLocalGatewayRouteTables'
type EC2_DescribeLocalGatewayRouteTables_Call struct {
	*mock.Call
}

// DescribeLocalGatewayRouteTables is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLocalGatewayRouteTablesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLocalGatewayRouteTables(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLocalGatewayRouteTables_Call {
	return &EC2_DescribeLocalGatewayRouteTables_Call{Call: _e.mock.On("DescribeLocalGatewayRouteTables",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLocalGatewayRouteTables_Call) Run(run func(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTablesInput, optFns ...func(*ec2.Options))) *EC2_DescribeLocalGatewayRouteTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLocalGatewayRouteTablesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLocalGatewayRouteTables_Call) Return(_a0 *ec2.DescribeLocalGatewayRouteTablesOutput, _a1 error) *EC2_DescribeLocalGatewayRouteTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLocalGatewayRouteTables_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error)) *EC2_DescribeLocalGatewayRouteTables_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLocalGatewayVirtualInterfaceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayVirtualInterfaceGroups(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayVirtualInterfaceGroups")
	}

	var r0 *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLocalGatewayVirtualInterfaceGroups'
type EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call struct {
	*mock.Call
}

// DescribeLocalGatewayVirtualInterfaceGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLocalGatewayVirtualInterfaceGroups(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call {
	return &EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call{Call: _e.mock.On("DescribeLocalGatewayVirtualInterfaceGroups",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call) Run(run func(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, optFns ...func(*ec2.Options))) *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call) Return(_a0 *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, _a1 error) *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error)) *EC2_DescribeLocalGatewayVirtualInterfaceGroups_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLocalGatewayVirtualInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayVirtualInterfaces(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGatewayVirtualInterfaces")
	}

	var r0 *ec2.DescribeLocalGatewayVirtualInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayVirtualInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLocalGatewayVirtualInterfaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLocalGatewayVirtualInterfaces'
type EC2_DescribeLocalGatewayVirtualInterfaces_Call struct {
	*mock.Call
}

// DescribeLocalGatewayVirtualInterfaces is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLocalGatewayVirtualInterfacesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLocalGatewayVirtualInterfaces(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLocalGatewayVirtualInterfaces_Call {
	return &EC2_DescribeLocalGatewayVirtualInterfaces_Call{Call: _e.mock.On("DescribeLocalGatewayVirtualInterfaces",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLocalGatewayVirtualInterfaces_Call) Run(run func(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfacesInput, optFns ...func(*ec2.Options))) *EC2_DescribeLocalGatewayVirtualInterfaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLocalGatewayVirtualInterfacesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLocalGatewayVirtualInterfaces_Call) Return(_a0 *ec2.DescribeLocalGatewayVirtualInterfacesOutput, _a1 error) *EC2_DescribeLocalGatewayVirtualInterfaces_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLocalGatewayVirtualInterfaces_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error)) *EC2_DescribeLocalGatewayVirtualInterfaces_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLocalGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGateways(ctx context.Context, params *ec2.DescribeLocalGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLocalGateways")
	}

	var r0 *ec2.DescribeLocalGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeLocalGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLocalGateways'
type EC2_DescribeLocalGateways_Call struct {
	*mock.Call
}

// DescribeLocalGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeLocalGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeLocalGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeLocalGateways_Call {
	return &EC2_DescribeLocalGateways_Call{Call: _e.mock.On("DescribeLocalGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeLocalGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeLocalGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeLocalGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeLocalGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeLocalGateways_Call) Return(_a0 *ec2.DescribeLocalGatewaysOutput, _a1 error) *EC2_DescribeLocalGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeLocalGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error)) *EC2_DescribeLocalGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeManagedPrefixLists provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeManagedPrefixLists(ctx context.Context, params *ec2.DescribeManagedPrefixListsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeManagedPrefixLists")
	}

	var r0 *ec2.DescribeManagedPrefixListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) *ec2.DescribeManagedPrefixListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeManagedPrefixListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeManagedPrefixLists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeManagedPrefixLists'
type EC2_DescribeManagedPrefixLists_Call struct {
	*mock.Call
}

// DescribeManagedPrefixLists is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeManagedPrefixListsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeManagedPrefixLists(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeManagedPrefixLists_Call {
	return &EC2_DescribeManagedPrefixLists_Call{Call: _e.mock.On("DescribeManagedPrefixLists",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeManagedPrefixLists_Call) Run(run func(ctx context.Context, params *ec2.DescribeManagedPrefixListsInput, optFns ...func(*ec2.Options))) *EC2_DescribeManagedPrefixLists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeManagedPrefixListsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeManagedPrefixLists_Call) Return(_a0 *ec2.DescribeManagedPrefixListsOutput, _a1 error) *EC2_DescribeManagedPrefixLists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeManagedPrefixLists_Call) RunAndReturn(run func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error)) *EC2_DescribeManagedPrefixLists_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeMovingAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeMovingAddresses(ctx context.Context, params *ec2.DescribeMovingAddressesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMovingAddresses")
	}

	var r0 *ec2.DescribeMovingAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) *ec2.DescribeMovingAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeMovingAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeMovingAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeMovingAddresses'
type EC2_DescribeMovingAddresses_Call struct {
	*mock.Call
}

// DescribeMovingAddresses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeMovingAddressesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeMovingAddresses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeMovingAddresses_Call {
	return &EC2_DescribeMovingAddresses_Call{Call: _e.mock.On("DescribeMovingAddresses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeMovingAddresses_Call) Run(run func(ctx context.Context, params *ec2.DescribeMovingAddressesInput, optFns ...func(*ec2.Options))) *EC2_DescribeMovingAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeMovingAddressesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeMovingAddresses_Call) Return(_a0 *ec2.DescribeMovingAddressesOutput, _a1 error) *EC2_DescribeMovingAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeMovingAddresses_Call) RunAndReturn(run func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error)) *EC2_DescribeMovingAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNatGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNatGateways(ctx context.Context, params *ec2.DescribeNatGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNatGateways")
	}

	var r0 *ec2.DescribeNatGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeNatGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNatGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNatGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNatGateways'
type EC2_DescribeNatGateways_Call struct {
	*mock.Call
}

// DescribeNatGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNatGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNatGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNatGateways_Call {
	return &EC2_DescribeNatGateways_Call{Call: _e.mock.On("DescribeNatGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNatGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeNatGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeNatGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNatGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNatGateways_Call) Return(_a0 *ec2.DescribeNatGatewaysOutput, _a1 error) *EC2_DescribeNatGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNatGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error)) *EC2_DescribeNatGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkAcls provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkAcls(ctx context.Context, params *ec2.DescribeNetworkAclsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkAcls")
	}

	var r0 *ec2.DescribeNetworkAclsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkAclsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkAclsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkAcls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkAcls'
type EC2_DescribeNetworkAcls_Call struct {
	*mock.Call
}

// DescribeNetworkAcls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkAclsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkAcls(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkAcls_Call {
	return &EC2_DescribeNetworkAcls_Call{Call: _e.mock.On("DescribeNetworkAcls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkAcls_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkAclsInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkAcls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkAclsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkAcls_Call) Return(_a0 *ec2.DescribeNetworkAclsOutput, _a1 error) *EC2_DescribeNetworkAcls_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkAcls_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error)) *EC2_DescribeNetworkAcls_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInsightsAccessScopeAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsAccessScopeAnalyses(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsAccessScopeAnalyses")
	}

	var r0 *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInsightsAccessScopeAnalyses'
type EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call struct {
	*mock.Call
}

// DescribeNetworkInsightsAccessScopeAnalyses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInsightsAccessScopeAnalyses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call {
	return &EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call{Call: _e.mock.On("DescribeNetworkInsightsAccessScopeAnalyses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInsightsAccessScopeAnalysesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call) Return(_a0 *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, _a1 error) *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error)) *EC2_DescribeNetworkInsightsAccessScopeAnalyses_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInsightsAccessScopes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsAccessScopes(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsAccessScopes")
	}

	var r0 *ec2.DescribeNetworkInsightsAccessScopesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAccessScopesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAccessScopesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInsightsAccessScopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInsightsAccessScopes'
type EC2_DescribeNetworkInsightsAccessScopes_Call struct {
	*mock.Call
}

// DescribeNetworkInsightsAccessScopes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInsightsAccessScopesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInsightsAccessScopes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInsightsAccessScopes_Call {
	return &EC2_DescribeNetworkInsightsAccessScopes_Call{Call: _e.mock.On("DescribeNetworkInsightsAccessScopes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInsightsAccessScopes_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopesInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInsightsAccessScopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInsightsAccessScopesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInsightsAccessScopes_Call) Return(_a0 *ec2.DescribeNetworkInsightsAccessScopesOutput, _a1 error) *EC2_DescribeNetworkInsightsAccessScopes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInsightsAccessScopes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error)) *EC2_DescribeNetworkInsightsAccessScopes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInsightsAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsAnalyses(ctx context.Context, params *ec2.DescribeNetworkInsightsAnalysesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsAnalyses")
	}

	var r0 *ec2.DescribeNetworkInsightsAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInsightsAnalyses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInsightsAnalyses'
type EC2_DescribeNetworkInsightsAnalyses_Call struct {
	*mock.Call
}

// DescribeNetworkInsightsAnalyses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInsightsAnalysesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInsightsAnalyses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInsightsAnalyses_Call {
	return &EC2_DescribeNetworkInsightsAnalyses_Call{Call: _e.mock.On("DescribeNetworkInsightsAnalyses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInsightsAnalyses_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInsightsAnalysesInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInsightsAnalyses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInsightsAnalysesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInsightsAnalyses_Call) Return(_a0 *ec2.DescribeNetworkInsightsAnalysesOutput, _a1 error) *EC2_DescribeNetworkInsightsAnalyses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInsightsAnalyses_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error)) *EC2_DescribeNetworkInsightsAnalyses_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInsightsPaths provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsPaths(ctx context.Context, params *ec2.DescribeNetworkInsightsPathsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInsightsPaths")
	}

	var r0 *ec2.DescribeNetworkInsightsPathsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsPathsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsPathsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInsightsPaths_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInsightsPaths'
type EC2_DescribeNetworkInsightsPaths_Call struct {
	*mock.Call
}

// DescribeNetworkInsightsPaths is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInsightsPathsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInsightsPaths(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInsightsPaths_Call {
	return &EC2_DescribeNetworkInsightsPaths_Call{Call: _e.mock.On("DescribeNetworkInsightsPaths",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInsightsPaths_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInsightsPathsInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInsightsPaths_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInsightsPathsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInsightsPaths_Call) Return(_a0 *ec2.DescribeNetworkInsightsPathsOutput, _a1 error) *EC2_DescribeNetworkInsightsPaths_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInsightsPaths_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error)) *EC2_DescribeNetworkInsightsPaths_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInterfaceAttribute(ctx context.Context, params *ec2.DescribeNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInterfaceAttribute")
	}

	var r0 *ec2.DescribeNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInterfaceAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInterfaceAttribute'
type EC2_DescribeNetworkInterfaceAttribute_Call struct {
	*mock.Call
}

// DescribeNetworkInterfaceAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInterfaceAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInterfaceAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInterfaceAttribute_Call {
	return &EC2_DescribeNetworkInterfaceAttribute_Call{Call: _e.mock.On("DescribeNetworkInterfaceAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInterfaceAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInterfaceAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInterfaceAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInterfaceAttribute_Call) Return(_a0 *ec2.DescribeNetworkInterfaceAttributeOutput, _a1 error) *EC2_DescribeNetworkInterfaceAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInterfaceAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error)) *EC2_DescribeNetworkInterfaceAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInterfacePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInterfacePermissions(ctx context.Context, params *ec2.DescribeNetworkInterfacePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInterfacePermissions")
	}

	var r0 *ec2.DescribeNetworkInterfacePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfacePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInterfacePermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInterfacePermissions'
type EC2_DescribeNetworkInterfacePermissions_Call struct {
	*mock.Call
}

// DescribeNetworkInterfacePermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInterfacePermissionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInterfacePermissions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInterfacePermissions_Call {
	return &EC2_DescribeNetworkInterfacePermissions_Call{Call: _e.mock.On("DescribeNetworkInterfacePermissions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInterfacePermissions_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInterfacePermissionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInterfacePermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInterfacePermissionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInterfacePermissions_Call) Return(_a0 *ec2.DescribeNetworkInterfacePermissionsOutput, _a1 error) *EC2_DescribeNetworkInterfacePermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInterfacePermissions_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error)) *EC2_DescribeNetworkInterfacePermissions_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeNetworkInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInterfaces(ctx context.Context, params *ec2.DescribeNetworkInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNetworkInterfaces")
	}

	var r0 *ec2.DescribeNetworkInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeNetworkInterfaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeNetworkInterfaces'
type EC2_DescribeNetworkInterfaces_Call struct {
	*mock.Call
}

// DescribeNetworkInterfaces is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeNetworkInterfacesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeNetworkInterfaces(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeNetworkInterfaces_Call {
	return &EC2_DescribeNetworkInterfaces_Call{Call: _e.mock.On("DescribeNetworkInterfaces",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeNetworkInterfaces_Call) Run(run func(ctx context.Context, params *ec2.DescribeNetworkInterfacesInput, optFns ...func(*ec2.Options))) *EC2_DescribeNetworkInterfaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeNetworkInterfacesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeNetworkInterfaces_Call) Return(_a0 *ec2.DescribeNetworkInterfacesOutput, _a1 error) *EC2_DescribeNetworkInterfaces_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeNetworkInterfaces_Call) RunAndReturn(run func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error)) *EC2_DescribeNetworkInterfaces_Call {
	_c.Call.Return(run)
	return _c
}

// DescribePlacementGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePlacementGroups(ctx context.Context, params *ec2.DescribePlacementGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePlacementGroups")
	}

	var r0 *ec2.DescribePlacementGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) *ec2.DescribePlacementGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePlacementGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribePlacementGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribePlacementGroups'
type EC2_DescribePlacementGroups_Call struct {
	*mock.Call
}

// DescribePlacementGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribePlacementGroupsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribePlacementGroups(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribePlacementGroups_Call {
	return &EC2_DescribePlacementGroups_Call{Call: _e.mock.On("DescribePlacementGroups",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribePlacementGroups_Call) Run(run func(ctx context.Context, params *ec2.DescribePlacementGroupsInput, optFns ...func(*ec2.Options))) *EC2_DescribePlacementGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribePlacementGroupsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribePlacementGroups_Call) Return(_a0 *ec2.DescribePlacementGroupsOutput, _a1 error) *EC2_DescribePlacementGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribePlacementGroups_Call) RunAndReturn(run func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error)) *EC2_DescribePlacementGroups_Call {
	_c.Call.Return(run)
	return _c
}

// DescribePrefixLists provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePrefixLists(ctx context.Context, params *ec2.DescribePrefixListsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePrefixLists")
	}

	var r0 *ec2.DescribePrefixListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) *ec2.DescribePrefixListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrefixListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribePrefixLists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribePrefixLists'
type EC2_DescribePrefixLists_Call struct {
	*mock.Call
}

// DescribePrefixLists is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribePrefixListsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribePrefixLists(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribePrefixLists_Call {
	return &EC2_DescribePrefixLists_Call{Call: _e.mock.On("DescribePrefixLists",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribePrefixLists_Call) Run(run func(ctx context.Context, params *ec2.DescribePrefixListsInput, optFns ...func(*ec2.Options))) *EC2_DescribePrefixLists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribePrefixListsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribePrefixLists_Call) Return(_a0 *ec2.DescribePrefixListsOutput, _a1 error) *EC2_DescribePrefixLists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribePrefixLists_Call) RunAndReturn(run func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error)) *EC2_DescribePrefixLists_Call {
	_c.Call.Return(run)
	return _c
}

// DescribePrincipalIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePrincipalIdFormat(ctx context.Context, params *ec2.DescribePrincipalIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePrincipalIdFormat")
	}

	var r0 *ec2.DescribePrincipalIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) *ec2.DescribePrincipalIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrincipalIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribePrincipalIdFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribePrincipalIdFormat'
type EC2_DescribePrincipalIdFormat_Call struct {
	*mock.Call
}

// DescribePrincipalIdFormat is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribePrincipalIdFormatInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribePrincipalIdFormat(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribePrincipalIdFormat_Call {
	return &EC2_DescribePrincipalIdFormat_Call{Call: _e.mock.On("DescribePrincipalIdFormat",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribePrincipalIdFormat_Call) Run(run func(ctx context.Context, params *ec2.DescribePrincipalIdFormatInput, optFns ...func(*ec2.Options))) *EC2_DescribePrincipalIdFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribePrincipalIdFormatInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribePrincipalIdFormat_Call) Return(_a0 *ec2.DescribePrincipalIdFormatOutput, _a1 error) *EC2_DescribePrincipalIdFormat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribePrincipalIdFormat_Call) RunAndReturn(run func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error)) *EC2_DescribePrincipalIdFormat_Call {
	_c.Call.Return(run)
	return _c
}

// DescribePublicIpv4Pools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePublicIpv4Pools(ctx context.Context, params *ec2.DescribePublicIpv4PoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePublicIpv4Pools")
	}

	var r0 *ec2.DescribePublicIpv4PoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) *ec2.DescribePublicIpv4PoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePublicIpv4PoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribePublicIpv4Pools_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribePublicIpv4Pools'
type EC2_DescribePublicIpv4Pools_Call struct {
	*mock.Call
}

// DescribePublicIpv4Pools is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribePublicIpv4PoolsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribePublicIpv4Pools(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribePublicIpv4Pools_Call {
	return &EC2_DescribePublicIpv4Pools_Call{Call: _e.mock.On("DescribePublicIpv4Pools",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribePublicIpv4Pools_Call) Run(run func(ctx context.Context, params *ec2.DescribePublicIpv4PoolsInput, optFns ...func(*ec2.Options))) *EC2_DescribePublicIpv4Pools_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribePublicIpv4PoolsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribePublicIpv4Pools_Call) Return(_a0 *ec2.DescribePublicIpv4PoolsOutput, _a1 error) *EC2_DescribePublicIpv4Pools_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribePublicIpv4Pools_Call) RunAndReturn(run func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error)) *EC2_DescribePublicIpv4Pools_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeRegions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeRegions(ctx context.Context, params *ec2.DescribeRegionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRegions")
	}

	var r0 *ec2.DescribeRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) *ec2.DescribeRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeRegions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeRegions'
type EC2_DescribeRegions_Call struct {
	*mock.Call
}

// DescribeRegions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeRegionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeRegions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeRegions_Call {
	return &EC2_DescribeRegions_Call{Call: _e.mock.On("DescribeRegions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeRegions_Call) Run(run func(ctx context.Context, params *ec2.DescribeRegionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeRegions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeRegionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeRegions_Call) Return(_a0 *ec2.DescribeRegionsOutput, _a1 error) *EC2_DescribeRegions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeRegions_Call) RunAndReturn(run func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error)) *EC2_DescribeRegions_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeReplaceRootVolumeTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReplaceRootVolumeTasks(ctx context.Context, params *ec2.DescribeReplaceRootVolumeTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReplaceRootVolumeTasks")
	}

	var r0 *ec2.DescribeReplaceRootVolumeTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) *ec2.DescribeReplaceRootVolumeTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReplaceRootVolumeTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeReplaceRootVolumeTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeReplaceRootVolumeTasks'
type EC2_DescribeReplaceRootVolumeTasks_Call struct {
	*mock.Call
}

// DescribeReplaceRootVolumeTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeReplaceRootVolumeTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeReplaceRootVolumeTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeReplaceRootVolumeTasks_Call {
	return &EC2_DescribeReplaceRootVolumeTasks_Call{Call: _e.mock.On("DescribeReplaceRootVolumeTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeReplaceRootVolumeTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeReplaceRootVolumeTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeReplaceRootVolumeTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeReplaceRootVolumeTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeReplaceRootVolumeTasks_Call) Return(_a0 *ec2.DescribeReplaceRootVolumeTasksOutput, _a1 error) *EC2_DescribeReplaceRootVolumeTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeReplaceRootVolumeTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error)) *EC2_DescribeReplaceRootVolumeTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstances(ctx context.Context, params *ec2.DescribeReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstances")
	}

	var r0 *ec2.DescribeReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeReservedInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeReservedInstances'
type EC2_DescribeReservedInstances_Call struct {
	*mock.Call
}

// DescribeReservedInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeReservedInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeReservedInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeReservedInstances_Call {
	return &EC2_DescribeReservedInstances_Call{Call: _e.mock.On("DescribeReservedInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeReservedInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeReservedInstancesInput, optFns ...func(*ec2.Options))) *EC2_DescribeReservedInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeReservedInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeReservedInstances_Call) Return(_a0 *ec2.DescribeReservedInstancesOutput, _a1 error) *EC2_DescribeReservedInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeReservedInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error)) *EC2_DescribeReservedInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeReservedInstancesListings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstancesListings(ctx context.Context, params *ec2.DescribeReservedInstancesListingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstancesListings")
	}

	var r0 *ec2.DescribeReservedInstancesListingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesListingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesListingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeReservedInstancesListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeReservedInstancesListings'
type EC2_DescribeReservedInstancesListings_Call struct {
	*mock.Call
}

// DescribeReservedInstancesListings is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeReservedInstancesListingsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeReservedInstancesListings(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeReservedInstancesListings_Call {
	return &EC2_DescribeReservedInstancesListings_Call{Call: _e.mock.On("DescribeReservedInstancesListings",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeReservedInstancesListings_Call) Run(run func(ctx context.Context, params *ec2.DescribeReservedInstancesListingsInput, optFns ...func(*ec2.Options))) *EC2_DescribeReservedInstancesListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeReservedInstancesListingsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeReservedInstancesListings_Call) Return(_a0 *ec2.DescribeReservedInstancesListingsOutput, _a1 error) *EC2_DescribeReservedInstancesListings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeReservedInstancesListings_Call) RunAndReturn(run func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error)) *EC2_DescribeReservedInstancesListings_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeReservedInstancesModifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstancesModifications(ctx context.Context, params *ec2.DescribeReservedInstancesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstancesModifications")
	}

	var r0 *ec2.DescribeReservedInstancesModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeReservedInstancesModifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeReservedInstancesModifications'
type EC2_DescribeReservedInstancesModifications_Call struct {
	*mock.Call
}

// DescribeReservedInstancesModifications is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeReservedInstancesModificationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeReservedInstancesModifications(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeReservedInstancesModifications_Call {
	return &EC2_DescribeReservedInstancesModifications_Call{Call: _e.mock.On("DescribeReservedInstancesModifications",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeReservedInstancesModifications_Call) Run(run func(ctx context.Context, params *ec2.DescribeReservedInstancesModificationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeReservedInstancesModifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeReservedInstancesModificationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeReservedInstancesModifications_Call) Return(_a0 *ec2.DescribeReservedInstancesModificationsOutput, _a1 error) *EC2_DescribeReservedInstancesModifications_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeReservedInstancesModifications_Call) RunAndReturn(run func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error)) *EC2_DescribeReservedInstancesModifications_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeReservedInstancesOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstancesOfferings(ctx context.Context, params *ec2.DescribeReservedInstancesOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeReservedInstancesOfferings")
	}

	var r0 *ec2.DescribeReservedInstancesOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeReservedInstancesOfferings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeReservedInstancesOfferings'
type EC2_DescribeReservedInstancesOfferings_Call struct {
	*mock.Call
}

// DescribeReservedInstancesOfferings is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeReservedInstancesOfferingsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeReservedInstancesOfferings(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeReservedInstancesOfferings_Call {
	return &EC2_DescribeReservedInstancesOfferings_Call{Call: _e.mock.On("DescribeReservedInstancesOfferings",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeReservedInstancesOfferings_Call) Run(run func(ctx context.Context, params *ec2.DescribeReservedInstancesOfferingsInput, optFns ...func(*ec2.Options))) *EC2_DescribeReservedInstancesOfferings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeReservedInstancesOfferingsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeReservedInstancesOfferings_Call) Return(_a0 *ec2.DescribeReservedInstancesOfferingsOutput, _a1 error) *EC2_DescribeReservedInstancesOfferings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeReservedInstancesOfferings_Call) RunAndReturn(run func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error)) *EC2_DescribeReservedInstancesOfferings_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeRouteTables(ctx context.Context, params *ec2.DescribeRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRouteTables")
	}

	var r0 *ec2.DescribeRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeRouteTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeRouteTables'
type EC2_DescribeRouteTables_Call struct {
	*mock.Call
}

// DescribeRouteTables is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeRouteTablesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeRouteTables(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeRouteTables_Call {
	return &EC2_DescribeRouteTables_Call{Call: _e.mock.On("DescribeRouteTables",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeRouteTables_Call) Run(run func(ctx context.Context, params *ec2.DescribeRouteTablesInput, optFns ...func(*ec2.Options))) *EC2_DescribeRouteTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeRouteTablesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeRouteTables_Call) Return(_a0 *ec2.DescribeRouteTablesOutput, _a1 error) *EC2_DescribeRouteTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeRouteTables_Call) RunAndReturn(run func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error)) *EC2_DescribeRouteTables_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeScheduledInstanceAvailability provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeScheduledInstanceAvailability(ctx context.Context, params *ec2.DescribeScheduledInstanceAvailabilityInput, optFns ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScheduledInstanceAvailability")
	}

	var r0 *ec2.DescribeScheduledInstanceAvailabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) *ec2.DescribeScheduledInstanceAvailabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstanceAvailabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeScheduledInstanceAvailability_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeScheduledInstanceAvailability'
type EC2_DescribeScheduledInstanceAvailability_Call struct {
	*mock.Call
}

// DescribeScheduledInstanceAvailability is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeScheduledInstanceAvailabilityInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeScheduledInstanceAvailability(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeScheduledInstanceAvailability_Call {
	return &EC2_DescribeScheduledInstanceAvailability_Call{Call: _e.mock.On("DescribeScheduledInstanceAvailability",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeScheduledInstanceAvailability_Call) Run(run func(ctx context.Context, params *ec2.DescribeScheduledInstanceAvailabilityInput, optFns ...func(*ec2.Options))) *EC2_DescribeScheduledInstanceAvailability_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeScheduledInstanceAvailabilityInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeScheduledInstanceAvailability_Call) Return(_a0 *ec2.DescribeScheduledInstanceAvailabilityOutput, _a1 error) *EC2_DescribeScheduledInstanceAvailability_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeScheduledInstanceAvailability_Call) RunAndReturn(run func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error)) *EC2_DescribeScheduledInstanceAvailability_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeScheduledInstances(ctx context.Context, params *ec2.DescribeScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeScheduledInstances")
	}

	var r0 *ec2.DescribeScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) *ec2.DescribeScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeScheduledInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeScheduledInstances'
type EC2_DescribeScheduledInstances_Call struct {
	*mock.Call
}

// DescribeScheduledInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeScheduledInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeScheduledInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeScheduledInstances_Call {
	return &EC2_DescribeScheduledInstances_Call{Call: _e.mock.On("DescribeScheduledInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeScheduledInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeScheduledInstancesInput, optFns ...func(*ec2.Options))) *EC2_DescribeScheduledInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeScheduledInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeScheduledInstances_Call) Return(_a0 *ec2.DescribeScheduledInstancesOutput, _a1 error) *EC2_DescribeScheduledInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeScheduledInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error)) *EC2_DescribeScheduledInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSecurityGroupReferences provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSecurityGroupReferences(ctx context.Context, params *ec2.DescribeSecurityGroupReferencesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroupReferences")
	}

	var r0 *ec2.DescribeSecurityGroupReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSecurityGroupReferences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSecurityGroupReferences'
type EC2_DescribeSecurityGroupReferences_Call struct {
	*mock.Call
}

// DescribeSecurityGroupReferences is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSecurityGroupReferencesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSecurityGroupReferences(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSecurityGroupReferences_Call {
	return &EC2_DescribeSecurityGroupReferences_Call{Call: _e.mock.On("DescribeSecurityGroupReferences",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSecurityGroupReferences_Call) Run(run func(ctx context.Context, params *ec2.DescribeSecurityGroupReferencesInput, optFns ...func(*ec2.Options))) *EC2_DescribeSecurityGroupReferences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSecurityGroupReferencesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSecurityGroupReferences_Call) Return(_a0 *ec2.DescribeSecurityGroupReferencesOutput, _a1 error) *EC2_DescribeSecurityGroupReferences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSecurityGroupReferences_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error)) *EC2_DescribeSecurityGroupReferences_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSecurityGroupRules provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSecurityGroupRules(ctx context.Context, params *ec2.DescribeSecurityGroupRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroupRules")
	}

	var r0 *ec2.DescribeSecurityGroupRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSecurityGroupRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSecurityGroupRules'
type EC2_DescribeSecurityGroupRules_Call struct {
	*mock.Call
}

// DescribeSecurityGroupRules is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSecurityGroupRulesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSecurityGroupRules(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSecurityGroupRules_Call {
	return &EC2_DescribeSecurityGroupRules_Call{Call: _e.mock.On("DescribeSecurityGroupRules",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSecurityGroupRules_Call) Run(run func(ctx context.Context, params *ec2.DescribeSecurityGroupRulesInput, optFns ...func(*ec2.Options))) *EC2_DescribeSecurityGroupRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSecurityGroupRulesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSecurityGroupRules_Call) Return(_a0 *ec2.DescribeSecurityGroupRulesOutput, _a1 error) *EC2_DescribeSecurityGroupRules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSecurityGroupRules_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error)) *EC2_DescribeSecurityGroupRules_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSecurityGroups(ctx context.Context, params *ec2.DescribeSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroups")
	}

	var r0 *ec2.DescribeSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSecurityGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSecurityGroups'
type EC2_DescribeSecurityGroups_Call struct {
	*mock.Call
}

// DescribeSecurityGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSecurityGroupsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSecurityGroups(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSecurityGroups_Call {
	return &EC2_DescribeSecurityGroups_Call{Call: _e.mock.On("DescribeSecurityGroups",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSecurityGroups_Call) Run(run func(ctx context.Context, params *ec2.DescribeSecurityGroupsInput, optFns ...func(*ec2.Options))) *EC2_DescribeSecurityGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSecurityGroupsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSecurityGroups_Call) Return(_a0 *ec2.DescribeSecurityGroupsOutput, _a1 error) *EC2_DescribeSecurityGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSecurityGroups_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error)) *EC2_DescribeSecurityGroups_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSnapshotAttribute(ctx context.Context, params *ec2.DescribeSnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshotAttribute")
	}

	var r0 *ec2.DescribeSnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSnapshotAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSnapshotAttribute'
type EC2_DescribeSnapshotAttribute_Call struct {
	*mock.Call
}

// DescribeSnapshotAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSnapshotAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSnapshotAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSnapshotAttribute_Call {
	return &EC2_DescribeSnapshotAttribute_Call{Call: _e.mock.On("DescribeSnapshotAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSnapshotAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeSnapshotAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeSnapshotAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSnapshotAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSnapshotAttribute_Call) Return(_a0 *ec2.DescribeSnapshotAttributeOutput, _a1 error) *EC2_DescribeSnapshotAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSnapshotAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error)) *EC2_DescribeSnapshotAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSnapshotTierStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSnapshotTierStatus(ctx context.Context, params *ec2.DescribeSnapshotTierStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshotTierStatus")
	}

	var r0 *ec2.DescribeSnapshotTierStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotTierStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotTierStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSnapshotTierStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSnapshotTierStatus'
type EC2_DescribeSnapshotTierStatus_Call struct {
	*mock.Call
}

// DescribeSnapshotTierStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSnapshotTierStatusInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSnapshotTierStatus(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSnapshotTierStatus_Call {
	return &EC2_DescribeSnapshotTierStatus_Call{Call: _e.mock.On("DescribeSnapshotTierStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSnapshotTierStatus_Call) Run(run func(ctx context.Context, params *ec2.DescribeSnapshotTierStatusInput, optFns ...func(*ec2.Options))) *EC2_DescribeSnapshotTierStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSnapshotTierStatusInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSnapshotTierStatus_Call) Return(_a0 *ec2.DescribeSnapshotTierStatusOutput, _a1 error) *EC2_DescribeSnapshotTierStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSnapshotTierStatus_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error)) *EC2_DescribeSnapshotTierStatus_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSnapshots(ctx context.Context, params *ec2.DescribeSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSnapshots")
	}

	var r0 *ec2.DescribeSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSnapshots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSnapshots'
type EC2_DescribeSnapshots_Call struct {
	*mock.Call
}

// DescribeSnapshots is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSnapshotsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSnapshots(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSnapshots_Call {
	return &EC2_DescribeSnapshots_Call{Call: _e.mock.On("DescribeSnapshots",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSnapshots_Call) Run(run func(ctx context.Context, params *ec2.DescribeSnapshotsInput, optFns ...func(*ec2.Options))) *EC2_DescribeSnapshots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSnapshotsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSnapshots_Call) Return(_a0 *ec2.DescribeSnapshotsOutput, _a1 error) *EC2_DescribeSnapshots_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSnapshots_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error)) *EC2_DescribeSnapshots_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotDatafeedSubscription(ctx context.Context, params *ec2.DescribeSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotDatafeedSubscription")
	}

	var r0 *ec2.DescribeSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.DescribeSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSpotDatafeedSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSpotDatafeedSubscription'
type EC2_DescribeSpotDatafeedSubscription_Call struct {
	*mock.Call
}

// DescribeSpotDatafeedSubscription is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSpotDatafeedSubscriptionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSpotDatafeedSubscription(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSpotDatafeedSubscription_Call {
	return &EC2_DescribeSpotDatafeedSubscription_Call{Call: _e.mock.On("DescribeSpotDatafeedSubscription",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSpotDatafeedSubscription_Call) Run(run func(ctx context.Context, params *ec2.DescribeSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options))) *EC2_DescribeSpotDatafeedSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSpotDatafeedSubscriptionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSpotDatafeedSubscription_Call) Return(_a0 *ec2.DescribeSpotDatafeedSubscriptionOutput, _a1 error) *EC2_DescribeSpotDatafeedSubscription_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSpotDatafeedSubscription_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error)) *EC2_DescribeSpotDatafeedSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSpotFleetInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotFleetInstances(ctx context.Context, params *ec2.DescribeSpotFleetInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotFleetInstances")
	}

	var r0 *ec2.DescribeSpotFleetInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSpotFleetInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSpotFleetInstances'
type EC2_DescribeSpotFleetInstances_Call struct {
	*mock.Call
}

// DescribeSpotFleetInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSpotFleetInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSpotFleetInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSpotFleetInstances_Call {
	return &EC2_DescribeSpotFleetInstances_Call{Call: _e.mock.On("DescribeSpotFleetInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSpotFleetInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeSpotFleetInstancesInput, optFns ...func(*ec2.Options))) *EC2_DescribeSpotFleetInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSpotFleetInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSpotFleetInstances_Call) Return(_a0 *ec2.DescribeSpotFleetInstancesOutput, _a1 error) *EC2_DescribeSpotFleetInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSpotFleetInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error)) *EC2_DescribeSpotFleetInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSpotFleetRequestHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotFleetRequestHistory(ctx context.Context, params *ec2.DescribeSpotFleetRequestHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotFleetRequestHistory")
	}

	var r0 *ec2.DescribeSpotFleetRequestHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetRequestHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSpotFleetRequestHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSpotFleetRequestHistory'
type EC2_DescribeSpotFleetRequestHistory_Call struct {
	*mock.Call
}

// DescribeSpotFleetRequestHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSpotFleetRequestHistoryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSpotFleetRequestHistory(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSpotFleetRequestHistory_Call {
	return &EC2_DescribeSpotFleetRequestHistory_Call{Call: _e.mock.On("DescribeSpotFleetRequestHistory",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSpotFleetRequestHistory_Call) Run(run func(ctx context.Context, params *ec2.DescribeSpotFleetRequestHistoryInput, optFns ...func(*ec2.Options))) *EC2_DescribeSpotFleetRequestHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSpotFleetRequestHistoryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSpotFleetRequestHistory_Call) Return(_a0 *ec2.DescribeSpotFleetRequestHistoryOutput, _a1 error) *EC2_DescribeSpotFleetRequestHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSpotFleetRequestHistory_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error)) *EC2_DescribeSpotFleetRequestHistory_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSpotFleetRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotFleetRequests(ctx context.Context, params *ec2.DescribeSpotFleetRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotFleetRequests")
	}

	var r0 *ec2.DescribeSpotFleetRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSpotFleetRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSpotFleetRequests'
type EC2_DescribeSpotFleetRequests_Call struct {
	*mock.Call
}

// DescribeSpotFleetRequests is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSpotFleetRequestsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSpotFleetRequests(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSpotFleetRequests_Call {
	return &EC2_DescribeSpotFleetRequests_Call{Call: _e.mock.On("DescribeSpotFleetRequests",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSpotFleetRequests_Call) Run(run func(ctx context.Context, params *ec2.DescribeSpotFleetRequestsInput, optFns ...func(*ec2.Options))) *EC2_DescribeSpotFleetRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSpotFleetRequestsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSpotFleetRequests_Call) Return(_a0 *ec2.DescribeSpotFleetRequestsOutput, _a1 error) *EC2_DescribeSpotFleetRequests_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSpotFleetRequests_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error)) *EC2_DescribeSpotFleetRequests_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSpotInstanceRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotInstanceRequests(ctx context.Context, params *ec2.DescribeSpotInstanceRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotInstanceRequests")
	}

	var r0 *ec2.DescribeSpotInstanceRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) *ec2.DescribeSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotInstanceRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSpotInstanceRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSpotInstanceRequests'
type EC2_DescribeSpotInstanceRequests_Call struct {
	*mock.Call
}

// DescribeSpotInstanceRequests is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSpotInstanceRequestsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSpotInstanceRequests(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSpotInstanceRequests_Call {
	return &EC2_DescribeSpotInstanceRequests_Call{Call: _e.mock.On("DescribeSpotInstanceRequests",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSpotInstanceRequests_Call) Run(run func(ctx context.Context, params *ec2.DescribeSpotInstanceRequestsInput, optFns ...func(*ec2.Options))) *EC2_DescribeSpotInstanceRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSpotInstanceRequestsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSpotInstanceRequests_Call) Return(_a0 *ec2.DescribeSpotInstanceRequestsOutput, _a1 error) *EC2_DescribeSpotInstanceRequests_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSpotInstanceRequests_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error)) *EC2_DescribeSpotInstanceRequests_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSpotPriceHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotPriceHistory(ctx context.Context, params *ec2.DescribeSpotPriceHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSpotPriceHistory")
	}

	var r0 *ec2.DescribeSpotPriceHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) *ec2.DescribeSpotPriceHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotPriceHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSpotPriceHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSpotPriceHistory'
type EC2_DescribeSpotPriceHistory_Call struct {
	*mock.Call
}

// DescribeSpotPriceHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSpotPriceHistoryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSpotPriceHistory(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSpotPriceHistory_Call {
	return &EC2_DescribeSpotPriceHistory_Call{Call: _e.mock.On("DescribeSpotPriceHistory",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSpotPriceHistory_Call) Run(run func(ctx context.Context, params *ec2.DescribeSpotPriceHistoryInput, optFns ...func(*ec2.Options))) *EC2_DescribeSpotPriceHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSpotPriceHistoryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSpotPriceHistory_Call) Return(_a0 *ec2.DescribeSpotPriceHistoryOutput, _a1 error) *EC2_DescribeSpotPriceHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSpotPriceHistory_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error)) *EC2_DescribeSpotPriceHistory_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeStaleSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeStaleSecurityGroups(ctx context.Context, params *ec2.DescribeStaleSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStaleSecurityGroups")
	}

	var r0 *ec2.DescribeStaleSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeStaleSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStaleSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeStaleSecurityGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeStaleSecurityGroups'
type EC2_DescribeStaleSecurityGroups_Call struct {
	*mock.Call
}

// DescribeStaleSecurityGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeStaleSecurityGroupsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeStaleSecurityGroups(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeStaleSecurityGroups_Call {
	return &EC2_DescribeStaleSecurityGroups_Call{Call: _e.mock.On("DescribeStaleSecurityGroups",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeStaleSecurityGroups_Call) Run(run func(ctx context.Context, params *ec2.DescribeStaleSecurityGroupsInput, optFns ...func(*ec2.Options))) *EC2_DescribeStaleSecurityGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeStaleSecurityGroupsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeStaleSecurityGroups_Call) Return(_a0 *ec2.DescribeStaleSecurityGroupsOutput, _a1 error) *EC2_DescribeStaleSecurityGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeStaleSecurityGroups_Call) RunAndReturn(run func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error)) *EC2_DescribeStaleSecurityGroups_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeStoreImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeStoreImageTasks(ctx context.Context, params *ec2.DescribeStoreImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStoreImageTasks")
	}

	var r0 *ec2.DescribeStoreImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeStoreImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStoreImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeStoreImageTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeStoreImageTasks'
type EC2_DescribeStoreImageTasks_Call struct {
	*mock.Call
}

// DescribeStoreImageTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeStoreImageTasksInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeStoreImageTasks(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeStoreImageTasks_Call {
	return &EC2_DescribeStoreImageTasks_Call{Call: _e.mock.On("DescribeStoreImageTasks",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeStoreImageTasks_Call) Run(run func(ctx context.Context, params *ec2.DescribeStoreImageTasksInput, optFns ...func(*ec2.Options))) *EC2_DescribeStoreImageTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeStoreImageTasksInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeStoreImageTasks_Call) Return(_a0 *ec2.DescribeStoreImageTasksOutput, _a1 error) *EC2_DescribeStoreImageTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeStoreImageTasks_Call) RunAndReturn(run func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error)) *EC2_DescribeStoreImageTasks_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSubnets(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSubnets")
	}

	var r0 *ec2.DescribeSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) *ec2.DescribeSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeSubnets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSubnets'
type EC2_DescribeSubnets_Call struct {
	*mock.Call
}

// DescribeSubnets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSubnetsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeSubnets(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeSubnets_Call {
	return &EC2_DescribeSubnets_Call{Call: _e.mock.On("DescribeSubnets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeSubnets_Call) Run(run func(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options))) *EC2_DescribeSubnets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSubnetsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeSubnets_Call) Return(_a0 *ec2.DescribeSubnetsOutput, _a1 error) *EC2_DescribeSubnets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeSubnets_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error)) *EC2_DescribeSubnets_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTags(ctx context.Context, params *ec2.DescribeTagsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTags")
	}

	var r0 *ec2.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) *ec2.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTags'
type EC2_DescribeTags_Call struct {
	*mock.Call
}

// DescribeTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTagsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTags(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTags_Call {
	return &EC2_DescribeTags_Call{Call: _e.mock.On("DescribeTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTags_Call) Run(run func(ctx context.Context, params *ec2.DescribeTagsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTags_Call) Return(_a0 *ec2.DescribeTagsOutput, _a1 error) *EC2_DescribeTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTags_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error)) *EC2_DescribeTags_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTrafficMirrorFilters provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrafficMirrorFilters(ctx context.Context, params *ec2.DescribeTrafficMirrorFiltersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorFilters")
	}

	var r0 *ec2.DescribeTrafficMirrorFiltersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorFiltersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorFiltersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTrafficMirrorFilters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTrafficMirrorFilters'
type EC2_DescribeTrafficMirrorFilters_Call struct {
	*mock.Call
}

// DescribeTrafficMirrorFilters is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTrafficMirrorFiltersInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTrafficMirrorFilters(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTrafficMirrorFilters_Call {
	return &EC2_DescribeTrafficMirrorFilters_Call{Call: _e.mock.On("DescribeTrafficMirrorFilters",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTrafficMirrorFilters_Call) Run(run func(ctx context.Context, params *ec2.DescribeTrafficMirrorFiltersInput, optFns ...func(*ec2.Options))) *EC2_DescribeTrafficMirrorFilters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTrafficMirrorFiltersInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTrafficMirrorFilters_Call) Return(_a0 *ec2.DescribeTrafficMirrorFiltersOutput, _a1 error) *EC2_DescribeTrafficMirrorFilters_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTrafficMirrorFilters_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error)) *EC2_DescribeTrafficMirrorFilters_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTrafficMirrorSessions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrafficMirrorSessions(ctx context.Context, params *ec2.DescribeTrafficMirrorSessionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorSessions")
	}

	var r0 *ec2.DescribeTrafficMirrorSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTrafficMirrorSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTrafficMirrorSessions'
type EC2_DescribeTrafficMirrorSessions_Call struct {
	*mock.Call
}

// DescribeTrafficMirrorSessions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTrafficMirrorSessionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTrafficMirrorSessions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTrafficMirrorSessions_Call {
	return &EC2_DescribeTrafficMirrorSessions_Call{Call: _e.mock.On("DescribeTrafficMirrorSessions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTrafficMirrorSessions_Call) Run(run func(ctx context.Context, params *ec2.DescribeTrafficMirrorSessionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTrafficMirrorSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTrafficMirrorSessionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTrafficMirrorSessions_Call) Return(_a0 *ec2.DescribeTrafficMirrorSessionsOutput, _a1 error) *EC2_DescribeTrafficMirrorSessions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTrafficMirrorSessions_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error)) *EC2_DescribeTrafficMirrorSessions_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTrafficMirrorTargets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrafficMirrorTargets(ctx context.Context, params *ec2.DescribeTrafficMirrorTargetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrafficMirrorTargets")
	}

	var r0 *ec2.DescribeTrafficMirrorTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTrafficMirrorTargets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTrafficMirrorTargets'
type EC2_DescribeTrafficMirrorTargets_Call struct {
	*mock.Call
}

// DescribeTrafficMirrorTargets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTrafficMirrorTargetsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTrafficMirrorTargets(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTrafficMirrorTargets_Call {
	return &EC2_DescribeTrafficMirrorTargets_Call{Call: _e.mock.On("DescribeTrafficMirrorTargets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTrafficMirrorTargets_Call) Run(run func(ctx context.Context, params *ec2.DescribeTrafficMirrorTargetsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTrafficMirrorTargets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTrafficMirrorTargetsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTrafficMirrorTargets_Call) Return(_a0 *ec2.DescribeTrafficMirrorTargetsOutput, _a1 error) *EC2_DescribeTrafficMirrorTargets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTrafficMirrorTargets_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error)) *EC2_DescribeTrafficMirrorTargets_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayAttachments")
	}

	var r0 *ec2.DescribeTransitGatewayAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayAttachments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayAttachments'
type EC2_DescribeTransitGatewayAttachments_Call struct {
	*mock.Call
}

// DescribeTransitGatewayAttachments is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayAttachmentsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayAttachments(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayAttachments_Call {
	return &EC2_DescribeTransitGatewayAttachments_Call{Call: _e.mock.On("DescribeTransitGatewayAttachments",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayAttachments_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayAttachmentsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayAttachments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayAttachmentsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayAttachments_Call) Return(_a0 *ec2.DescribeTransitGatewayAttachmentsOutput, _a1 error) *EC2_DescribeTransitGatewayAttachments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayAttachments_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error)) *EC2_DescribeTransitGatewayAttachments_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayConnectPeers provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayConnectPeers(ctx context.Context, params *ec2.DescribeTransitGatewayConnectPeersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayConnectPeers")
	}

	var r0 *ec2.DescribeTransitGatewayConnectPeersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayConnectPeersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayConnectPeersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayConnectPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayConnectPeers'
type EC2_DescribeTransitGatewayConnectPeers_Call struct {
	*mock.Call
}

// DescribeTransitGatewayConnectPeers is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayConnectPeersInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayConnectPeers(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayConnectPeers_Call {
	return &EC2_DescribeTransitGatewayConnectPeers_Call{Call: _e.mock.On("DescribeTransitGatewayConnectPeers",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayConnectPeers_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayConnectPeersInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayConnectPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayConnectPeersInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayConnectPeers_Call) Return(_a0 *ec2.DescribeTransitGatewayConnectPeersOutput, _a1 error) *EC2_DescribeTransitGatewayConnectPeers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayConnectPeers_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error)) *EC2_DescribeTransitGatewayConnectPeers_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayConnects provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayConnects(ctx context.Context, params *ec2.DescribeTransitGatewayConnectsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayConnects")
	}

	var r0 *ec2.DescribeTransitGatewayConnectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayConnectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayConnectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayConnects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayConnects'
type EC2_DescribeTransitGatewayConnects_Call struct {
	*mock.Call
}

// DescribeTransitGatewayConnects is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayConnectsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayConnects(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayConnects_Call {
	return &EC2_DescribeTransitGatewayConnects_Call{Call: _e.mock.On("DescribeTransitGatewayConnects",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayConnects_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayConnectsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayConnects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayConnectsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayConnects_Call) Return(_a0 *ec2.DescribeTransitGatewayConnectsOutput, _a1 error) *EC2_DescribeTransitGatewayConnects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayConnects_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error)) *EC2_DescribeTransitGatewayConnects_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayMulticastDomains provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayMulticastDomains(ctx context.Context, params *ec2.DescribeTransitGatewayMulticastDomainsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayMulticastDomains")
	}

	var r0 *ec2.DescribeTransitGatewayMulticastDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayMulticastDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayMulticastDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayMulticastDomains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayMulticastDomains'
type EC2_DescribeTransitGatewayMulticastDomains_Call struct {
	*mock.Call
}

// DescribeTransitGatewayMulticastDomains is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayMulticastDomainsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayMulticastDomains(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayMulticastDomains_Call {
	return &EC2_DescribeTransitGatewayMulticastDomains_Call{Call: _e.mock.On("DescribeTransitGatewayMulticastDomains",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayMulticastDomains_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayMulticastDomainsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayMulticastDomains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayMulticastDomainsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayMulticastDomains_Call) Return(_a0 *ec2.DescribeTransitGatewayMulticastDomainsOutput, _a1 error) *EC2_DescribeTransitGatewayMulticastDomains_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayMulticastDomains_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error)) *EC2_DescribeTransitGatewayMulticastDomains_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayPeeringAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayPeeringAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayPeeringAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayPeeringAttachments")
	}

	var r0 *ec2.DescribeTransitGatewayPeeringAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayPeeringAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayPeeringAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayPeeringAttachments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayPeeringAttachments'
type EC2_DescribeTransitGatewayPeeringAttachments_Call struct {
	*mock.Call
}

// DescribeTransitGatewayPeeringAttachments is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayPeeringAttachmentsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayPeeringAttachments(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayPeeringAttachments_Call {
	return &EC2_DescribeTransitGatewayPeeringAttachments_Call{Call: _e.mock.On("DescribeTransitGatewayPeeringAttachments",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayPeeringAttachments_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayPeeringAttachmentsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayPeeringAttachments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayPeeringAttachmentsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayPeeringAttachments_Call) Return(_a0 *ec2.DescribeTransitGatewayPeeringAttachmentsOutput, _a1 error) *EC2_DescribeTransitGatewayPeeringAttachments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayPeeringAttachments_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error)) *EC2_DescribeTransitGatewayPeeringAttachments_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayRouteTables(ctx context.Context, params *ec2.DescribeTransitGatewayRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayRouteTables")
	}

	var r0 *ec2.DescribeTransitGatewayRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayRouteTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayRouteTables'
type EC2_DescribeTransitGatewayRouteTables_Call struct {
	*mock.Call
}

// DescribeTransitGatewayRouteTables is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayRouteTablesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayRouteTables(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayRouteTables_Call {
	return &EC2_DescribeTransitGatewayRouteTables_Call{Call: _e.mock.On("DescribeTransitGatewayRouteTables",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayRouteTables_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayRouteTablesInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayRouteTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayRouteTablesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayRouteTables_Call) Return(_a0 *ec2.DescribeTransitGatewayRouteTablesOutput, _a1 error) *EC2_DescribeTransitGatewayRouteTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayRouteTables_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error)) *EC2_DescribeTransitGatewayRouteTables_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGatewayVpcAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayVpcAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayVpcAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGatewayVpcAttachments")
	}

	var r0 *ec2.DescribeTransitGatewayVpcAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayVpcAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayVpcAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGatewayVpcAttachments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGatewayVpcAttachments'
type EC2_DescribeTransitGatewayVpcAttachments_Call struct {
	*mock.Call
}

// DescribeTransitGatewayVpcAttachments is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewayVpcAttachmentsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGatewayVpcAttachments(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGatewayVpcAttachments_Call {
	return &EC2_DescribeTransitGatewayVpcAttachments_Call{Call: _e.mock.On("DescribeTransitGatewayVpcAttachments",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGatewayVpcAttachments_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewayVpcAttachmentsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGatewayVpcAttachments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewayVpcAttachmentsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGatewayVpcAttachments_Call) Return(_a0 *ec2.DescribeTransitGatewayVpcAttachmentsOutput, _a1 error) *EC2_DescribeTransitGatewayVpcAttachments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGatewayVpcAttachments_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error)) *EC2_DescribeTransitGatewayVpcAttachments_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTransitGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGateways(ctx context.Context, params *ec2.DescribeTransitGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTransitGateways")
	}

	var r0 *ec2.DescribeTransitGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTransitGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTransitGateways'
type EC2_DescribeTransitGateways_Call struct {
	*mock.Call
}

// DescribeTransitGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTransitGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTransitGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTransitGateways_Call {
	return &EC2_DescribeTransitGateways_Call{Call: _e.mock.On("DescribeTransitGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTransitGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeTransitGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeTransitGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTransitGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTransitGateways_Call) Return(_a0 *ec2.DescribeTransitGatewaysOutput, _a1 error) *EC2_DescribeTransitGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTransitGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error)) *EC2_DescribeTransitGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTrunkInterfaceAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrunkInterfaceAssociations(ctx context.Context, params *ec2.DescribeTrunkInterfaceAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTrunkInterfaceAssociations")
	}

	var r0 *ec2.DescribeTrunkInterfaceAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeTrunkInterfaceAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrunkInterfaceAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeTrunkInterfaceAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTrunkInterfaceAssociations'
type EC2_DescribeTrunkInterfaceAssociations_Call struct {
	*mock.Call
}

// DescribeTrunkInterfaceAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeTrunkInterfaceAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeTrunkInterfaceAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeTrunkInterfaceAssociations_Call {
	return &EC2_DescribeTrunkInterfaceAssociations_Call{Call: _e.mock.On("DescribeTrunkInterfaceAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeTrunkInterfaceAssociations_Call) Run(run func(ctx context.Context, params *ec2.DescribeTrunkInterfaceAssociationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeTrunkInterfaceAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeTrunkInterfaceAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeTrunkInterfaceAssociations_Call) Return(_a0 *ec2.DescribeTrunkInterfaceAssociationsOutput, _a1 error) *EC2_DescribeTrunkInterfaceAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeTrunkInterfaceAssociations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error)) *EC2_DescribeTrunkInterfaceAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVolumeAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumeAttribute(ctx context.Context, params *ec2.DescribeVolumeAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumeAttribute")
	}

	var r0 *ec2.DescribeVolumeAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) *ec2.DescribeVolumeAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVolumeAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVolumeAttribute'
type EC2_DescribeVolumeAttribute_Call struct {
	*mock.Call
}

// DescribeVolumeAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVolumeAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVolumeAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVolumeAttribute_Call {
	return &EC2_DescribeVolumeAttribute_Call{Call: _e.mock.On("DescribeVolumeAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVolumeAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeVolumeAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeVolumeAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVolumeAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVolumeAttribute_Call) Return(_a0 *ec2.DescribeVolumeAttributeOutput, _a1 error) *EC2_DescribeVolumeAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVolumeAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error)) *EC2_DescribeVolumeAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVolumeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumeStatus(ctx context.Context, params *ec2.DescribeVolumeStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumeStatus")
	}

	var r0 *ec2.DescribeVolumeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) *ec2.DescribeVolumeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVolumeStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVolumeStatus'
type EC2_DescribeVolumeStatus_Call struct {
	*mock.Call
}

// DescribeVolumeStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVolumeStatusInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVolumeStatus(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVolumeStatus_Call {
	return &EC2_DescribeVolumeStatus_Call{Call: _e.mock.On("DescribeVolumeStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVolumeStatus_Call) Run(run func(ctx context.Context, params *ec2.DescribeVolumeStatusInput, optFns ...func(*ec2.Options))) *EC2_DescribeVolumeStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVolumeStatusInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVolumeStatus_Call) Return(_a0 *ec2.DescribeVolumeStatusOutput, _a1 error) *EC2_DescribeVolumeStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVolumeStatus_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error)) *EC2_DescribeVolumeStatus_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVolumes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumes(ctx context.Context, params *ec2.DescribeVolumesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumes")
	}

	var r0 *ec2.DescribeVolumesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) *ec2.DescribeVolumesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVolumes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVolumes'
type EC2_DescribeVolumes_Call struct {
	*mock.Call
}

// DescribeVolumes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVolumesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVolumes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVolumes_Call {
	return &EC2_DescribeVolumes_Call{Call: _e.mock.On("DescribeVolumes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVolumes_Call) Run(run func(ctx context.Context, params *ec2.DescribeVolumesInput, optFns ...func(*ec2.Options))) *EC2_DescribeVolumes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVolumesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVolumes_Call) Return(_a0 *ec2.DescribeVolumesOutput, _a1 error) *EC2_DescribeVolumes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVolumes_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error)) *EC2_DescribeVolumes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVolumesModifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumesModifications(ctx context.Context, params *ec2.DescribeVolumesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVolumesModifications")
	}

	var r0 *ec2.DescribeVolumesModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) *ec2.DescribeVolumesModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVolumesModifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVolumesModifications'
type EC2_DescribeVolumesModifications_Call struct {
	*mock.Call
}

// DescribeVolumesModifications is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVolumesModificationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVolumesModifications(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVolumesModifications_Call {
	return &EC2_DescribeVolumesModifications_Call{Call: _e.mock.On("DescribeVolumesModifications",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVolumesModifications_Call) Run(run func(ctx context.Context, params *ec2.DescribeVolumesModificationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVolumesModifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVolumesModificationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVolumesModifications_Call) Return(_a0 *ec2.DescribeVolumesModificationsOutput, _a1 error) *EC2_DescribeVolumesModifications_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVolumesModifications_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error)) *EC2_DescribeVolumesModifications_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcAttribute(ctx context.Context, params *ec2.DescribeVpcAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcAttribute")
	}

	var r0 *ec2.DescribeVpcAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) *ec2.DescribeVpcAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcAttribute'
type EC2_DescribeVpcAttribute_Call struct {
	*mock.Call
}

// DescribeVpcAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcAttribute_Call {
	return &EC2_DescribeVpcAttribute_Call{Call: _e.mock.On("DescribeVpcAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcAttribute_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcAttributeInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcAttribute_Call) Return(_a0 *ec2.DescribeVpcAttributeOutput, _a1 error) *EC2_DescribeVpcAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcAttribute_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error)) *EC2_DescribeVpcAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcClassicLink(ctx context.Context, params *ec2.DescribeVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcClassicLink")
	}

	var r0 *ec2.DescribeVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.DescribeVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcClassicLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcClassicLink'
type EC2_DescribeVpcClassicLink_Call struct {
	*mock.Call
}

// DescribeVpcClassicLink is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcClassicLinkInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcClassicLink(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcClassicLink_Call {
	return &EC2_DescribeVpcClassicLink_Call{Call: _e.mock.On("DescribeVpcClassicLink",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcClassicLink_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcClassicLinkInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcClassicLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcClassicLinkInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcClassicLink_Call) Return(_a0 *ec2.DescribeVpcClassicLinkOutput, _a1 error) *EC2_DescribeVpcClassicLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcClassicLink_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error)) *EC2_DescribeVpcClassicLink_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.DescribeVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcClassicLinkDnsSupport")
	}

	var r0 *ec2.DescribeVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.DescribeVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcClassicLinkDnsSupport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcClassicLinkDnsSupport'
type EC2_DescribeVpcClassicLinkDnsSupport_Call struct {
	*mock.Call
}

// DescribeVpcClassicLinkDnsSupport is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcClassicLinkDnsSupportInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcClassicLinkDnsSupport(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcClassicLinkDnsSupport_Call {
	return &EC2_DescribeVpcClassicLinkDnsSupport_Call{Call: _e.mock.On("DescribeVpcClassicLinkDnsSupport",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcClassicLinkDnsSupport_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcClassicLinkDnsSupport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcClassicLinkDnsSupportInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcClassicLinkDnsSupport_Call) Return(_a0 *ec2.DescribeVpcClassicLinkDnsSupportOutput, _a1 error) *EC2_DescribeVpcClassicLinkDnsSupport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcClassicLinkDnsSupport_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error)) *EC2_DescribeVpcClassicLinkDnsSupport_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcEndpointConnectionNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointConnectionNotifications(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointConnectionNotifications")
	}

	var r0 *ec2.DescribeVpcEndpointConnectionNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcEndpointConnectionNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcEndpointConnectionNotifications'
type EC2_DescribeVpcEndpointConnectionNotifications_Call struct {
	*mock.Call
}

// DescribeVpcEndpointConnectionNotifications is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcEndpointConnectionNotificationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcEndpointConnectionNotifications(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcEndpointConnectionNotifications_Call {
	return &EC2_DescribeVpcEndpointConnectionNotifications_Call{Call: _e.mock.On("DescribeVpcEndpointConnectionNotifications",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcEndpointConnectionNotifications_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcEndpointConnectionNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcEndpointConnectionNotificationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcEndpointConnectionNotifications_Call) Return(_a0 *ec2.DescribeVpcEndpointConnectionNotificationsOutput, _a1 error) *EC2_DescribeVpcEndpointConnectionNotifications_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcEndpointConnectionNotifications_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error)) *EC2_DescribeVpcEndpointConnectionNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointConnections(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointConnections")
	}

	var r0 *ec2.DescribeVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcEndpointConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcEndpointConnections'
type EC2_DescribeVpcEndpointConnections_Call struct {
	*mock.Call
}

// DescribeVpcEndpointConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcEndpointConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcEndpointConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcEndpointConnections_Call {
	return &EC2_DescribeVpcEndpointConnections_Call{Call: _e.mock.On("DescribeVpcEndpointConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcEndpointConnections_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcEndpointConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcEndpointConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcEndpointConnections_Call) Return(_a0 *ec2.DescribeVpcEndpointConnectionsOutput, _a1 error) *EC2_DescribeVpcEndpointConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcEndpointConnections_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error)) *EC2_DescribeVpcEndpointConnections_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcEndpointServiceConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointServiceConfigurations(ctx context.Context, params *ec2.DescribeVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointServiceConfigurations")
	}

	var r0 *ec2.DescribeVpcEndpointServiceConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServiceConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcEndpointServiceConfigurations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcEndpointServiceConfigurations'
type EC2_DescribeVpcEndpointServiceConfigurations_Call struct {
	*mock.Call
}

// DescribeVpcEndpointServiceConfigurations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcEndpointServiceConfigurationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcEndpointServiceConfigurations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcEndpointServiceConfigurations_Call {
	return &EC2_DescribeVpcEndpointServiceConfigurations_Call{Call: _e.mock.On("DescribeVpcEndpointServiceConfigurations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcEndpointServiceConfigurations_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcEndpointServiceConfigurations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcEndpointServiceConfigurationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcEndpointServiceConfigurations_Call) Return(_a0 *ec2.DescribeVpcEndpointServiceConfigurationsOutput, _a1 error) *EC2_DescribeVpcEndpointServiceConfigurations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcEndpointServiceConfigurations_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error)) *EC2_DescribeVpcEndpointServiceConfigurations_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcEndpointServicePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointServicePermissions(ctx context.Context, params *ec2.DescribeVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointServicePermissions")
	}

	var r0 *ec2.DescribeVpcEndpointServicePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcEndpointServicePermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcEndpointServicePermissions'
type EC2_DescribeVpcEndpointServicePermissions_Call struct {
	*mock.Call
}

// DescribeVpcEndpointServicePermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcEndpointServicePermissionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcEndpointServicePermissions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcEndpointServicePermissions_Call {
	return &EC2_DescribeVpcEndpointServicePermissions_Call{Call: _e.mock.On("DescribeVpcEndpointServicePermissions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcEndpointServicePermissions_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcEndpointServicePermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcEndpointServicePermissionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcEndpointServicePermissions_Call) Return(_a0 *ec2.DescribeVpcEndpointServicePermissionsOutput, _a1 error) *EC2_DescribeVpcEndpointServicePermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcEndpointServicePermissions_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error)) *EC2_DescribeVpcEndpointServicePermissions_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcEndpointServices provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointServices(ctx context.Context, params *ec2.DescribeVpcEndpointServicesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpointServices")
	}

	var r0 *ec2.DescribeVpcEndpointServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcEndpointServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcEndpointServices'
type EC2_DescribeVpcEndpointServices_Call struct {
	*mock.Call
}

// DescribeVpcEndpointServices is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcEndpointServicesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcEndpointServices(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcEndpointServices_Call {
	return &EC2_DescribeVpcEndpointServices_Call{Call: _e.mock.On("DescribeVpcEndpointServices",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcEndpointServices_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcEndpointServicesInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcEndpointServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcEndpointServicesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcEndpointServices_Call) Return(_a0 *ec2.DescribeVpcEndpointServicesOutput, _a1 error) *EC2_DescribeVpcEndpointServices_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcEndpointServices_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error)) *EC2_DescribeVpcEndpointServices_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpoints(ctx context.Context, params *ec2.DescribeVpcEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcEndpoints")
	}

	var r0 *ec2.DescribeVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcEndpoints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcEndpoints'
type EC2_DescribeVpcEndpoints_Call struct {
	*mock.Call
}

// DescribeVpcEndpoints is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcEndpointsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcEndpoints(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcEndpoints_Call {
	return &EC2_DescribeVpcEndpoints_Call{Call: _e.mock.On("DescribeVpcEndpoints",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcEndpoints_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcEndpointsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcEndpoints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcEndpointsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcEndpoints_Call) Return(_a0 *ec2.DescribeVpcEndpointsOutput, _a1 error) *EC2_DescribeVpcEndpoints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcEndpoints_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error)) *EC2_DescribeVpcEndpoints_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcPeeringConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcPeeringConnections(ctx context.Context, params *ec2.DescribeVpcPeeringConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcPeeringConnections")
	}

	var r0 *ec2.DescribeVpcPeeringConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcPeeringConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcPeeringConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcPeeringConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcPeeringConnections'
type EC2_DescribeVpcPeeringConnections_Call struct {
	*mock.Call
}

// DescribeVpcPeeringConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcPeeringConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcPeeringConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcPeeringConnections_Call {
	return &EC2_DescribeVpcPeeringConnections_Call{Call: _e.mock.On("DescribeVpcPeeringConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcPeeringConnections_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcPeeringConnectionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcPeeringConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcPeeringConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcPeeringConnections_Call) Return(_a0 *ec2.DescribeVpcPeeringConnectionsOutput, _a1 error) *EC2_DescribeVpcPeeringConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcPeeringConnections_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error)) *EC2_DescribeVpcPeeringConnections_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcs(ctx context.Context, params *ec2.DescribeVpcsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcs")
	}

	var r0 *ec2.DescribeVpcsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) *ec2.DescribeVpcsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpcs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcs'
type EC2_DescribeVpcs_Call struct {
	*mock.Call
}

// DescribeVpcs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpcs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpcs_Call {
	return &EC2_DescribeVpcs_Call{Call: _e.mock.On("DescribeVpcs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpcs_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpcs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpcs_Call) Return(_a0 *ec2.DescribeVpcsOutput, _a1 error) *EC2_DescribeVpcs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpcs_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error)) *EC2_DescribeVpcs_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpnConnections(ctx context.Context, params *ec2.DescribeVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpnConnections")
	}

	var r0 *ec2.DescribeVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpnConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpnConnections'
type EC2_DescribeVpnConnections_Call struct {
	*mock.Call
}

// DescribeVpnConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpnConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpnConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpnConnections_Call {
	return &EC2_DescribeVpnConnections_Call{Call: _e.mock.On("DescribeVpnConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpnConnections_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpnConnectionsInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpnConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpnConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpnConnections_Call) Return(_a0 *ec2.DescribeVpnConnectionsOutput, _a1 error) *EC2_DescribeVpnConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpnConnections_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error)) *EC2_DescribeVpnConnections_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpnGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpnGateways(ctx context.Context, params *ec2.DescribeVpnGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpnGateways")
	}

	var r0 *ec2.DescribeVpnGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeVpnGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DescribeVpnGateways_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpnGateways'
type EC2_DescribeVpnGateways_Call struct {
	*mock.Call
}

// DescribeVpnGateways is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpnGatewaysInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DescribeVpnGateways(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DescribeVpnGateways_Call {
	return &EC2_DescribeVpnGateways_Call{Call: _e.mock.On("DescribeVpnGateways",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DescribeVpnGateways_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpnGatewaysInput, optFns ...func(*ec2.Options))) *EC2_DescribeVpnGateways_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpnGatewaysInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DescribeVpnGateways_Call) Return(_a0 *ec2.DescribeVpnGatewaysOutput, _a1 error) *EC2_DescribeVpnGateways_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DescribeVpnGateways_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error)) *EC2_DescribeVpnGateways_Call {
	_c.Call.Return(run)
	return _c
}

// DetachClassicLinkVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachClassicLinkVpc(ctx context.Context, params *ec2.DetachClassicLinkVpcInput, optFns ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachClassicLinkVpc")
	}

	var r0 *ec2.DetachClassicLinkVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) *ec2.DetachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachClassicLinkVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DetachClassicLinkVpc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachClassicLinkVpc'
type EC2_DetachClassicLinkVpc_Call struct {
	*mock.Call
}

// DetachClassicLinkVpc is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DetachClassicLinkVpcInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DetachClassicLinkVpc(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DetachClassicLinkVpc_Call {
	return &EC2_DetachClassicLinkVpc_Call{Call: _e.mock.On("DetachClassicLinkVpc",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DetachClassicLinkVpc_Call) Run(run func(ctx context.Context, params *ec2.DetachClassicLinkVpcInput, optFns ...func(*ec2.Options))) *EC2_DetachClassicLinkVpc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DetachClassicLinkVpcInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DetachClassicLinkVpc_Call) Return(_a0 *ec2.DetachClassicLinkVpcOutput, _a1 error) *EC2_DetachClassicLinkVpc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DetachClassicLinkVpc_Call) RunAndReturn(run func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error)) *EC2_DetachClassicLinkVpc_Call {
	_c.Call.Return(run)
	return _c
}

// DetachInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachInternetGateway(ctx context.Context, params *ec2.DetachInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachInternetGateway")
	}

	var r0 *ec2.DetachInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) *ec2.DetachInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DetachInternetGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachInternetGateway'
type EC2_DetachInternetGateway_Call struct {
	*mock.Call
}

// DetachInternetGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DetachInternetGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DetachInternetGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DetachInternetGateway_Call {
	return &EC2_DetachInternetGateway_Call{Call: _e.mock.On("DetachInternetGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DetachInternetGateway_Call) Run(run func(ctx context.Context, params *ec2.DetachInternetGatewayInput, optFns ...func(*ec2.Options))) *EC2_DetachInternetGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DetachInternetGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DetachInternetGateway_Call) Return(_a0 *ec2.DetachInternetGatewayOutput, _a1 error) *EC2_DetachInternetGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DetachInternetGateway_Call) RunAndReturn(run func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error)) *EC2_DetachInternetGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DetachNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachNetworkInterface(ctx context.Context, params *ec2.DetachNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachNetworkInterface")
	}

	var r0 *ec2.DetachNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.DetachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DetachNetworkInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachNetworkInterface'
type EC2_DetachNetworkInterface_Call struct {
	*mock.Call
}

// DetachNetworkInterface is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DetachNetworkInterfaceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DetachNetworkInterface(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DetachNetworkInterface_Call {
	return &EC2_DetachNetworkInterface_Call{Call: _e.mock.On("DetachNetworkInterface",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DetachNetworkInterface_Call) Run(run func(ctx context.Context, params *ec2.DetachNetworkInterfaceInput, optFns ...func(*ec2.Options))) *EC2_DetachNetworkInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DetachNetworkInterfaceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DetachNetworkInterface_Call) Return(_a0 *ec2.DetachNetworkInterfaceOutput, _a1 error) *EC2_DetachNetworkInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DetachNetworkInterface_Call) RunAndReturn(run func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error)) *EC2_DetachNetworkInterface_Call {
	_c.Call.Return(run)
	return _c
}

// DetachVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachVolume(ctx context.Context, params *ec2.DetachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachVolume")
	}

	var r0 *ec2.DetachVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) *ec2.DetachVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DetachVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachVolume'
type EC2_DetachVolume_Call struct {
	*mock.Call
}

// DetachVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DetachVolumeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DetachVolume(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DetachVolume_Call {
	return &EC2_DetachVolume_Call{Call: _e.mock.On("DetachVolume",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DetachVolume_Call) Run(run func(ctx context.Context, params *ec2.DetachVolumeInput, optFns ...func(*ec2.Options))) *EC2_DetachVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DetachVolumeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DetachVolume_Call) Return(_a0 *ec2.DetachVolumeOutput, _a1 error) *EC2_DetachVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DetachVolume_Call) RunAndReturn(run func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error)) *EC2_DetachVolume_Call {
	_c.Call.Return(run)
	return _c
}

// DetachVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachVpnGateway(ctx context.Context, params *ec2.DetachVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachVpnGateway")
	}

	var r0 *ec2.DetachVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) *ec2.DetachVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DetachVpnGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachVpnGateway'
type EC2_DetachVpnGateway_Call struct {
	*mock.Call
}

// DetachVpnGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DetachVpnGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DetachVpnGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DetachVpnGateway_Call {
	return &EC2_DetachVpnGateway_Call{Call: _e.mock.On("DetachVpnGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DetachVpnGateway_Call) Run(run func(ctx context.Context, params *ec2.DetachVpnGatewayInput, optFns ...func(*ec2.Options))) *EC2_DetachVpnGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DetachVpnGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DetachVpnGateway_Call) Return(_a0 *ec2.DetachVpnGatewayOutput, _a1 error) *EC2_DetachVpnGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DetachVpnGateway_Call) RunAndReturn(run func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error)) *EC2_DetachVpnGateway_Call {
	_c.Call.Return(run)
	return _c
}

// DisableEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableEbsEncryptionByDefault(ctx context.Context, params *ec2.DisableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableEbsEncryptionByDefault")
	}

	var r0 *ec2.DisableEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.DisableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableEbsEncryptionByDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableEbsEncryptionByDefault'
type EC2_DisableEbsEncryptionByDefault_Call struct {
	*mock.Call
}

// DisableEbsEncryptionByDefault is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableEbsEncryptionByDefaultInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableEbsEncryptionByDefault(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableEbsEncryptionByDefault_Call {
	return &EC2_DisableEbsEncryptionByDefault_Call{Call: _e.mock.On("DisableEbsEncryptionByDefault",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableEbsEncryptionByDefault_Call) Run(run func(ctx context.Context, params *ec2.DisableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options))) *EC2_DisableEbsEncryptionByDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableEbsEncryptionByDefaultInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableEbsEncryptionByDefault_Call) Return(_a0 *ec2.DisableEbsEncryptionByDefaultOutput, _a1 error) *EC2_DisableEbsEncryptionByDefault_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableEbsEncryptionByDefault_Call) RunAndReturn(run func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error)) *EC2_DisableEbsEncryptionByDefault_Call {
	_c.Call.Return(run)
	return _c
}

// DisableFastLaunch provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableFastLaunch(ctx context.Context, params *ec2.DisableFastLaunchInput, optFns ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableFastLaunch")
	}

	var r0 *ec2.DisableFastLaunchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) *ec2.DisableFastLaunchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastLaunchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableFastLaunch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableFastLaunch'
type EC2_DisableFastLaunch_Call struct {
	*mock.Call
}

// DisableFastLaunch is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableFastLaunchInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableFastLaunch(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableFastLaunch_Call {
	return &EC2_DisableFastLaunch_Call{Call: _e.mock.On("DisableFastLaunch",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableFastLaunch_Call) Run(run func(ctx context.Context, params *ec2.DisableFastLaunchInput, optFns ...func(*ec2.Options))) *EC2_DisableFastLaunch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableFastLaunchInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableFastLaunch_Call) Return(_a0 *ec2.DisableFastLaunchOutput, _a1 error) *EC2_DisableFastLaunch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableFastLaunch_Call) RunAndReturn(run func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error)) *EC2_DisableFastLaunch_Call {
	_c.Call.Return(run)
	return _c
}

// DisableFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableFastSnapshotRestores(ctx context.Context, params *ec2.DisableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableFastSnapshotRestores")
	}

	var r0 *ec2.DisableFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.DisableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableFastSnapshotRestores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableFastSnapshotRestores'
type EC2_DisableFastSnapshotRestores_Call struct {
	*mock.Call
}

// DisableFastSnapshotRestores is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableFastSnapshotRestoresInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableFastSnapshotRestores(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableFastSnapshotRestores_Call {
	return &EC2_DisableFastSnapshotRestores_Call{Call: _e.mock.On("DisableFastSnapshotRestores",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableFastSnapshotRestores_Call) Run(run func(ctx context.Context, params *ec2.DisableFastSnapshotRestoresInput, optFns ...func(*ec2.Options))) *EC2_DisableFastSnapshotRestores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableFastSnapshotRestoresInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableFastSnapshotRestores_Call) Return(_a0 *ec2.DisableFastSnapshotRestoresOutput, _a1 error) *EC2_DisableFastSnapshotRestores_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableFastSnapshotRestores_Call) RunAndReturn(run func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error)) *EC2_DisableFastSnapshotRestores_Call {
	_c.Call.Return(run)
	return _c
}

// DisableImageDeprecation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableImageDeprecation(ctx context.Context, params *ec2.DisableImageDeprecationInput, optFns ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableImageDeprecation")
	}

	var r0 *ec2.DisableImageDeprecationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) *ec2.DisableImageDeprecationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableImageDeprecationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableImageDeprecation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableImageDeprecation'
type EC2_DisableImageDeprecation_Call struct {
	*mock.Call
}

// DisableImageDeprecation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableImageDeprecationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableImageDeprecation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableImageDeprecation_Call {
	return &EC2_DisableImageDeprecation_Call{Call: _e.mock.On("DisableImageDeprecation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableImageDeprecation_Call) Run(run func(ctx context.Context, params *ec2.DisableImageDeprecationInput, optFns ...func(*ec2.Options))) *EC2_DisableImageDeprecation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableImageDeprecationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableImageDeprecation_Call) Return(_a0 *ec2.DisableImageDeprecationOutput, _a1 error) *EC2_DisableImageDeprecation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableImageDeprecation_Call) RunAndReturn(run func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error)) *EC2_DisableImageDeprecation_Call {
	_c.Call.Return(run)
	return _c
}

// DisableIpamOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableIpamOrganizationAdminAccount(ctx context.Context, params *ec2.DisableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableIpamOrganizationAdminAccount")
	}

	var r0 *ec2.DisableIpamOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) *ec2.DisableIpamOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableIpamOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableIpamOrganizationAdminAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableIpamOrganizationAdminAccount'
type EC2_DisableIpamOrganizationAdminAccount_Call struct {
	*mock.Call
}

// DisableIpamOrganizationAdminAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableIpamOrganizationAdminAccountInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableIpamOrganizationAdminAccount(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableIpamOrganizationAdminAccount_Call {
	return &EC2_DisableIpamOrganizationAdminAccount_Call{Call: _e.mock.On("DisableIpamOrganizationAdminAccount",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableIpamOrganizationAdminAccount_Call) Run(run func(ctx context.Context, params *ec2.DisableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options))) *EC2_DisableIpamOrganizationAdminAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableIpamOrganizationAdminAccountInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableIpamOrganizationAdminAccount_Call) Return(_a0 *ec2.DisableIpamOrganizationAdminAccountOutput, _a1 error) *EC2_DisableIpamOrganizationAdminAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableIpamOrganizationAdminAccount_Call) RunAndReturn(run func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error)) *EC2_DisableIpamOrganizationAdminAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DisableSerialConsoleAccess provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableSerialConsoleAccess(ctx context.Context, params *ec2.DisableSerialConsoleAccessInput, optFns ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableSerialConsoleAccess")
	}

	var r0 *ec2.DisableSerialConsoleAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) *ec2.DisableSerialConsoleAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableSerialConsoleAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableSerialConsoleAccess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableSerialConsoleAccess'
type EC2_DisableSerialConsoleAccess_Call struct {
	*mock.Call
}

// DisableSerialConsoleAccess is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableSerialConsoleAccessInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableSerialConsoleAccess(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableSerialConsoleAccess_Call {
	return &EC2_DisableSerialConsoleAccess_Call{Call: _e.mock.On("DisableSerialConsoleAccess",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableSerialConsoleAccess_Call) Run(run func(ctx context.Context, params *ec2.DisableSerialConsoleAccessInput, optFns ...func(*ec2.Options))) *EC2_DisableSerialConsoleAccess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableSerialConsoleAccessInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableSerialConsoleAccess_Call) Return(_a0 *ec2.DisableSerialConsoleAccessOutput, _a1 error) *EC2_DisableSerialConsoleAccess_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableSerialConsoleAccess_Call) RunAndReturn(run func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error)) *EC2_DisableSerialConsoleAccess_Call {
	_c.Call.Return(run)
	return _c
}

// DisableTransitGatewayRouteTablePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableTransitGatewayRouteTablePropagation(ctx context.Context, params *ec2.DisableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableTransitGatewayRouteTablePropagation")
	}

	var r0 *ec2.DisableTransitGatewayRouteTablePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) *ec2.DisableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableTransitGatewayRouteTablePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableTransitGatewayRouteTablePropagation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableTransitGatewayRouteTablePropagation'
type EC2_DisableTransitGatewayRouteTablePropagation_Call struct {
	*mock.Call
}

// DisableTransitGatewayRouteTablePropagation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableTransitGatewayRouteTablePropagationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableTransitGatewayRouteTablePropagation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableTransitGatewayRouteTablePropagation_Call {
	return &EC2_DisableTransitGatewayRouteTablePropagation_Call{Call: _e.mock.On("DisableTransitGatewayRouteTablePropagation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableTransitGatewayRouteTablePropagation_Call) Run(run func(ctx context.Context, params *ec2.DisableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options))) *EC2_DisableTransitGatewayRouteTablePropagation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableTransitGatewayRouteTablePropagationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableTransitGatewayRouteTablePropagation_Call) Return(_a0 *ec2.DisableTransitGatewayRouteTablePropagationOutput, _a1 error) *EC2_DisableTransitGatewayRouteTablePropagation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableTransitGatewayRouteTablePropagation_Call) RunAndReturn(run func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error)) *EC2_DisableTransitGatewayRouteTablePropagation_Call {
	_c.Call.Return(run)
	return _c
}

// DisableVgwRoutePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableVgwRoutePropagation(ctx context.Context, params *ec2.DisableVgwRoutePropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableVgwRoutePropagation")
	}

	var r0 *ec2.DisableVgwRoutePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) *ec2.DisableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVgwRoutePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableVgwRoutePropagation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableVgwRoutePropagation'
type EC2_DisableVgwRoutePropagation_Call struct {
	*mock.Call
}

// DisableVgwRoutePropagation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableVgwRoutePropagationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableVgwRoutePropagation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableVgwRoutePropagation_Call {
	return &EC2_DisableVgwRoutePropagation_Call{Call: _e.mock.On("DisableVgwRoutePropagation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableVgwRoutePropagation_Call) Run(run func(ctx context.Context, params *ec2.DisableVgwRoutePropagationInput, optFns ...func(*ec2.Options))) *EC2_DisableVgwRoutePropagation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableVgwRoutePropagationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableVgwRoutePropagation_Call) Return(_a0 *ec2.DisableVgwRoutePropagationOutput, _a1 error) *EC2_DisableVgwRoutePropagation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableVgwRoutePropagation_Call) RunAndReturn(run func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error)) *EC2_DisableVgwRoutePropagation_Call {
	_c.Call.Return(run)
	return _c
}

// DisableVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableVpcClassicLink(ctx context.Context, params *ec2.DisableVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableVpcClassicLink")
	}

	var r0 *ec2.DisableVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.DisableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableVpcClassicLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableVpcClassicLink'
type EC2_DisableVpcClassicLink_Call struct {
	*mock.Call
}

// DisableVpcClassicLink is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableVpcClassicLinkInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableVpcClassicLink(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableVpcClassicLink_Call {
	return &EC2_DisableVpcClassicLink_Call{Call: _e.mock.On("DisableVpcClassicLink",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableVpcClassicLink_Call) Run(run func(ctx context.Context, params *ec2.DisableVpcClassicLinkInput, optFns ...func(*ec2.Options))) *EC2_DisableVpcClassicLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableVpcClassicLinkInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableVpcClassicLink_Call) Return(_a0 *ec2.DisableVpcClassicLinkOutput, _a1 error) *EC2_DisableVpcClassicLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableVpcClassicLink_Call) RunAndReturn(run func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error)) *EC2_DisableVpcClassicLink_Call {
	_c.Call.Return(run)
	return _c
}

// DisableVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.DisableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableVpcClassicLinkDnsSupport")
	}

	var r0 *ec2.DisableVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.DisableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisableVpcClassicLinkDnsSupport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableVpcClassicLinkDnsSupport'
type EC2_DisableVpcClassicLinkDnsSupport_Call struct {
	*mock.Call
}

// DisableVpcClassicLinkDnsSupport is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisableVpcClassicLinkDnsSupportInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisableVpcClassicLinkDnsSupport(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisableVpcClassicLinkDnsSupport_Call {
	return &EC2_DisableVpcClassicLinkDnsSupport_Call{Call: _e.mock.On("DisableVpcClassicLinkDnsSupport",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisableVpcClassicLinkDnsSupport_Call) Run(run func(ctx context.Context, params *ec2.DisableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options))) *EC2_DisableVpcClassicLinkDnsSupport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisableVpcClassicLinkDnsSupportInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisableVpcClassicLinkDnsSupport_Call) Return(_a0 *ec2.DisableVpcClassicLinkDnsSupportOutput, _a1 error) *EC2_DisableVpcClassicLinkDnsSupport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisableVpcClassicLinkDnsSupport_Call) RunAndReturn(run func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error)) *EC2_DisableVpcClassicLinkDnsSupport_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateAddress(ctx context.Context, params *ec2.DisassociateAddressInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAddress")
	}

	var r0 *ec2.DisassociateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) *ec2.DisassociateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateAddress'
type EC2_DisassociateAddress_Call struct {
	*mock.Call
}

// DisassociateAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateAddressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateAddress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateAddress_Call {
	return &EC2_DisassociateAddress_Call{Call: _e.mock.On("DisassociateAddress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateAddress_Call) Run(run func(ctx context.Context, params *ec2.DisassociateAddressInput, optFns ...func(*ec2.Options))) *EC2_DisassociateAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateAddressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateAddress_Call) Return(_a0 *ec2.DisassociateAddressOutput, _a1 error) *EC2_DisassociateAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateAddress_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error)) *EC2_DisassociateAddress_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateClientVpnTargetNetwork(ctx context.Context, params *ec2.DisassociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateClientVpnTargetNetwork")
	}

	var r0 *ec2.DisassociateClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.DisassociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateClientVpnTargetNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateClientVpnTargetNetwork'
type EC2_DisassociateClientVpnTargetNetwork_Call struct {
	*mock.Call
}

// DisassociateClientVpnTargetNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateClientVpnTargetNetworkInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateClientVpnTargetNetwork(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateClientVpnTargetNetwork_Call {
	return &EC2_DisassociateClientVpnTargetNetwork_Call{Call: _e.mock.On("DisassociateClientVpnTargetNetwork",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateClientVpnTargetNetwork_Call) Run(run func(ctx context.Context, params *ec2.DisassociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options))) *EC2_DisassociateClientVpnTargetNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateClientVpnTargetNetworkInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateClientVpnTargetNetwork_Call) Return(_a0 *ec2.DisassociateClientVpnTargetNetworkOutput, _a1 error) *EC2_DisassociateClientVpnTargetNetwork_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateClientVpnTargetNetwork_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error)) *EC2_DisassociateClientVpnTargetNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateEnclaveCertificateIamRole provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateEnclaveCertificateIamRole(ctx context.Context, params *ec2.DisassociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateEnclaveCertificateIamRole")
	}

	var r0 *ec2.DisassociateEnclaveCertificateIamRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) *ec2.DisassociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateEnclaveCertificateIamRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateEnclaveCertificateIamRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateEnclaveCertificateIamRole'
type EC2_DisassociateEnclaveCertificateIamRole_Call struct {
	*mock.Call
}

// DisassociateEnclaveCertificateIamRole is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateEnclaveCertificateIamRoleInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateEnclaveCertificateIamRole(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateEnclaveCertificateIamRole_Call {
	return &EC2_DisassociateEnclaveCertificateIamRole_Call{Call: _e.mock.On("DisassociateEnclaveCertificateIamRole",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateEnclaveCertificateIamRole_Call) Run(run func(ctx context.Context, params *ec2.DisassociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options))) *EC2_DisassociateEnclaveCertificateIamRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateEnclaveCertificateIamRoleInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateEnclaveCertificateIamRole_Call) Return(_a0 *ec2.DisassociateEnclaveCertificateIamRoleOutput, _a1 error) *EC2_DisassociateEnclaveCertificateIamRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateEnclaveCertificateIamRole_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error)) *EC2_DisassociateEnclaveCertificateIamRole_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateIamInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateIamInstanceProfile(ctx context.Context, params *ec2.DisassociateIamInstanceProfileInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateIamInstanceProfile")
	}

	var r0 *ec2.DisassociateIamInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) *ec2.DisassociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateIamInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateIamInstanceProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateIamInstanceProfile'
type EC2_DisassociateIamInstanceProfile_Call struct {
	*mock.Call
}

// DisassociateIamInstanceProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateIamInstanceProfileInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateIamInstanceProfile(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateIamInstanceProfile_Call {
	return &EC2_DisassociateIamInstanceProfile_Call{Call: _e.mock.On("DisassociateIamInstanceProfile",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateIamInstanceProfile_Call) Run(run func(ctx context.Context, params *ec2.DisassociateIamInstanceProfileInput, optFns ...func(*ec2.Options))) *EC2_DisassociateIamInstanceProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateIamInstanceProfileInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateIamInstanceProfile_Call) Return(_a0 *ec2.DisassociateIamInstanceProfileOutput, _a1 error) *EC2_DisassociateIamInstanceProfile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateIamInstanceProfile_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error)) *EC2_DisassociateIamInstanceProfile_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateInstanceEventWindow(ctx context.Context, params *ec2.DisassociateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateInstanceEventWindow")
	}

	var r0 *ec2.DisassociateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.DisassociateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateInstanceEventWindow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateInstanceEventWindow'
type EC2_DisassociateInstanceEventWindow_Call struct {
	*mock.Call
}

// DisassociateInstanceEventWindow is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateInstanceEventWindowInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateInstanceEventWindow(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateInstanceEventWindow_Call {
	return &EC2_DisassociateInstanceEventWindow_Call{Call: _e.mock.On("DisassociateInstanceEventWindow",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateInstanceEventWindow_Call) Run(run func(ctx context.Context, params *ec2.DisassociateInstanceEventWindowInput, optFns ...func(*ec2.Options))) *EC2_DisassociateInstanceEventWindow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateInstanceEventWindowInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateInstanceEventWindow_Call) Return(_a0 *ec2.DisassociateInstanceEventWindowOutput, _a1 error) *EC2_DisassociateInstanceEventWindow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateInstanceEventWindow_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error)) *EC2_DisassociateInstanceEventWindow_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateRouteTable(ctx context.Context, params *ec2.DisassociateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateRouteTable")
	}

	var r0 *ec2.DisassociateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) *ec2.DisassociateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateRouteTable'
type EC2_DisassociateRouteTable_Call struct {
	*mock.Call
}

// DisassociateRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateRouteTable_Call {
	return &EC2_DisassociateRouteTable_Call{Call: _e.mock.On("DisassociateRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateRouteTable_Call) Run(run func(ctx context.Context, params *ec2.DisassociateRouteTableInput, optFns ...func(*ec2.Options))) *EC2_DisassociateRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateRouteTable_Call) Return(_a0 *ec2.DisassociateRouteTableOutput, _a1 error) *EC2_DisassociateRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error)) *EC2_DisassociateRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateSubnetCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateSubnetCidrBlock(ctx context.Context, params *ec2.DisassociateSubnetCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateSubnetCidrBlock")
	}

	var r0 *ec2.DisassociateSubnetCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) *ec2.DisassociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateSubnetCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateSubnetCidrBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateSubnetCidrBlock'
type EC2_DisassociateSubnetCidrBlock_Call struct {
	*mock.Call
}

// DisassociateSubnetCidrBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateSubnetCidrBlockInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateSubnetCidrBlock(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateSubnetCidrBlock_Call {
	return &EC2_DisassociateSubnetCidrBlock_Call{Call: _e.mock.On("DisassociateSubnetCidrBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateSubnetCidrBlock_Call) Run(run func(ctx context.Context, params *ec2.DisassociateSubnetCidrBlockInput, optFns ...func(*ec2.Options))) *EC2_DisassociateSubnetCidrBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateSubnetCidrBlockInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateSubnetCidrBlock_Call) Return(_a0 *ec2.DisassociateSubnetCidrBlockOutput, _a1 error) *EC2_DisassociateSubnetCidrBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateSubnetCidrBlock_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error)) *EC2_DisassociateSubnetCidrBlock_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.DisassociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTransitGatewayMulticastDomain")
	}

	var r0 *ec2.DisassociateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateTransitGatewayMulticastDomain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateTransitGatewayMulticastDomain'
type EC2_DisassociateTransitGatewayMulticastDomain_Call struct {
	*mock.Call
}

// DisassociateTransitGatewayMulticastDomain is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateTransitGatewayMulticastDomainInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateTransitGatewayMulticastDomain(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateTransitGatewayMulticastDomain_Call {
	return &EC2_DisassociateTransitGatewayMulticastDomain_Call{Call: _e.mock.On("DisassociateTransitGatewayMulticastDomain",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateTransitGatewayMulticastDomain_Call) Run(run func(ctx context.Context, params *ec2.DisassociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options))) *EC2_DisassociateTransitGatewayMulticastDomain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateTransitGatewayMulticastDomainInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateTransitGatewayMulticastDomain_Call) Return(_a0 *ec2.DisassociateTransitGatewayMulticastDomainOutput, _a1 error) *EC2_DisassociateTransitGatewayMulticastDomain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateTransitGatewayMulticastDomain_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error)) *EC2_DisassociateTransitGatewayMulticastDomain_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateTransitGatewayRouteTable(ctx context.Context, params *ec2.DisassociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTransitGatewayRouteTable")
	}

	var r0 *ec2.DisassociateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateTransitGatewayRouteTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateTransitGatewayRouteTable'
type EC2_DisassociateTransitGatewayRouteTable_Call struct {
	*mock.Call
}

// DisassociateTransitGatewayRouteTable is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateTransitGatewayRouteTableInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateTransitGatewayRouteTable(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateTransitGatewayRouteTable_Call {
	return &EC2_DisassociateTransitGatewayRouteTable_Call{Call: _e.mock.On("DisassociateTransitGatewayRouteTable",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateTransitGatewayRouteTable_Call) Run(run func(ctx context.Context, params *ec2.DisassociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options))) *EC2_DisassociateTransitGatewayRouteTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateTransitGatewayRouteTableInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateTransitGatewayRouteTable_Call) Return(_a0 *ec2.DisassociateTransitGatewayRouteTableOutput, _a1 error) *EC2_DisassociateTransitGatewayRouteTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateTransitGatewayRouteTable_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error)) *EC2_DisassociateTransitGatewayRouteTable_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateTrunkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateTrunkInterface(ctx context.Context, params *ec2.DisassociateTrunkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateTrunkInterface")
	}

	var r0 *ec2.DisassociateTrunkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) *ec2.DisassociateTrunkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTrunkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateTrunkInterface_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateTrunkInterface'
type EC2_DisassociateTrunkInterface_Call struct {
	*mock.Call
}

// DisassociateTrunkInterface is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateTrunkInterfaceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateTrunkInterface(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateTrunkInterface_Call {
	return &EC2_DisassociateTrunkInterface_Call{Call: _e.mock.On("DisassociateTrunkInterface",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateTrunkInterface_Call) Run(run func(ctx context.Context, params *ec2.DisassociateTrunkInterfaceInput, optFns ...func(*ec2.Options))) *EC2_DisassociateTrunkInterface_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateTrunkInterfaceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateTrunkInterface_Call) Return(_a0 *ec2.DisassociateTrunkInterfaceOutput, _a1 error) *EC2_DisassociateTrunkInterface_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateTrunkInterface_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error)) *EC2_DisassociateTrunkInterface_Call {
	_c.Call.Return(run)
	return _c
}

// DisassociateVpcCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateVpcCidrBlock(ctx context.Context, params *ec2.DisassociateVpcCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateVpcCidrBlock")
	}

	var r0 *ec2.DisassociateVpcCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) *ec2.DisassociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateVpcCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_DisassociateVpcCidrBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisassociateVpcCidrBlock'
type EC2_DisassociateVpcCidrBlock_Call struct {
	*mock.Call
}

// DisassociateVpcCidrBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DisassociateVpcCidrBlockInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) DisassociateVpcCidrBlock(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_DisassociateVpcCidrBlock_Call {
	return &EC2_DisassociateVpcCidrBlock_Call{Call: _e.mock.On("DisassociateVpcCidrBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_DisassociateVpcCidrBlock_Call) Run(run func(ctx context.Context, params *ec2.DisassociateVpcCidrBlockInput, optFns ...func(*ec2.Options))) *EC2_DisassociateVpcCidrBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DisassociateVpcCidrBlockInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_DisassociateVpcCidrBlock_Call) Return(_a0 *ec2.DisassociateVpcCidrBlockOutput, _a1 error) *EC2_DisassociateVpcCidrBlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_DisassociateVpcCidrBlock_Call) RunAndReturn(run func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error)) *EC2_DisassociateVpcCidrBlock_Call {
	_c.Call.Return(run)
	return _c
}

// EnableEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableEbsEncryptionByDefault(ctx context.Context, params *ec2.EnableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableEbsEncryptionByDefault")
	}

	var r0 *ec2.EnableEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.EnableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableEbsEncryptionByDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableEbsEncryptionByDefault'
type EC2_EnableEbsEncryptionByDefault_Call struct {
	*mock.Call
}

// EnableEbsEncryptionByDefault is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableEbsEncryptionByDefaultInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableEbsEncryptionByDefault(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableEbsEncryptionByDefault_Call {
	return &EC2_EnableEbsEncryptionByDefault_Call{Call: _e.mock.On("EnableEbsEncryptionByDefault",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableEbsEncryptionByDefault_Call) Run(run func(ctx context.Context, params *ec2.EnableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options))) *EC2_EnableEbsEncryptionByDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableEbsEncryptionByDefaultInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableEbsEncryptionByDefault_Call) Return(_a0 *ec2.EnableEbsEncryptionByDefaultOutput, _a1 error) *EC2_EnableEbsEncryptionByDefault_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableEbsEncryptionByDefault_Call) RunAndReturn(run func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error)) *EC2_EnableEbsEncryptionByDefault_Call {
	_c.Call.Return(run)
	return _c
}

// EnableFastLaunch provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableFastLaunch(ctx context.Context, params *ec2.EnableFastLaunchInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableFastLaunch")
	}

	var r0 *ec2.EnableFastLaunchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) *ec2.EnableFastLaunchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastLaunchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableFastLaunch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableFastLaunch'
type EC2_EnableFastLaunch_Call struct {
	*mock.Call
}

// EnableFastLaunch is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableFastLaunchInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableFastLaunch(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableFastLaunch_Call {
	return &EC2_EnableFastLaunch_Call{Call: _e.mock.On("EnableFastLaunch",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableFastLaunch_Call) Run(run func(ctx context.Context, params *ec2.EnableFastLaunchInput, optFns ...func(*ec2.Options))) *EC2_EnableFastLaunch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableFastLaunchInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableFastLaunch_Call) Return(_a0 *ec2.EnableFastLaunchOutput, _a1 error) *EC2_EnableFastLaunch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableFastLaunch_Call) RunAndReturn(run func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error)) *EC2_EnableFastLaunch_Call {
	_c.Call.Return(run)
	return _c
}

// EnableFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableFastSnapshotRestores(ctx context.Context, params *ec2.EnableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableFastSnapshotRestores")
	}

	var r0 *ec2.EnableFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.EnableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableFastSnapshotRestores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableFastSnapshotRestores'
type EC2_EnableFastSnapshotRestores_Call struct {
	*mock.Call
}

// EnableFastSnapshotRestores is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableFastSnapshotRestoresInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableFastSnapshotRestores(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableFastSnapshotRestores_Call {
	return &EC2_EnableFastSnapshotRestores_Call{Call: _e.mock.On("EnableFastSnapshotRestores",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableFastSnapshotRestores_Call) Run(run func(ctx context.Context, params *ec2.EnableFastSnapshotRestoresInput, optFns ...func(*ec2.Options))) *EC2_EnableFastSnapshotRestores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableFastSnapshotRestoresInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableFastSnapshotRestores_Call) Return(_a0 *ec2.EnableFastSnapshotRestoresOutput, _a1 error) *EC2_EnableFastSnapshotRestores_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableFastSnapshotRestores_Call) RunAndReturn(run func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error)) *EC2_EnableFastSnapshotRestores_Call {
	_c.Call.Return(run)
	return _c
}

// EnableImageDeprecation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableImageDeprecation(ctx context.Context, params *ec2.EnableImageDeprecationInput, optFns ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableImageDeprecation")
	}

	var r0 *ec2.EnableImageDeprecationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) *ec2.EnableImageDeprecationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableImageDeprecationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableImageDeprecation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableImageDeprecation'
type EC2_EnableImageDeprecation_Call struct {
	*mock.Call
}

// EnableImageDeprecation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableImageDeprecationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableImageDeprecation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableImageDeprecation_Call {
	return &EC2_EnableImageDeprecation_Call{Call: _e.mock.On("EnableImageDeprecation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableImageDeprecation_Call) Run(run func(ctx context.Context, params *ec2.EnableImageDeprecationInput, optFns ...func(*ec2.Options))) *EC2_EnableImageDeprecation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableImageDeprecationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableImageDeprecation_Call) Return(_a0 *ec2.EnableImageDeprecationOutput, _a1 error) *EC2_EnableImageDeprecation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableImageDeprecation_Call) RunAndReturn(run func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error)) *EC2_EnableImageDeprecation_Call {
	_c.Call.Return(run)
	return _c
}

// EnableIpamOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableIpamOrganizationAdminAccount(ctx context.Context, params *ec2.EnableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableIpamOrganizationAdminAccount")
	}

	var r0 *ec2.EnableIpamOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) *ec2.EnableIpamOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableIpamOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableIpamOrganizationAdminAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableIpamOrganizationAdminAccount'
type EC2_EnableIpamOrganizationAdminAccount_Call struct {
	*mock.Call
}

// EnableIpamOrganizationAdminAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableIpamOrganizationAdminAccountInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableIpamOrganizationAdminAccount(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableIpamOrganizationAdminAccount_Call {
	return &EC2_EnableIpamOrganizationAdminAccount_Call{Call: _e.mock.On("EnableIpamOrganizationAdminAccount",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableIpamOrganizationAdminAccount_Call) Run(run func(ctx context.Context, params *ec2.EnableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options))) *EC2_EnableIpamOrganizationAdminAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableIpamOrganizationAdminAccountInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableIpamOrganizationAdminAccount_Call) Return(_a0 *ec2.EnableIpamOrganizationAdminAccountOutput, _a1 error) *EC2_EnableIpamOrganizationAdminAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableIpamOrganizationAdminAccount_Call) RunAndReturn(run func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error)) *EC2_EnableIpamOrganizationAdminAccount_Call {
	_c.Call.Return(run)
	return _c
}

// EnableSerialConsoleAccess provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableSerialConsoleAccess(ctx context.Context, params *ec2.EnableSerialConsoleAccessInput, optFns ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableSerialConsoleAccess")
	}

	var r0 *ec2.EnableSerialConsoleAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) *ec2.EnableSerialConsoleAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableSerialConsoleAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableSerialConsoleAccess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableSerialConsoleAccess'
type EC2_EnableSerialConsoleAccess_Call struct {
	*mock.Call
}

// EnableSerialConsoleAccess is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableSerialConsoleAccessInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableSerialConsoleAccess(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableSerialConsoleAccess_Call {
	return &EC2_EnableSerialConsoleAccess_Call{Call: _e.mock.On("EnableSerialConsoleAccess",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableSerialConsoleAccess_Call) Run(run func(ctx context.Context, params *ec2.EnableSerialConsoleAccessInput, optFns ...func(*ec2.Options))) *EC2_EnableSerialConsoleAccess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableSerialConsoleAccessInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableSerialConsoleAccess_Call) Return(_a0 *ec2.EnableSerialConsoleAccessOutput, _a1 error) *EC2_EnableSerialConsoleAccess_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableSerialConsoleAccess_Call) RunAndReturn(run func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error)) *EC2_EnableSerialConsoleAccess_Call {
	_c.Call.Return(run)
	return _c
}

// EnableTransitGatewayRouteTablePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableTransitGatewayRouteTablePropagation(ctx context.Context, params *ec2.EnableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableTransitGatewayRouteTablePropagation")
	}

	var r0 *ec2.EnableTransitGatewayRouteTablePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) *ec2.EnableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableTransitGatewayRouteTablePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableTransitGatewayRouteTablePropagation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableTransitGatewayRouteTablePropagation'
type EC2_EnableTransitGatewayRouteTablePropagation_Call struct {
	*mock.Call
}

// EnableTransitGatewayRouteTablePropagation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableTransitGatewayRouteTablePropagationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableTransitGatewayRouteTablePropagation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableTransitGatewayRouteTablePropagation_Call {
	return &EC2_EnableTransitGatewayRouteTablePropagation_Call{Call: _e.mock.On("EnableTransitGatewayRouteTablePropagation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableTransitGatewayRouteTablePropagation_Call) Run(run func(ctx context.Context, params *ec2.EnableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options))) *EC2_EnableTransitGatewayRouteTablePropagation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableTransitGatewayRouteTablePropagationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableTransitGatewayRouteTablePropagation_Call) Return(_a0 *ec2.EnableTransitGatewayRouteTablePropagationOutput, _a1 error) *EC2_EnableTransitGatewayRouteTablePropagation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableTransitGatewayRouteTablePropagation_Call) RunAndReturn(run func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error)) *EC2_EnableTransitGatewayRouteTablePropagation_Call {
	_c.Call.Return(run)
	return _c
}

// EnableVgwRoutePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVgwRoutePropagation(ctx context.Context, params *ec2.EnableVgwRoutePropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVgwRoutePropagation")
	}

	var r0 *ec2.EnableVgwRoutePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) *ec2.EnableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVgwRoutePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableVgwRoutePropagation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableVgwRoutePropagation'
type EC2_EnableVgwRoutePropagation_Call struct {
	*mock.Call
}

// EnableVgwRoutePropagation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableVgwRoutePropagationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableVgwRoutePropagation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableVgwRoutePropagation_Call {
	return &EC2_EnableVgwRoutePropagation_Call{Call: _e.mock.On("EnableVgwRoutePropagation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableVgwRoutePropagation_Call) Run(run func(ctx context.Context, params *ec2.EnableVgwRoutePropagationInput, optFns ...func(*ec2.Options))) *EC2_EnableVgwRoutePropagation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableVgwRoutePropagationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableVgwRoutePropagation_Call) Return(_a0 *ec2.EnableVgwRoutePropagationOutput, _a1 error) *EC2_EnableVgwRoutePropagation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableVgwRoutePropagation_Call) RunAndReturn(run func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error)) *EC2_EnableVgwRoutePropagation_Call {
	_c.Call.Return(run)
	return _c
}

// EnableVolumeIO provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVolumeIO(ctx context.Context, params *ec2.EnableVolumeIOInput, optFns ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVolumeIO")
	}

	var r0 *ec2.EnableVolumeIOOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) *ec2.EnableVolumeIOOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVolumeIOOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableVolumeIO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableVolumeIO'
type EC2_EnableVolumeIO_Call struct {
	*mock.Call
}

// EnableVolumeIO is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableVolumeIOInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableVolumeIO(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableVolumeIO_Call {
	return &EC2_EnableVolumeIO_Call{Call: _e.mock.On("EnableVolumeIO",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableVolumeIO_Call) Run(run func(ctx context.Context, params *ec2.EnableVolumeIOInput, optFns ...func(*ec2.Options))) *EC2_EnableVolumeIO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableVolumeIOInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableVolumeIO_Call) Return(_a0 *ec2.EnableVolumeIOOutput, _a1 error) *EC2_EnableVolumeIO_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableVolumeIO_Call) RunAndReturn(run func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error)) *EC2_EnableVolumeIO_Call {
	_c.Call.Return(run)
	return _c
}

// EnableVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVpcClassicLink(ctx context.Context, params *ec2.EnableVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVpcClassicLink")
	}

	var r0 *ec2.EnableVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.EnableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableVpcClassicLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableVpcClassicLink'
type EC2_EnableVpcClassicLink_Call struct {
	*mock.Call
}

// EnableVpcClassicLink is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableVpcClassicLinkInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableVpcClassicLink(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableVpcClassicLink_Call {
	return &EC2_EnableVpcClassicLink_Call{Call: _e.mock.On("EnableVpcClassicLink",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableVpcClassicLink_Call) Run(run func(ctx context.Context, params *ec2.EnableVpcClassicLinkInput, optFns ...func(*ec2.Options))) *EC2_EnableVpcClassicLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableVpcClassicLinkInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableVpcClassicLink_Call) Return(_a0 *ec2.EnableVpcClassicLinkOutput, _a1 error) *EC2_EnableVpcClassicLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableVpcClassicLink_Call) RunAndReturn(run func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error)) *EC2_EnableVpcClassicLink_Call {
	_c.Call.Return(run)
	return _c
}

// EnableVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.EnableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableVpcClassicLinkDnsSupport")
	}

	var r0 *ec2.EnableVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.EnableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_EnableVpcClassicLinkDnsSupport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableVpcClassicLinkDnsSupport'
type EC2_EnableVpcClassicLinkDnsSupport_Call struct {
	*mock.Call
}

// EnableVpcClassicLinkDnsSupport is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.EnableVpcClassicLinkDnsSupportInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) EnableVpcClassicLinkDnsSupport(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_EnableVpcClassicLinkDnsSupport_Call {
	return &EC2_EnableVpcClassicLinkDnsSupport_Call{Call: _e.mock.On("EnableVpcClassicLinkDnsSupport",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_EnableVpcClassicLinkDnsSupport_Call) Run(run func(ctx context.Context, params *ec2.EnableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options))) *EC2_EnableVpcClassicLinkDnsSupport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.EnableVpcClassicLinkDnsSupportInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_EnableVpcClassicLinkDnsSupport_Call) Return(_a0 *ec2.EnableVpcClassicLinkDnsSupportOutput, _a1 error) *EC2_EnableVpcClassicLinkDnsSupport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_EnableVpcClassicLinkDnsSupport_Call) RunAndReturn(run func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error)) *EC2_EnableVpcClassicLinkDnsSupport_Call {
	_c.Call.Return(run)
	return _c
}

// ExportClientVpnClientCertificateRevocationList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportClientVpnClientCertificateRevocationList(ctx context.Context, params *ec2.ExportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportClientVpnClientCertificateRevocationList")
	}

	var r0 *ec2.ExportClientVpnClientCertificateRevocationListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) *ec2.ExportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientCertificateRevocationListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ExportClientVpnClientCertificateRevocationList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExportClientVpnClientCertificateRevocationList'
type EC2_ExportClientVpnClientCertificateRevocationList_Call struct {
	*mock.Call
}

// ExportClientVpnClientCertificateRevocationList is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ExportClientVpnClientCertificateRevocationListInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ExportClientVpnClientCertificateRevocationList(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ExportClientVpnClientCertificateRevocationList_Call {
	return &EC2_ExportClientVpnClientCertificateRevocationList_Call{Call: _e.mock.On("ExportClientVpnClientCertificateRevocationList",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ExportClientVpnClientCertificateRevocationList_Call) Run(run func(ctx context.Context, params *ec2.ExportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options))) *EC2_ExportClientVpnClientCertificateRevocationList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ExportClientVpnClientCertificateRevocationListInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ExportClientVpnClientCertificateRevocationList_Call) Return(_a0 *ec2.ExportClientVpnClientCertificateRevocationListOutput, _a1 error) *EC2_ExportClientVpnClientCertificateRevocationList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ExportClientVpnClientCertificateRevocationList_Call) RunAndReturn(run func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error)) *EC2_ExportClientVpnClientCertificateRevocationList_Call {
	_c.Call.Return(run)
	return _c
}

// ExportClientVpnClientConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportClientVpnClientConfiguration(ctx context.Context, params *ec2.ExportClientVpnClientConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportClientVpnClientConfiguration")
	}

	var r0 *ec2.ExportClientVpnClientConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) *ec2.ExportClientVpnClientConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ExportClientVpnClientConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExportClientVpnClientConfiguration'
type EC2_ExportClientVpnClientConfiguration_Call struct {
	*mock.Call
}

// ExportClientVpnClientConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ExportClientVpnClientConfigurationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ExportClientVpnClientConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ExportClientVpnClientConfiguration_Call {
	return &EC2_ExportClientVpnClientConfiguration_Call{Call: _e.mock.On("ExportClientVpnClientConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ExportClientVpnClientConfiguration_Call) Run(run func(ctx context.Context, params *ec2.ExportClientVpnClientConfigurationInput, optFns ...func(*ec2.Options))) *EC2_ExportClientVpnClientConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ExportClientVpnClientConfigurationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ExportClientVpnClientConfiguration_Call) Return(_a0 *ec2.ExportClientVpnClientConfigurationOutput, _a1 error) *EC2_ExportClientVpnClientConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ExportClientVpnClientConfiguration_Call) RunAndReturn(run func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error)) *EC2_ExportClientVpnClientConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// ExportImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportImage(ctx context.Context, params *ec2.ExportImageInput, optFns ...func(*ec2.Options)) (*ec2.ExportImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportImage")
	}

	var r0 *ec2.ExportImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) (*ec2.ExportImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) *ec2.ExportImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ExportImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExportImage'
type EC2_ExportImage_Call struct {
	*mock.Call
}

// ExportImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ExportImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ExportImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ExportImage_Call {
	return &EC2_ExportImage_Call{Call: _e.mock.On("ExportImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ExportImage_Call) Run(run func(ctx context.Context, params *ec2.ExportImageInput, optFns ...func(*ec2.Options))) *EC2_ExportImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ExportImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ExportImage_Call) Return(_a0 *ec2.ExportImageOutput, _a1 error) *EC2_ExportImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ExportImage_Call) RunAndReturn(run func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) (*ec2.ExportImageOutput, error)) *EC2_ExportImage_Call {
	_c.Call.Return(run)
	return _c
}

// ExportTransitGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportTransitGatewayRoutes(ctx context.Context, params *ec2.ExportTransitGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExportTransitGatewayRoutes")
	}

	var r0 *ec2.ExportTransitGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) *ec2.ExportTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportTransitGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ExportTransitGatewayRoutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExportTransitGatewayRoutes'
type EC2_ExportTransitGatewayRoutes_Call struct {
	*mock.Call
}

// ExportTransitGatewayRoutes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ExportTransitGatewayRoutesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ExportTransitGatewayRoutes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ExportTransitGatewayRoutes_Call {
	return &EC2_ExportTransitGatewayRoutes_Call{Call: _e.mock.On("ExportTransitGatewayRoutes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ExportTransitGatewayRoutes_Call) Run(run func(ctx context.Context, params *ec2.ExportTransitGatewayRoutesInput, optFns ...func(*ec2.Options))) *EC2_ExportTransitGatewayRoutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ExportTransitGatewayRoutesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ExportTransitGatewayRoutes_Call) Return(_a0 *ec2.ExportTransitGatewayRoutesOutput, _a1 error) *EC2_ExportTransitGatewayRoutes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ExportTransitGatewayRoutes_Call) RunAndReturn(run func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error)) *EC2_ExportTransitGatewayRoutes_Call {
	_c.Call.Return(run)
	return _c
}

// GetAssociatedEnclaveCertificateIamRoles provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetAssociatedEnclaveCertificateIamRoles(ctx context.Context, params *ec2.GetAssociatedEnclaveCertificateIamRolesInput, optFns ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssociatedEnclaveCertificateIamRoles")
	}

	var r0 *ec2.GetAssociatedEnclaveCertificateIamRolesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) *ec2.GetAssociatedEnclaveCertificateIamRolesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedEnclaveCertificateIamRolesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetAssociatedEnclaveCertificateIamRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAssociatedEnclaveCertificateIamRoles'
type EC2_GetAssociatedEnclaveCertificateIamRoles_Call struct {
	*mock.Call
}

// GetAssociatedEnclaveCertificateIamRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetAssociatedEnclaveCertificateIamRolesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetAssociatedEnclaveCertificateIamRoles(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetAssociatedEnclaveCertificateIamRoles_Call {
	return &EC2_GetAssociatedEnclaveCertificateIamRoles_Call{Call: _e.mock.On("GetAssociatedEnclaveCertificateIamRoles",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetAssociatedEnclaveCertificateIamRoles_Call) Run(run func(ctx context.Context, params *ec2.GetAssociatedEnclaveCertificateIamRolesInput, optFns ...func(*ec2.Options))) *EC2_GetAssociatedEnclaveCertificateIamRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetAssociatedEnclaveCertificateIamRolesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetAssociatedEnclaveCertificateIamRoles_Call) Return(_a0 *ec2.GetAssociatedEnclaveCertificateIamRolesOutput, _a1 error) *EC2_GetAssociatedEnclaveCertificateIamRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetAssociatedEnclaveCertificateIamRoles_Call) RunAndReturn(run func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error)) *EC2_GetAssociatedEnclaveCertificateIamRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetAssociatedIpv6PoolCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetAssociatedIpv6PoolCidrs(ctx context.Context, params *ec2.GetAssociatedIpv6PoolCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssociatedIpv6PoolCidrs")
	}

	var r0 *ec2.GetAssociatedIpv6PoolCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) *ec2.GetAssociatedIpv6PoolCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedIpv6PoolCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetAssociatedIpv6PoolCidrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAssociatedIpv6PoolCidrs'
type EC2_GetAssociatedIpv6PoolCidrs_Call struct {
	*mock.Call
}

// GetAssociatedIpv6PoolCidrs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetAssociatedIpv6PoolCidrsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetAssociatedIpv6PoolCidrs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetAssociatedIpv6PoolCidrs_Call {
	return &EC2_GetAssociatedIpv6PoolCidrs_Call{Call: _e.mock.On("GetAssociatedIpv6PoolCidrs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetAssociatedIpv6PoolCidrs_Call) Run(run func(ctx context.Context, params *ec2.GetAssociatedIpv6PoolCidrsInput, optFns ...func(*ec2.Options))) *EC2_GetAssociatedIpv6PoolCidrs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetAssociatedIpv6PoolCidrsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetAssociatedIpv6PoolCidrs_Call) Return(_a0 *ec2.GetAssociatedIpv6PoolCidrsOutput, _a1 error) *EC2_GetAssociatedIpv6PoolCidrs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetAssociatedIpv6PoolCidrs_Call) RunAndReturn(run func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error)) *EC2_GetAssociatedIpv6PoolCidrs_Call {
	_c.Call.Return(run)
	return _c
}

// GetCapacityReservationUsage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetCapacityReservationUsage(ctx context.Context, params *ec2.GetCapacityReservationUsageInput, optFns ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCapacityReservationUsage")
	}

	var r0 *ec2.GetCapacityReservationUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) *ec2.GetCapacityReservationUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityReservationUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetCapacityReservationUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCapacityReservationUsage'
type EC2_GetCapacityReservationUsage_Call struct {
	*mock.Call
}

// GetCapacityReservationUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetCapacityReservationUsageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetCapacityReservationUsage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetCapacityReservationUsage_Call {
	return &EC2_GetCapacityReservationUsage_Call{Call: _e.mock.On("GetCapacityReservationUsage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetCapacityReservationUsage_Call) Run(run func(ctx context.Context, params *ec2.GetCapacityReservationUsageInput, optFns ...func(*ec2.Options))) *EC2_GetCapacityReservationUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetCapacityReservationUsageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetCapacityReservationUsage_Call) Return(_a0 *ec2.GetCapacityReservationUsageOutput, _a1 error) *EC2_GetCapacityReservationUsage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetCapacityReservationUsage_Call) RunAndReturn(run func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error)) *EC2_GetCapacityReservationUsage_Call {
	_c.Call.Return(run)
	return _c
}

// GetCoipPoolUsage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetCoipPoolUsage(ctx context.Context, params *ec2.GetCoipPoolUsageInput, optFns ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCoipPoolUsage")
	}

	var r0 *ec2.GetCoipPoolUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) *ec2.GetCoipPoolUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCoipPoolUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetCoipPoolUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCoipPoolUsage'
type EC2_GetCoipPoolUsage_Call struct {
	*mock.Call
}

// GetCoipPoolUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetCoipPoolUsageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetCoipPoolUsage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetCoipPoolUsage_Call {
	return &EC2_GetCoipPoolUsage_Call{Call: _e.mock.On("GetCoipPoolUsage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetCoipPoolUsage_Call) Run(run func(ctx context.Context, params *ec2.GetCoipPoolUsageInput, optFns ...func(*ec2.Options))) *EC2_GetCoipPoolUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetCoipPoolUsageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetCoipPoolUsage_Call) Return(_a0 *ec2.GetCoipPoolUsageOutput, _a1 error) *EC2_GetCoipPoolUsage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetCoipPoolUsage_Call) RunAndReturn(run func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error)) *EC2_GetCoipPoolUsage_Call {
	_c.Call.Return(run)
	return _c
}

// GetConsoleOutput provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetConsoleOutput(ctx context.Context, params *ec2.GetConsoleOutputInput, optFns ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConsoleOutput")
	}

	var r0 *ec2.GetConsoleOutputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) *ec2.GetConsoleOutputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleOutputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetConsoleOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConsoleOutput'
type EC2_GetConsoleOutput_Call struct {
	*mock.Call
}

// GetConsoleOutput is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetConsoleOutputInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetConsoleOutput(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetConsoleOutput_Call {
	return &EC2_GetConsoleOutput_Call{Call: _e.mock.On("GetConsoleOutput",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetConsoleOutput_Call) Run(run func(ctx context.Context, params *ec2.GetConsoleOutputInput, optFns ...func(*ec2.Options))) *EC2_GetConsoleOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetConsoleOutputInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetConsoleOutput_Call) Return(_a0 *ec2.GetConsoleOutputOutput, _a1 error) *EC2_GetConsoleOutput_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetConsoleOutput_Call) RunAndReturn(run func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error)) *EC2_GetConsoleOutput_Call {
	_c.Call.Return(run)
	return _c
}

// GetConsoleScreenshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetConsoleScreenshot(ctx context.Context, params *ec2.GetConsoleScreenshotInput, optFns ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConsoleScreenshot")
	}

	var r0 *ec2.GetConsoleScreenshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) *ec2.GetConsoleScreenshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleScreenshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetConsoleScreenshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConsoleScreenshot'
type EC2_GetConsoleScreenshot_Call struct {
	*mock.Call
}

// GetConsoleScreenshot is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetConsoleScreenshotInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetConsoleScreenshot(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetConsoleScreenshot_Call {
	return &EC2_GetConsoleScreenshot_Call{Call: _e.mock.On("GetConsoleScreenshot",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetConsoleScreenshot_Call) Run(run func(ctx context.Context, params *ec2.GetConsoleScreenshotInput, optFns ...func(*ec2.Options))) *EC2_GetConsoleScreenshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetConsoleScreenshotInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetConsoleScreenshot_Call) Return(_a0 *ec2.GetConsoleScreenshotOutput, _a1 error) *EC2_GetConsoleScreenshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetConsoleScreenshot_Call) RunAndReturn(run func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error)) *EC2_GetConsoleScreenshot_Call {
	_c.Call.Return(run)
	return _c
}

// GetDefaultCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetDefaultCreditSpecification(ctx context.Context, params *ec2.GetDefaultCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDefaultCreditSpecification")
	}

	var r0 *ec2.GetDefaultCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) *ec2.GetDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetDefaultCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetDefaultCreditSpecification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultCreditSpecification'
type EC2_GetDefaultCreditSpecification_Call struct {
	*mock.Call
}

// GetDefaultCreditSpecification is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetDefaultCreditSpecificationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetDefaultCreditSpecification(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetDefaultCreditSpecification_Call {
	return &EC2_GetDefaultCreditSpecification_Call{Call: _e.mock.On("GetDefaultCreditSpecification",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetDefaultCreditSpecification_Call) Run(run func(ctx context.Context, params *ec2.GetDefaultCreditSpecificationInput, optFns ...func(*ec2.Options))) *EC2_GetDefaultCreditSpecification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetDefaultCreditSpecificationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetDefaultCreditSpecification_Call) Return(_a0 *ec2.GetDefaultCreditSpecificationOutput, _a1 error) *EC2_GetDefaultCreditSpecification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetDefaultCreditSpecification_Call) RunAndReturn(run func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error)) *EC2_GetDefaultCreditSpecification_Call {
	_c.Call.Return(run)
	return _c
}

// GetEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetEbsDefaultKmsKeyId(ctx context.Context, params *ec2.GetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEbsDefaultKmsKeyId")
	}

	var r0 *ec2.GetEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.GetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetEbsDefaultKmsKeyId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEbsDefaultKmsKeyId'
type EC2_GetEbsDefaultKmsKeyId_Call struct {
	*mock.Call
}

// GetEbsDefaultKmsKeyId is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetEbsDefaultKmsKeyIdInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetEbsDefaultKmsKeyId(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetEbsDefaultKmsKeyId_Call {
	return &EC2_GetEbsDefaultKmsKeyId_Call{Call: _e.mock.On("GetEbsDefaultKmsKeyId",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetEbsDefaultKmsKeyId_Call) Run(run func(ctx context.Context, params *ec2.GetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options))) *EC2_GetEbsDefaultKmsKeyId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetEbsDefaultKmsKeyIdInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetEbsDefaultKmsKeyId_Call) Return(_a0 *ec2.GetEbsDefaultKmsKeyIdOutput, _a1 error) *EC2_GetEbsDefaultKmsKeyId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetEbsDefaultKmsKeyId_Call) RunAndReturn(run func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error)) *EC2_GetEbsDefaultKmsKeyId_Call {
	_c.Call.Return(run)
	return _c
}

// GetEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetEbsEncryptionByDefault(ctx context.Context, params *ec2.GetEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEbsEncryptionByDefault")
	}

	var r0 *ec2.GetEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.GetEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetEbsEncryptionByDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEbsEncryptionByDefault'
type EC2_GetEbsEncryptionByDefault_Call struct {
	*mock.Call
}

// GetEbsEncryptionByDefault is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetEbsEncryptionByDefaultInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetEbsEncryptionByDefault(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetEbsEncryptionByDefault_Call {
	return &EC2_GetEbsEncryptionByDefault_Call{Call: _e.mock.On("GetEbsEncryptionByDefault",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetEbsEncryptionByDefault_Call) Run(run func(ctx context.Context, params *ec2.GetEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options))) *EC2_GetEbsEncryptionByDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetEbsEncryptionByDefaultInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetEbsEncryptionByDefault_Call) Return(_a0 *ec2.GetEbsEncryptionByDefaultOutput, _a1 error) *EC2_GetEbsEncryptionByDefault_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetEbsEncryptionByDefault_Call) RunAndReturn(run func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error)) *EC2_GetEbsEncryptionByDefault_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlowLogsIntegrationTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetFlowLogsIntegrationTemplate(ctx context.Context, params *ec2.GetFlowLogsIntegrationTemplateInput, optFns ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFlowLogsIntegrationTemplate")
	}

	var r0 *ec2.GetFlowLogsIntegrationTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) *ec2.GetFlowLogsIntegrationTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetFlowLogsIntegrationTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetFlowLogsIntegrationTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlowLogsIntegrationTemplate'
type EC2_GetFlowLogsIntegrationTemplate_Call struct {
	*mock.Call
}

// GetFlowLogsIntegrationTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetFlowLogsIntegrationTemplateInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetFlowLogsIntegrationTemplate(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetFlowLogsIntegrationTemplate_Call {
	return &EC2_GetFlowLogsIntegrationTemplate_Call{Call: _e.mock.On("GetFlowLogsIntegrationTemplate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetFlowLogsIntegrationTemplate_Call) Run(run func(ctx context.Context, params *ec2.GetFlowLogsIntegrationTemplateInput, optFns ...func(*ec2.Options))) *EC2_GetFlowLogsIntegrationTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetFlowLogsIntegrationTemplateInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetFlowLogsIntegrationTemplate_Call) Return(_a0 *ec2.GetFlowLogsIntegrationTemplateOutput, _a1 error) *EC2_GetFlowLogsIntegrationTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetFlowLogsIntegrationTemplate_Call) RunAndReturn(run func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error)) *EC2_GetFlowLogsIntegrationTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupsForCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetGroupsForCapacityReservation(ctx context.Context, params *ec2.GetGroupsForCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupsForCapacityReservation")
	}

	var r0 *ec2.GetGroupsForCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) *ec2.GetGroupsForCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetGroupsForCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetGroupsForCapacityReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupsForCapacityReservation'
type EC2_GetGroupsForCapacityReservation_Call struct {
	*mock.Call
}

// GetGroupsForCapacityReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetGroupsForCapacityReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetGroupsForCapacityReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetGroupsForCapacityReservation_Call {
	return &EC2_GetGroupsForCapacityReservation_Call{Call: _e.mock.On("GetGroupsForCapacityReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetGroupsForCapacityReservation_Call) Run(run func(ctx context.Context, params *ec2.GetGroupsForCapacityReservationInput, optFns ...func(*ec2.Options))) *EC2_GetGroupsForCapacityReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetGroupsForCapacityReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetGroupsForCapacityReservation_Call) Return(_a0 *ec2.GetGroupsForCapacityReservationOutput, _a1 error) *EC2_GetGroupsForCapacityReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetGroupsForCapacityReservation_Call) RunAndReturn(run func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error)) *EC2_GetGroupsForCapacityReservation_Call {
	_c.Call.Return(run)
	return _c
}

// GetHostReservationPurchasePreview provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetHostReservationPurchasePreview(ctx context.Context, params *ec2.GetHostReservationPurchasePreviewInput, optFns ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHostReservationPurchasePreview")
	}

	var r0 *ec2.GetHostReservationPurchasePreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) *ec2.GetHostReservationPurchasePreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetHostReservationPurchasePreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetHostReservationPurchasePreview_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHostReservationPurchasePreview'
type EC2_GetHostReservationPurchasePreview_Call struct {
	*mock.Call
}

// GetHostReservationPurchasePreview is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetHostReservationPurchasePreviewInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetHostReservationPurchasePreview(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetHostReservationPurchasePreview_Call {
	return &EC2_GetHostReservationPurchasePreview_Call{Call: _e.mock.On("GetHostReservationPurchasePreview",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetHostReservationPurchasePreview_Call) Run(run func(ctx context.Context, params *ec2.GetHostReservationPurchasePreviewInput, optFns ...func(*ec2.Options))) *EC2_GetHostReservationPurchasePreview_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetHostReservationPurchasePreviewInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetHostReservationPurchasePreview_Call) Return(_a0 *ec2.GetHostReservationPurchasePreviewOutput, _a1 error) *EC2_GetHostReservationPurchasePreview_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetHostReservationPurchasePreview_Call) RunAndReturn(run func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error)) *EC2_GetHostReservationPurchasePreview_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstanceTypesFromInstanceRequirements provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetInstanceTypesFromInstanceRequirements(ctx context.Context, params *ec2.GetInstanceTypesFromInstanceRequirementsInput, optFns ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstanceTypesFromInstanceRequirements")
	}

	var r0 *ec2.GetInstanceTypesFromInstanceRequirementsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) *ec2.GetInstanceTypesFromInstanceRequirementsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetInstanceTypesFromInstanceRequirementsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetInstanceTypesFromInstanceRequirements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstanceTypesFromInstanceRequirements'
type EC2_GetInstanceTypesFromInstanceRequirements_Call struct {
	*mock.Call
}

// GetInstanceTypesFromInstanceRequirements is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetInstanceTypesFromInstanceRequirementsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetInstanceTypesFromInstanceRequirements(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetInstanceTypesFromInstanceRequirements_Call {
	return &EC2_GetInstanceTypesFromInstanceRequirements_Call{Call: _e.mock.On("GetInstanceTypesFromInstanceRequirements",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetInstanceTypesFromInstanceRequirements_Call) Run(run func(ctx context.Context, params *ec2.GetInstanceTypesFromInstanceRequirementsInput, optFns ...func(*ec2.Options))) *EC2_GetInstanceTypesFromInstanceRequirements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetInstanceTypesFromInstanceRequirementsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetInstanceTypesFromInstanceRequirements_Call) Return(_a0 *ec2.GetInstanceTypesFromInstanceRequirementsOutput, _a1 error) *EC2_GetInstanceTypesFromInstanceRequirements_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetInstanceTypesFromInstanceRequirements_Call) RunAndReturn(run func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error)) *EC2_GetInstanceTypesFromInstanceRequirements_Call {
	_c.Call.Return(run)
	return _c
}

// GetIpamAddressHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamAddressHistory(ctx context.Context, params *ec2.GetIpamAddressHistoryInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamAddressHistory")
	}

	var r0 *ec2.GetIpamAddressHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) *ec2.GetIpamAddressHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamAddressHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetIpamAddressHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIpamAddressHistory'
type EC2_GetIpamAddressHistory_Call struct {
	*mock.Call
}

// GetIpamAddressHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetIpamAddressHistoryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetIpamAddressHistory(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetIpamAddressHistory_Call {
	return &EC2_GetIpamAddressHistory_Call{Call: _e.mock.On("GetIpamAddressHistory",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetIpamAddressHistory_Call) Run(run func(ctx context.Context, params *ec2.GetIpamAddressHistoryInput, optFns ...func(*ec2.Options))) *EC2_GetIpamAddressHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetIpamAddressHistoryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetIpamAddressHistory_Call) Return(_a0 *ec2.GetIpamAddressHistoryOutput, _a1 error) *EC2_GetIpamAddressHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetIpamAddressHistory_Call) RunAndReturn(run func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error)) *EC2_GetIpamAddressHistory_Call {
	_c.Call.Return(run)
	return _c
}

// GetIpamPoolAllocations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamPoolAllocations(ctx context.Context, params *ec2.GetIpamPoolAllocationsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPoolAllocations")
	}

	var r0 *ec2.GetIpamPoolAllocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) *ec2.GetIpamPoolAllocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPoolAllocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetIpamPoolAllocations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIpamPoolAllocations'
type EC2_GetIpamPoolAllocations_Call struct {
	*mock.Call
}

// GetIpamPoolAllocations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetIpamPoolAllocationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetIpamPoolAllocations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetIpamPoolAllocations_Call {
	return &EC2_GetIpamPoolAllocations_Call{Call: _e.mock.On("GetIpamPoolAllocations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetIpamPoolAllocations_Call) Run(run func(ctx context.Context, params *ec2.GetIpamPoolAllocationsInput, optFns ...func(*ec2.Options))) *EC2_GetIpamPoolAllocations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetIpamPoolAllocationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetIpamPoolAllocations_Call) Return(_a0 *ec2.GetIpamPoolAllocationsOutput, _a1 error) *EC2_GetIpamPoolAllocations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetIpamPoolAllocations_Call) RunAndReturn(run func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error)) *EC2_GetIpamPoolAllocations_Call {
	_c.Call.Return(run)
	return _c
}

// GetIpamPoolCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamPoolCidrs(ctx context.Context, params *ec2.GetIpamPoolCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamPoolCidrs")
	}

	var r0 *ec2.GetIpamPoolCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamPoolCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPoolCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetIpamPoolCidrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIpamPoolCidrs'
type EC2_GetIpamPoolCidrs_Call struct {
	*mock.Call
}

// GetIpamPoolCidrs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetIpamPoolCidrsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetIpamPoolCidrs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetIpamPoolCidrs_Call {
	return &EC2_GetIpamPoolCidrs_Call{Call: _e.mock.On("GetIpamPoolCidrs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetIpamPoolCidrs_Call) Run(run func(ctx context.Context, params *ec2.GetIpamPoolCidrsInput, optFns ...func(*ec2.Options))) *EC2_GetIpamPoolCidrs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetIpamPoolCidrsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetIpamPoolCidrs_Call) Return(_a0 *ec2.GetIpamPoolCidrsOutput, _a1 error) *EC2_GetIpamPoolCidrs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetIpamPoolCidrs_Call) RunAndReturn(run func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error)) *EC2_GetIpamPoolCidrs_Call {
	_c.Call.Return(run)
	return _c
}

// GetIpamResourceCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamResourceCidrs(ctx context.Context, params *ec2.GetIpamResourceCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIpamResourceCidrs")
	}

	var r0 *ec2.GetIpamResourceCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamResourceCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamResourceCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetIpamResourceCidrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIpamResourceCidrs'
type EC2_GetIpamResourceCidrs_Call struct {
	*mock.Call
}

// GetIpamResourceCidrs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetIpamResourceCidrsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetIpamResourceCidrs(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetIpamResourceCidrs_Call {
	return &EC2_GetIpamResourceCidrs_Call{Call: _e.mock.On("GetIpamResourceCidrs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetIpamResourceCidrs_Call) Run(run func(ctx context.Context, params *ec2.GetIpamResourceCidrsInput, optFns ...func(*ec2.Options))) *EC2_GetIpamResourceCidrs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetIpamResourceCidrsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetIpamResourceCidrs_Call) Return(_a0 *ec2.GetIpamResourceCidrsOutput, _a1 error) *EC2_GetIpamResourceCidrs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetIpamResourceCidrs_Call) RunAndReturn(run func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error)) *EC2_GetIpamResourceCidrs_Call {
	_c.Call.Return(run)
	return _c
}

// GetLaunchTemplateData provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetLaunchTemplateData(ctx context.Context, params *ec2.GetLaunchTemplateDataInput, optFns ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLaunchTemplateData")
	}

	var r0 *ec2.GetLaunchTemplateDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) *ec2.GetLaunchTemplateDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetLaunchTemplateDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetLaunchTemplateData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLaunchTemplateData'
type EC2_GetLaunchTemplateData_Call struct {
	*mock.Call
}

// GetLaunchTemplateData is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetLaunchTemplateDataInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetLaunchTemplateData(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetLaunchTemplateData_Call {
	return &EC2_GetLaunchTemplateData_Call{Call: _e.mock.On("GetLaunchTemplateData",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetLaunchTemplateData_Call) Run(run func(ctx context.Context, params *ec2.GetLaunchTemplateDataInput, optFns ...func(*ec2.Options))) *EC2_GetLaunchTemplateData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetLaunchTemplateDataInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetLaunchTemplateData_Call) Return(_a0 *ec2.GetLaunchTemplateDataOutput, _a1 error) *EC2_GetLaunchTemplateData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetLaunchTemplateData_Call) RunAndReturn(run func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error)) *EC2_GetLaunchTemplateData_Call {
	_c.Call.Return(run)
	return _c
}

// GetManagedPrefixListAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetManagedPrefixListAssociations(ctx context.Context, params *ec2.GetManagedPrefixListAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedPrefixListAssociations")
	}

	var r0 *ec2.GetManagedPrefixListAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) *ec2.GetManagedPrefixListAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetManagedPrefixListAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManagedPrefixListAssociations'
type EC2_GetManagedPrefixListAssociations_Call struct {
	*mock.Call
}

// GetManagedPrefixListAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetManagedPrefixListAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetManagedPrefixListAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetManagedPrefixListAssociations_Call {
	return &EC2_GetManagedPrefixListAssociations_Call{Call: _e.mock.On("GetManagedPrefixListAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetManagedPrefixListAssociations_Call) Run(run func(ctx context.Context, params *ec2.GetManagedPrefixListAssociationsInput, optFns ...func(*ec2.Options))) *EC2_GetManagedPrefixListAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetManagedPrefixListAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetManagedPrefixListAssociations_Call) Return(_a0 *ec2.GetManagedPrefixListAssociationsOutput, _a1 error) *EC2_GetManagedPrefixListAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetManagedPrefixListAssociations_Call) RunAndReturn(run func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error)) *EC2_GetManagedPrefixListAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// GetManagedPrefixListEntries provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetManagedPrefixListEntries(ctx context.Context, params *ec2.GetManagedPrefixListEntriesInput, optFns ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetManagedPrefixListEntries")
	}

	var r0 *ec2.GetManagedPrefixListEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) *ec2.GetManagedPrefixListEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetManagedPrefixListEntries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManagedPrefixListEntries'
type EC2_GetManagedPrefixListEntries_Call struct {
	*mock.Call
}

// GetManagedPrefixListEntries is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetManagedPrefixListEntriesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetManagedPrefixListEntries(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetManagedPrefixListEntries_Call {
	return &EC2_GetManagedPrefixListEntries_Call{Call: _e.mock.On("GetManagedPrefixListEntries",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetManagedPrefixListEntries_Call) Run(run func(ctx context.Context, params *ec2.GetManagedPrefixListEntriesInput, optFns ...func(*ec2.Options))) *EC2_GetManagedPrefixListEntries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetManagedPrefixListEntriesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetManagedPrefixListEntries_Call) Return(_a0 *ec2.GetManagedPrefixListEntriesOutput, _a1 error) *EC2_GetManagedPrefixListEntries_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetManagedPrefixListEntries_Call) RunAndReturn(run func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error)) *EC2_GetManagedPrefixListEntries_Call {
	_c.Call.Return(run)
	return _c
}

// GetNetworkInsightsAccessScopeAnalysisFindings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetNetworkInsightsAccessScopeAnalysisFindings(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, optFns ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkInsightsAccessScopeAnalysisFindings")
	}

	var r0 *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNetworkInsightsAccessScopeAnalysisFindings'
type EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call struct {
	*mock.Call
}

// GetNetworkInsightsAccessScopeAnalysisFindings is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetNetworkInsightsAccessScopeAnalysisFindings(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call {
	return &EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call{Call: _e.mock.On("GetNetworkInsightsAccessScopeAnalysisFindings",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call) Run(run func(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, optFns ...func(*ec2.Options))) *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call) Return(_a0 *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, _a1 error) *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call) RunAndReturn(run func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error)) *EC2_GetNetworkInsightsAccessScopeAnalysisFindings_Call {
	_c.Call.Return(run)
	return _c
}

// GetNetworkInsightsAccessScopeContent provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetNetworkInsightsAccessScopeContent(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeContentInput, optFns ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkInsightsAccessScopeContent")
	}

	var r0 *ec2.GetNetworkInsightsAccessScopeContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) *ec2.GetNetworkInsightsAccessScopeContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetNetworkInsightsAccessScopeContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetNetworkInsightsAccessScopeContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNetworkInsightsAccessScopeContent'
type EC2_GetNetworkInsightsAccessScopeContent_Call struct {
	*mock.Call
}

// GetNetworkInsightsAccessScopeContent is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetNetworkInsightsAccessScopeContentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetNetworkInsightsAccessScopeContent(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetNetworkInsightsAccessScopeContent_Call {
	return &EC2_GetNetworkInsightsAccessScopeContent_Call{Call: _e.mock.On("GetNetworkInsightsAccessScopeContent",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetNetworkInsightsAccessScopeContent_Call) Run(run func(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeContentInput, optFns ...func(*ec2.Options))) *EC2_GetNetworkInsightsAccessScopeContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetNetworkInsightsAccessScopeContentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetNetworkInsightsAccessScopeContent_Call) Return(_a0 *ec2.GetNetworkInsightsAccessScopeContentOutput, _a1 error) *EC2_GetNetworkInsightsAccessScopeContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetNetworkInsightsAccessScopeContent_Call) RunAndReturn(run func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error)) *EC2_GetNetworkInsightsAccessScopeContent_Call {
	_c.Call.Return(run)
	return _c
}

// GetPasswordData provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetPasswordData(ctx context.Context, params *ec2.GetPasswordDataInput, optFns ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPasswordData")
	}

	var r0 *ec2.GetPasswordDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) *ec2.GetPasswordDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetPasswordDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetPasswordData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPasswordData'
type EC2_GetPasswordData_Call struct {
	*mock.Call
}

// GetPasswordData is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetPasswordDataInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetPasswordData(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetPasswordData_Call {
	return &EC2_GetPasswordData_Call{Call: _e.mock.On("GetPasswordData",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetPasswordData_Call) Run(run func(ctx context.Context, params *ec2.GetPasswordDataInput, optFns ...func(*ec2.Options))) *EC2_GetPasswordData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetPasswordDataInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetPasswordData_Call) Return(_a0 *ec2.GetPasswordDataOutput, _a1 error) *EC2_GetPasswordData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetPasswordData_Call) RunAndReturn(run func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error)) *EC2_GetPasswordData_Call {
	_c.Call.Return(run)
	return _c
}

// GetReservedInstancesExchangeQuote provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetReservedInstancesExchangeQuote(ctx context.Context, params *ec2.GetReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetReservedInstancesExchangeQuote")
	}

	var r0 *ec2.GetReservedInstancesExchangeQuoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) *ec2.GetReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetReservedInstancesExchangeQuoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetReservedInstancesExchangeQuote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReservedInstancesExchangeQuote'
type EC2_GetReservedInstancesExchangeQuote_Call struct {
	*mock.Call
}

// GetReservedInstancesExchangeQuote is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetReservedInstancesExchangeQuoteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetReservedInstancesExchangeQuote(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetReservedInstancesExchangeQuote_Call {
	return &EC2_GetReservedInstancesExchangeQuote_Call{Call: _e.mock.On("GetReservedInstancesExchangeQuote",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetReservedInstancesExchangeQuote_Call) Run(run func(ctx context.Context, params *ec2.GetReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options))) *EC2_GetReservedInstancesExchangeQuote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetReservedInstancesExchangeQuoteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetReservedInstancesExchangeQuote_Call) Return(_a0 *ec2.GetReservedInstancesExchangeQuoteOutput, _a1 error) *EC2_GetReservedInstancesExchangeQuote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetReservedInstancesExchangeQuote_Call) RunAndReturn(run func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error)) *EC2_GetReservedInstancesExchangeQuote_Call {
	_c.Call.Return(run)
	return _c
}

// GetSerialConsoleAccessStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetSerialConsoleAccessStatus(ctx context.Context, params *ec2.GetSerialConsoleAccessStatusInput, optFns ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSerialConsoleAccessStatus")
	}

	var r0 *ec2.GetSerialConsoleAccessStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) *ec2.GetSerialConsoleAccessStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSerialConsoleAccessStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetSerialConsoleAccessStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSerialConsoleAccessStatus'
type EC2_GetSerialConsoleAccessStatus_Call struct {
	*mock.Call
}

// GetSerialConsoleAccessStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetSerialConsoleAccessStatusInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetSerialConsoleAccessStatus(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetSerialConsoleAccessStatus_Call {
	return &EC2_GetSerialConsoleAccessStatus_Call{Call: _e.mock.On("GetSerialConsoleAccessStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetSerialConsoleAccessStatus_Call) Run(run func(ctx context.Context, params *ec2.GetSerialConsoleAccessStatusInput, optFns ...func(*ec2.Options))) *EC2_GetSerialConsoleAccessStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetSerialConsoleAccessStatusInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetSerialConsoleAccessStatus_Call) Return(_a0 *ec2.GetSerialConsoleAccessStatusOutput, _a1 error) *EC2_GetSerialConsoleAccessStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetSerialConsoleAccessStatus_Call) RunAndReturn(run func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error)) *EC2_GetSerialConsoleAccessStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetSpotPlacementScores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetSpotPlacementScores(ctx context.Context, params *ec2.GetSpotPlacementScoresInput, optFns ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSpotPlacementScores")
	}

	var r0 *ec2.GetSpotPlacementScoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) *ec2.GetSpotPlacementScoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSpotPlacementScoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetSpotPlacementScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSpotPlacementScores'
type EC2_GetSpotPlacementScores_Call struct {
	*mock.Call
}

// GetSpotPlacementScores is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetSpotPlacementScoresInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetSpotPlacementScores(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetSpotPlacementScores_Call {
	return &EC2_GetSpotPlacementScores_Call{Call: _e.mock.On("GetSpotPlacementScores",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetSpotPlacementScores_Call) Run(run func(ctx context.Context, params *ec2.GetSpotPlacementScoresInput, optFns ...func(*ec2.Options))) *EC2_GetSpotPlacementScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetSpotPlacementScoresInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetSpotPlacementScores_Call) Return(_a0 *ec2.GetSpotPlacementScoresOutput, _a1 error) *EC2_GetSpotPlacementScores_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetSpotPlacementScores_Call) RunAndReturn(run func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error)) *EC2_GetSpotPlacementScores_Call {
	_c.Call.Return(run)
	return _c
}

// GetSubnetCidrReservations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetSubnetCidrReservations(ctx context.Context, params *ec2.GetSubnetCidrReservationsInput, optFns ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSubnetCidrReservations")
	}

	var r0 *ec2.GetSubnetCidrReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) *ec2.GetSubnetCidrReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSubnetCidrReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetSubnetCidrReservations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSubnetCidrReservations'
type EC2_GetSubnetCidrReservations_Call struct {
	*mock.Call
}

// GetSubnetCidrReservations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetSubnetCidrReservationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetSubnetCidrReservations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetSubnetCidrReservations_Call {
	return &EC2_GetSubnetCidrReservations_Call{Call: _e.mock.On("GetSubnetCidrReservations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetSubnetCidrReservations_Call) Run(run func(ctx context.Context, params *ec2.GetSubnetCidrReservationsInput, optFns ...func(*ec2.Options))) *EC2_GetSubnetCidrReservations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetSubnetCidrReservationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetSubnetCidrReservations_Call) Return(_a0 *ec2.GetSubnetCidrReservationsOutput, _a1 error) *EC2_GetSubnetCidrReservations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetSubnetCidrReservations_Call) RunAndReturn(run func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error)) *EC2_GetSubnetCidrReservations_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransitGatewayAttachmentPropagations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayAttachmentPropagations(ctx context.Context, params *ec2.GetTransitGatewayAttachmentPropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayAttachmentPropagations")
	}

	var r0 *ec2.GetTransitGatewayAttachmentPropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayAttachmentPropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayAttachmentPropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetTransitGatewayAttachmentPropagations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransitGatewayAttachmentPropagations'
type EC2_GetTransitGatewayAttachmentPropagations_Call struct {
	*mock.Call
}

// GetTransitGatewayAttachmentPropagations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetTransitGatewayAttachmentPropagationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetTransitGatewayAttachmentPropagations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetTransitGatewayAttachmentPropagations_Call {
	return &EC2_GetTransitGatewayAttachmentPropagations_Call{Call: _e.mock.On("GetTransitGatewayAttachmentPropagations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetTransitGatewayAttachmentPropagations_Call) Run(run func(ctx context.Context, params *ec2.GetTransitGatewayAttachmentPropagationsInput, optFns ...func(*ec2.Options))) *EC2_GetTransitGatewayAttachmentPropagations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetTransitGatewayAttachmentPropagationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetTransitGatewayAttachmentPropagations_Call) Return(_a0 *ec2.GetTransitGatewayAttachmentPropagationsOutput, _a1 error) *EC2_GetTransitGatewayAttachmentPropagations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetTransitGatewayAttachmentPropagations_Call) RunAndReturn(run func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error)) *EC2_GetTransitGatewayAttachmentPropagations_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.GetTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayMulticastDomainAssociations")
	}

	var r0 *ec2.GetTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetTransitGatewayMulticastDomainAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransitGatewayMulticastDomainAssociations'
type EC2_GetTransitGatewayMulticastDomainAssociations_Call struct {
	*mock.Call
}

// GetTransitGatewayMulticastDomainAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetTransitGatewayMulticastDomainAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetTransitGatewayMulticastDomainAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetTransitGatewayMulticastDomainAssociations_Call {
	return &EC2_GetTransitGatewayMulticastDomainAssociations_Call{Call: _e.mock.On("GetTransitGatewayMulticastDomainAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetTransitGatewayMulticastDomainAssociations_Call) Run(run func(ctx context.Context, params *ec2.GetTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options))) *EC2_GetTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetTransitGatewayMulticastDomainAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetTransitGatewayMulticastDomainAssociations_Call) Return(_a0 *ec2.GetTransitGatewayMulticastDomainAssociationsOutput, _a1 error) *EC2_GetTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetTransitGatewayMulticastDomainAssociations_Call) RunAndReturn(run func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error)) *EC2_GetTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransitGatewayPrefixListReferences provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayPrefixListReferences(ctx context.Context, params *ec2.GetTransitGatewayPrefixListReferencesInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayPrefixListReferences")
	}

	var r0 *ec2.GetTransitGatewayPrefixListReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayPrefixListReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayPrefixListReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetTransitGatewayPrefixListReferences_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransitGatewayPrefixListReferences'
type EC2_GetTransitGatewayPrefixListReferences_Call struct {
	*mock.Call
}

// GetTransitGatewayPrefixListReferences is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetTransitGatewayPrefixListReferencesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetTransitGatewayPrefixListReferences(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetTransitGatewayPrefixListReferences_Call {
	return &EC2_GetTransitGatewayPrefixListReferences_Call{Call: _e.mock.On("GetTransitGatewayPrefixListReferences",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetTransitGatewayPrefixListReferences_Call) Run(run func(ctx context.Context, params *ec2.GetTransitGatewayPrefixListReferencesInput, optFns ...func(*ec2.Options))) *EC2_GetTransitGatewayPrefixListReferences_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetTransitGatewayPrefixListReferencesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetTransitGatewayPrefixListReferences_Call) Return(_a0 *ec2.GetTransitGatewayPrefixListReferencesOutput, _a1 error) *EC2_GetTransitGatewayPrefixListReferences_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetTransitGatewayPrefixListReferences_Call) RunAndReturn(run func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error)) *EC2_GetTransitGatewayPrefixListReferences_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransitGatewayRouteTableAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayRouteTableAssociations(ctx context.Context, params *ec2.GetTransitGatewayRouteTableAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayRouteTableAssociations")
	}

	var r0 *ec2.GetTransitGatewayRouteTableAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayRouteTableAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTableAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetTransitGatewayRouteTableAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransitGatewayRouteTableAssociations'
type EC2_GetTransitGatewayRouteTableAssociations_Call struct {
	*mock.Call
}

// GetTransitGatewayRouteTableAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetTransitGatewayRouteTableAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetTransitGatewayRouteTableAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetTransitGatewayRouteTableAssociations_Call {
	return &EC2_GetTransitGatewayRouteTableAssociations_Call{Call: _e.mock.On("GetTransitGatewayRouteTableAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetTransitGatewayRouteTableAssociations_Call) Run(run func(ctx context.Context, params *ec2.GetTransitGatewayRouteTableAssociationsInput, optFns ...func(*ec2.Options))) *EC2_GetTransitGatewayRouteTableAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetTransitGatewayRouteTableAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetTransitGatewayRouteTableAssociations_Call) Return(_a0 *ec2.GetTransitGatewayRouteTableAssociationsOutput, _a1 error) *EC2_GetTransitGatewayRouteTableAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetTransitGatewayRouteTableAssociations_Call) RunAndReturn(run func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error)) *EC2_GetTransitGatewayRouteTableAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransitGatewayRouteTablePropagations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayRouteTablePropagations(ctx context.Context, params *ec2.GetTransitGatewayRouteTablePropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransitGatewayRouteTablePropagations")
	}

	var r0 *ec2.GetTransitGatewayRouteTablePropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayRouteTablePropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTablePropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetTransitGatewayRouteTablePropagations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransitGatewayRouteTablePropagations'
type EC2_GetTransitGatewayRouteTablePropagations_Call struct {
	*mock.Call
}

// GetTransitGatewayRouteTablePropagations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetTransitGatewayRouteTablePropagationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetTransitGatewayRouteTablePropagations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetTransitGatewayRouteTablePropagations_Call {
	return &EC2_GetTransitGatewayRouteTablePropagations_Call{Call: _e.mock.On("GetTransitGatewayRouteTablePropagations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetTransitGatewayRouteTablePropagations_Call) Run(run func(ctx context.Context, params *ec2.GetTransitGatewayRouteTablePropagationsInput, optFns ...func(*ec2.Options))) *EC2_GetTransitGatewayRouteTablePropagations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetTransitGatewayRouteTablePropagationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetTransitGatewayRouteTablePropagations_Call) Return(_a0 *ec2.GetTransitGatewayRouteTablePropagationsOutput, _a1 error) *EC2_GetTransitGatewayRouteTablePropagations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetTransitGatewayRouteTablePropagations_Call) RunAndReturn(run func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error)) *EC2_GetTransitGatewayRouteTablePropagations_Call {
	_c.Call.Return(run)
	return _c
}

// GetVpnConnectionDeviceSampleConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetVpnConnectionDeviceSampleConfiguration(ctx context.Context, params *ec2.GetVpnConnectionDeviceSampleConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVpnConnectionDeviceSampleConfiguration")
	}

	var r0 *ec2.GetVpnConnectionDeviceSampleConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) *ec2.GetVpnConnectionDeviceSampleConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnConnectionDeviceSampleConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetVpnConnectionDeviceSampleConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVpnConnectionDeviceSampleConfiguration'
type EC2_GetVpnConnectionDeviceSampleConfiguration_Call struct {
	*mock.Call
}

// GetVpnConnectionDeviceSampleConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetVpnConnectionDeviceSampleConfigurationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetVpnConnectionDeviceSampleConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetVpnConnectionDeviceSampleConfiguration_Call {
	return &EC2_GetVpnConnectionDeviceSampleConfiguration_Call{Call: _e.mock.On("GetVpnConnectionDeviceSampleConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetVpnConnectionDeviceSampleConfiguration_Call) Run(run func(ctx context.Context, params *ec2.GetVpnConnectionDeviceSampleConfigurationInput, optFns ...func(*ec2.Options))) *EC2_GetVpnConnectionDeviceSampleConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetVpnConnectionDeviceSampleConfigurationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetVpnConnectionDeviceSampleConfiguration_Call) Return(_a0 *ec2.GetVpnConnectionDeviceSampleConfigurationOutput, _a1 error) *EC2_GetVpnConnectionDeviceSampleConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetVpnConnectionDeviceSampleConfiguration_Call) RunAndReturn(run func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error)) *EC2_GetVpnConnectionDeviceSampleConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetVpnConnectionDeviceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetVpnConnectionDeviceTypes(ctx context.Context, params *ec2.GetVpnConnectionDeviceTypesInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetVpnConnectionDeviceTypes")
	}

	var r0 *ec2.GetVpnConnectionDeviceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) *ec2.GetVpnConnectionDeviceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnConnectionDeviceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_GetVpnConnectionDeviceTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVpnConnectionDeviceTypes'
type EC2_GetVpnConnectionDeviceTypes_Call struct {
	*mock.Call
}

// GetVpnConnectionDeviceTypes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.GetVpnConnectionDeviceTypesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) GetVpnConnectionDeviceTypes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_GetVpnConnectionDeviceTypes_Call {
	return &EC2_GetVpnConnectionDeviceTypes_Call{Call: _e.mock.On("GetVpnConnectionDeviceTypes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_GetVpnConnectionDeviceTypes_Call) Run(run func(ctx context.Context, params *ec2.GetVpnConnectionDeviceTypesInput, optFns ...func(*ec2.Options))) *EC2_GetVpnConnectionDeviceTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.GetVpnConnectionDeviceTypesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_GetVpnConnectionDeviceTypes_Call) Return(_a0 *ec2.GetVpnConnectionDeviceTypesOutput, _a1 error) *EC2_GetVpnConnectionDeviceTypes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_GetVpnConnectionDeviceTypes_Call) RunAndReturn(run func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error)) *EC2_GetVpnConnectionDeviceTypes_Call {
	_c.Call.Return(run)
	return _c
}

// ImportClientVpnClientCertificateRevocationList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportClientVpnClientCertificateRevocationList(ctx context.Context, params *ec2.ImportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportClientVpnClientCertificateRevocationList")
	}

	var r0 *ec2.ImportClientVpnClientCertificateRevocationListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) *ec2.ImportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportClientVpnClientCertificateRevocationListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ImportClientVpnClientCertificateRevocationList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportClientVpnClientCertificateRevocationList'
type EC2_ImportClientVpnClientCertificateRevocationList_Call struct {
	*mock.Call
}

// ImportClientVpnClientCertificateRevocationList is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ImportClientVpnClientCertificateRevocationListInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ImportClientVpnClientCertificateRevocationList(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ImportClientVpnClientCertificateRevocationList_Call {
	return &EC2_ImportClientVpnClientCertificateRevocationList_Call{Call: _e.mock.On("ImportClientVpnClientCertificateRevocationList",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ImportClientVpnClientCertificateRevocationList_Call) Run(run func(ctx context.Context, params *ec2.ImportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options))) *EC2_ImportClientVpnClientCertificateRevocationList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ImportClientVpnClientCertificateRevocationListInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ImportClientVpnClientCertificateRevocationList_Call) Return(_a0 *ec2.ImportClientVpnClientCertificateRevocationListOutput, _a1 error) *EC2_ImportClientVpnClientCertificateRevocationList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ImportClientVpnClientCertificateRevocationList_Call) RunAndReturn(run func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error)) *EC2_ImportClientVpnClientCertificateRevocationList_Call {
	_c.Call.Return(run)
	return _c
}

// ImportImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportImage(ctx context.Context, params *ec2.ImportImageInput, optFns ...func(*ec2.Options)) (*ec2.ImportImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportImage")
	}

	var r0 *ec2.ImportImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) (*ec2.ImportImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) *ec2.ImportImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ImportImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportImage'
type EC2_ImportImage_Call struct {
	*mock.Call
}

// ImportImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ImportImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ImportImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ImportImage_Call {
	return &EC2_ImportImage_Call{Call: _e.mock.On("ImportImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ImportImage_Call) Run(run func(ctx context.Context, params *ec2.ImportImageInput, optFns ...func(*ec2.Options))) *EC2_ImportImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ImportImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ImportImage_Call) Return(_a0 *ec2.ImportImageOutput, _a1 error) *EC2_ImportImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ImportImage_Call) RunAndReturn(run func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) (*ec2.ImportImageOutput, error)) *EC2_ImportImage_Call {
	_c.Call.Return(run)
	return _c
}

// ImportInstance provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportInstance(ctx context.Context, params *ec2.ImportInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportInstance")
	}

	var r0 *ec2.ImportInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) *ec2.ImportInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ImportInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportInstance'
type EC2_ImportInstance_Call struct {
	*mock.Call
}

// ImportInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ImportInstanceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ImportInstance(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ImportInstance_Call {
	return &EC2_ImportInstance_Call{Call: _e.mock.On("ImportInstance",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ImportInstance_Call) Run(run func(ctx context.Context, params *ec2.ImportInstanceInput, optFns ...func(*ec2.Options))) *EC2_ImportInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ImportInstanceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ImportInstance_Call) Return(_a0 *ec2.ImportInstanceOutput, _a1 error) *EC2_ImportInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ImportInstance_Call) RunAndReturn(run func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error)) *EC2_ImportInstance_Call {
	_c.Call.Return(run)
	return _c
}

// ImportKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportKeyPair(ctx context.Context, params *ec2.ImportKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportKeyPair")
	}

	var r0 *ec2.ImportKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) *ec2.ImportKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ImportKeyPair_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportKeyPair'
type EC2_ImportKeyPair_Call struct {
	*mock.Call
}

// ImportKeyPair is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ImportKeyPairInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ImportKeyPair(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ImportKeyPair_Call {
	return &EC2_ImportKeyPair_Call{Call: _e.mock.On("ImportKeyPair",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ImportKeyPair_Call) Run(run func(ctx context.Context, params *ec2.ImportKeyPairInput, optFns ...func(*ec2.Options))) *EC2_ImportKeyPair_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ImportKeyPairInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ImportKeyPair_Call) Return(_a0 *ec2.ImportKeyPairOutput, _a1 error) *EC2_ImportKeyPair_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ImportKeyPair_Call) RunAndReturn(run func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error)) *EC2_ImportKeyPair_Call {
	_c.Call.Return(run)
	return _c
}

// ImportSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportSnapshot(ctx context.Context, params *ec2.ImportSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportSnapshot")
	}

	var r0 *ec2.ImportSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) *ec2.ImportSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ImportSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportSnapshot'
type EC2_ImportSnapshot_Call struct {
	*mock.Call
}

// ImportSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ImportSnapshotInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ImportSnapshot(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ImportSnapshot_Call {
	return &EC2_ImportSnapshot_Call{Call: _e.mock.On("ImportSnapshot",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ImportSnapshot_Call) Run(run func(ctx context.Context, params *ec2.ImportSnapshotInput, optFns ...func(*ec2.Options))) *EC2_ImportSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ImportSnapshotInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ImportSnapshot_Call) Return(_a0 *ec2.ImportSnapshotOutput, _a1 error) *EC2_ImportSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ImportSnapshot_Call) RunAndReturn(run func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error)) *EC2_ImportSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// ImportVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportVolume(ctx context.Context, params *ec2.ImportVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportVolume")
	}

	var r0 *ec2.ImportVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) *ec2.ImportVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ImportVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportVolume'
type EC2_ImportVolume_Call struct {
	*mock.Call
}

// ImportVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ImportVolumeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ImportVolume(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ImportVolume_Call {
	return &EC2_ImportVolume_Call{Call: _e.mock.On("ImportVolume",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ImportVolume_Call) Run(run func(ctx context.Context, params *ec2.ImportVolumeInput, optFns ...func(*ec2.Options))) *EC2_ImportVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ImportVolumeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ImportVolume_Call) Return(_a0 *ec2.ImportVolumeOutput, _a1 error) *EC2_ImportVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ImportVolume_Call) RunAndReturn(run func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error)) *EC2_ImportVolume_Call {
	_c.Call.Return(run)
	return _c
}

// ListImagesInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ListImagesInRecycleBin(ctx context.Context, params *ec2.ListImagesInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListImagesInRecycleBin")
	}

	var r0 *ec2.ListImagesInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListImagesInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListImagesInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ListImagesInRecycleBin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListImagesInRecycleBin'
type EC2_ListImagesInRecycleBin_Call struct {
	*mock.Call
}

// ListImagesInRecycleBin is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ListImagesInRecycleBinInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ListImagesInRecycleBin(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ListImagesInRecycleBin_Call {
	return &EC2_ListImagesInRecycleBin_Call{Call: _e.mock.On("ListImagesInRecycleBin",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ListImagesInRecycleBin_Call) Run(run func(ctx context.Context, params *ec2.ListImagesInRecycleBinInput, optFns ...func(*ec2.Options))) *EC2_ListImagesInRecycleBin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ListImagesInRecycleBinInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ListImagesInRecycleBin_Call) Return(_a0 *ec2.ListImagesInRecycleBinOutput, _a1 error) *EC2_ListImagesInRecycleBin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ListImagesInRecycleBin_Call) RunAndReturn(run func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error)) *EC2_ListImagesInRecycleBin_Call {
	_c.Call.Return(run)
	return _c
}

// ListSnapshotsInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ListSnapshotsInRecycleBin(ctx context.Context, params *ec2.ListSnapshotsInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnapshotsInRecycleBin")
	}

	var r0 *ec2.ListSnapshotsInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListSnapshotsInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListSnapshotsInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ListSnapshotsInRecycleBin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSnapshotsInRecycleBin'
type EC2_ListSnapshotsInRecycleBin_Call struct {
	*mock.Call
}

// ListSnapshotsInRecycleBin is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ListSnapshotsInRecycleBinInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ListSnapshotsInRecycleBin(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ListSnapshotsInRecycleBin_Call {
	return &EC2_ListSnapshotsInRecycleBin_Call{Call: _e.mock.On("ListSnapshotsInRecycleBin",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ListSnapshotsInRecycleBin_Call) Run(run func(ctx context.Context, params *ec2.ListSnapshotsInRecycleBinInput, optFns ...func(*ec2.Options))) *EC2_ListSnapshotsInRecycleBin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ListSnapshotsInRecycleBinInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ListSnapshotsInRecycleBin_Call) Return(_a0 *ec2.ListSnapshotsInRecycleBinOutput, _a1 error) *EC2_ListSnapshotsInRecycleBin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ListSnapshotsInRecycleBin_Call) RunAndReturn(run func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error)) *EC2_ListSnapshotsInRecycleBin_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyAddressAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyAddressAttribute(ctx context.Context, params *ec2.ModifyAddressAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyAddressAttribute")
	}

	var r0 *ec2.ModifyAddressAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) *ec2.ModifyAddressAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAddressAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyAddressAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyAddressAttribute'
type EC2_ModifyAddressAttribute_Call struct {
	*mock.Call
}

// ModifyAddressAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyAddressAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyAddressAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyAddressAttribute_Call {
	return &EC2_ModifyAddressAttribute_Call{Call: _e.mock.On("ModifyAddressAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyAddressAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyAddressAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyAddressAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyAddressAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyAddressAttribute_Call) Return(_a0 *ec2.ModifyAddressAttributeOutput, _a1 error) *EC2_ModifyAddressAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyAddressAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error)) *EC2_ModifyAddressAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyAvailabilityZoneGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyAvailabilityZoneGroup(ctx context.Context, params *ec2.ModifyAvailabilityZoneGroupInput, optFns ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyAvailabilityZoneGroup")
	}

	var r0 *ec2.ModifyAvailabilityZoneGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) *ec2.ModifyAvailabilityZoneGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAvailabilityZoneGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyAvailabilityZoneGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyAvailabilityZoneGroup'
type EC2_ModifyAvailabilityZoneGroup_Call struct {
	*mock.Call
}

// ModifyAvailabilityZoneGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyAvailabilityZoneGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyAvailabilityZoneGroup(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyAvailabilityZoneGroup_Call {
	return &EC2_ModifyAvailabilityZoneGroup_Call{Call: _e.mock.On("ModifyAvailabilityZoneGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyAvailabilityZoneGroup_Call) Run(run func(ctx context.Context, params *ec2.ModifyAvailabilityZoneGroupInput, optFns ...func(*ec2.Options))) *EC2_ModifyAvailabilityZoneGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyAvailabilityZoneGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyAvailabilityZoneGroup_Call) Return(_a0 *ec2.ModifyAvailabilityZoneGroupOutput, _a1 error) *EC2_ModifyAvailabilityZoneGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyAvailabilityZoneGroup_Call) RunAndReturn(run func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error)) *EC2_ModifyAvailabilityZoneGroup_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyCapacityReservation(ctx context.Context, params *ec2.ModifyCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCapacityReservation")
	}

	var r0 *ec2.ModifyCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) *ec2.ModifyCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyCapacityReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyCapacityReservation'
type EC2_ModifyCapacityReservation_Call struct {
	*mock.Call
}

// ModifyCapacityReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyCapacityReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyCapacityReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyCapacityReservation_Call {
	return &EC2_ModifyCapacityReservation_Call{Call: _e.mock.On("ModifyCapacityReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyCapacityReservation_Call) Run(run func(ctx context.Context, params *ec2.ModifyCapacityReservationInput, optFns ...func(*ec2.Options))) *EC2_ModifyCapacityReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyCapacityReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyCapacityReservation_Call) Return(_a0 *ec2.ModifyCapacityReservationOutput, _a1 error) *EC2_ModifyCapacityReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyCapacityReservation_Call) RunAndReturn(run func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error)) *EC2_ModifyCapacityReservation_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyCapacityReservationFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyCapacityReservationFleet(ctx context.Context, params *ec2.ModifyCapacityReservationFleetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyCapacityReservationFleet")
	}

	var r0 *ec2.ModifyCapacityReservationFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) *ec2.ModifyCapacityReservationFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyCapacityReservationFleet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyCapacityReservationFleet'
type EC2_ModifyCapacityReservationFleet_Call struct {
	*mock.Call
}

// ModifyCapacityReservationFleet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyCapacityReservationFleetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyCapacityReservationFleet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyCapacityReservationFleet_Call {
	return &EC2_ModifyCapacityReservationFleet_Call{Call: _e.mock.On("ModifyCapacityReservationFleet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyCapacityReservationFleet_Call) Run(run func(ctx context.Context, params *ec2.ModifyCapacityReservationFleetInput, optFns ...func(*ec2.Options))) *EC2_ModifyCapacityReservationFleet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyCapacityReservationFleetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyCapacityReservationFleet_Call) Return(_a0 *ec2.ModifyCapacityReservationFleetOutput, _a1 error) *EC2_ModifyCapacityReservationFleet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyCapacityReservationFleet_Call) RunAndReturn(run func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error)) *EC2_ModifyCapacityReservationFleet_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyClientVpnEndpoint(ctx context.Context, params *ec2.ModifyClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyClientVpnEndpoint")
	}

	var r0 *ec2.ModifyClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.ModifyClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyClientVpnEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyClientVpnEndpoint'
type EC2_ModifyClientVpnEndpoint_Call struct {
	*mock.Call
}

// ModifyClientVpnEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyClientVpnEndpointInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyClientVpnEndpoint(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyClientVpnEndpoint_Call {
	return &EC2_ModifyClientVpnEndpoint_Call{Call: _e.mock.On("ModifyClientVpnEndpoint",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyClientVpnEndpoint_Call) Run(run func(ctx context.Context, params *ec2.ModifyClientVpnEndpointInput, optFns ...func(*ec2.Options))) *EC2_ModifyClientVpnEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyClientVpnEndpointInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyClientVpnEndpoint_Call) Return(_a0 *ec2.ModifyClientVpnEndpointOutput, _a1 error) *EC2_ModifyClientVpnEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyClientVpnEndpoint_Call) RunAndReturn(run func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error)) *EC2_ModifyClientVpnEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyDefaultCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyDefaultCreditSpecification(ctx context.Context, params *ec2.ModifyDefaultCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyDefaultCreditSpecification")
	}

	var r0 *ec2.ModifyDefaultCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) *ec2.ModifyDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyDefaultCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyDefaultCreditSpecification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyDefaultCreditSpecification'
type EC2_ModifyDefaultCreditSpecification_Call struct {
	*mock.Call
}

// ModifyDefaultCreditSpecification is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyDefaultCreditSpecificationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyDefaultCreditSpecification(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyDefaultCreditSpecification_Call {
	return &EC2_ModifyDefaultCreditSpecification_Call{Call: _e.mock.On("ModifyDefaultCreditSpecification",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyDefaultCreditSpecification_Call) Run(run func(ctx context.Context, params *ec2.ModifyDefaultCreditSpecificationInput, optFns ...func(*ec2.Options))) *EC2_ModifyDefaultCreditSpecification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyDefaultCreditSpecificationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyDefaultCreditSpecification_Call) Return(_a0 *ec2.ModifyDefaultCreditSpecificationOutput, _a1 error) *EC2_ModifyDefaultCreditSpecification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyDefaultCreditSpecification_Call) RunAndReturn(run func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error)) *EC2_ModifyDefaultCreditSpecification_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyEbsDefaultKmsKeyId(ctx context.Context, params *ec2.ModifyEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyEbsDefaultKmsKeyId")
	}

	var r0 *ec2.ModifyEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.ModifyEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyEbsDefaultKmsKeyId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyEbsDefaultKmsKeyId'
type EC2_ModifyEbsDefaultKmsKeyId_Call struct {
	*mock.Call
}

// ModifyEbsDefaultKmsKeyId is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyEbsDefaultKmsKeyIdInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyEbsDefaultKmsKeyId(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyEbsDefaultKmsKeyId_Call {
	return &EC2_ModifyEbsDefaultKmsKeyId_Call{Call: _e.mock.On("ModifyEbsDefaultKmsKeyId",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyEbsDefaultKmsKeyId_Call) Run(run func(ctx context.Context, params *ec2.ModifyEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options))) *EC2_ModifyEbsDefaultKmsKeyId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyEbsDefaultKmsKeyIdInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyEbsDefaultKmsKeyId_Call) Return(_a0 *ec2.ModifyEbsDefaultKmsKeyIdOutput, _a1 error) *EC2_ModifyEbsDefaultKmsKeyId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyEbsDefaultKmsKeyId_Call) RunAndReturn(run func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error)) *EC2_ModifyEbsDefaultKmsKeyId_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyFleet(ctx context.Context, params *ec2.ModifyFleetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyFleet")
	}

	var r0 *ec2.ModifyFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) *ec2.ModifyFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyFleet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyFleet'
type EC2_ModifyFleet_Call struct {
	*mock.Call
}

// ModifyFleet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyFleetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyFleet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyFleet_Call {
	return &EC2_ModifyFleet_Call{Call: _e.mock.On("ModifyFleet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyFleet_Call) Run(run func(ctx context.Context, params *ec2.ModifyFleetInput, optFns ...func(*ec2.Options))) *EC2_ModifyFleet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyFleetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyFleet_Call) Return(_a0 *ec2.ModifyFleetOutput, _a1 error) *EC2_ModifyFleet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyFleet_Call) RunAndReturn(run func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error)) *EC2_ModifyFleet_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyFpgaImageAttribute(ctx context.Context, params *ec2.ModifyFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyFpgaImageAttribute")
	}

	var r0 *ec2.ModifyFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.ModifyFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyFpgaImageAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyFpgaImageAttribute'
type EC2_ModifyFpgaImageAttribute_Call struct {
	*mock.Call
}

// ModifyFpgaImageAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyFpgaImageAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyFpgaImageAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyFpgaImageAttribute_Call {
	return &EC2_ModifyFpgaImageAttribute_Call{Call: _e.mock.On("ModifyFpgaImageAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyFpgaImageAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyFpgaImageAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyFpgaImageAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyFpgaImageAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyFpgaImageAttribute_Call) Return(_a0 *ec2.ModifyFpgaImageAttributeOutput, _a1 error) *EC2_ModifyFpgaImageAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyFpgaImageAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error)) *EC2_ModifyFpgaImageAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyHosts(ctx context.Context, params *ec2.ModifyHostsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyHosts")
	}

	var r0 *ec2.ModifyHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) *ec2.ModifyHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyHosts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyHosts'
type EC2_ModifyHosts_Call struct {
	*mock.Call
}

// ModifyHosts is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyHostsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyHosts(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyHosts_Call {
	return &EC2_ModifyHosts_Call{Call: _e.mock.On("ModifyHosts",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyHosts_Call) Run(run func(ctx context.Context, params *ec2.ModifyHostsInput, optFns ...func(*ec2.Options))) *EC2_ModifyHosts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyHostsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyHosts_Call) Return(_a0 *ec2.ModifyHostsOutput, _a1 error) *EC2_ModifyHosts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyHosts_Call) RunAndReturn(run func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error)) *EC2_ModifyHosts_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIdFormat(ctx context.Context, params *ec2.ModifyIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIdFormat")
	}

	var r0 *ec2.ModifyIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) *ec2.ModifyIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyIdFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIdFormat'
type EC2_ModifyIdFormat_Call struct {
	*mock.Call
}

// ModifyIdFormat is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyIdFormatInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyIdFormat(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyIdFormat_Call {
	return &EC2_ModifyIdFormat_Call{Call: _e.mock.On("ModifyIdFormat",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyIdFormat_Call) Run(run func(ctx context.Context, params *ec2.ModifyIdFormatInput, optFns ...func(*ec2.Options))) *EC2_ModifyIdFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyIdFormatInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyIdFormat_Call) Return(_a0 *ec2.ModifyIdFormatOutput, _a1 error) *EC2_ModifyIdFormat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyIdFormat_Call) RunAndReturn(run func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error)) *EC2_ModifyIdFormat_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIdentityIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIdentityIdFormat(ctx context.Context, params *ec2.ModifyIdentityIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIdentityIdFormat")
	}

	var r0 *ec2.ModifyIdentityIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) *ec2.ModifyIdentityIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdentityIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyIdentityIdFormat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIdentityIdFormat'
type EC2_ModifyIdentityIdFormat_Call struct {
	*mock.Call
}

// ModifyIdentityIdFormat is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyIdentityIdFormatInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyIdentityIdFormat(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyIdentityIdFormat_Call {
	return &EC2_ModifyIdentityIdFormat_Call{Call: _e.mock.On("ModifyIdentityIdFormat",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyIdentityIdFormat_Call) Run(run func(ctx context.Context, params *ec2.ModifyIdentityIdFormatInput, optFns ...func(*ec2.Options))) *EC2_ModifyIdentityIdFormat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyIdentityIdFormatInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyIdentityIdFormat_Call) Return(_a0 *ec2.ModifyIdentityIdFormatOutput, _a1 error) *EC2_ModifyIdentityIdFormat_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyIdentityIdFormat_Call) RunAndReturn(run func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error)) *EC2_ModifyIdentityIdFormat_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyImageAttribute(ctx context.Context, params *ec2.ModifyImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyImageAttribute")
	}

	var r0 *ec2.ModifyImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) *ec2.ModifyImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyImageAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyImageAttribute'
type EC2_ModifyImageAttribute_Call struct {
	*mock.Call
}

// ModifyImageAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyImageAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyImageAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyImageAttribute_Call {
	return &EC2_ModifyImageAttribute_Call{Call: _e.mock.On("ModifyImageAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyImageAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyImageAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyImageAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyImageAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyImageAttribute_Call) Return(_a0 *ec2.ModifyImageAttributeOutput, _a1 error) *EC2_ModifyImageAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyImageAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error)) *EC2_ModifyImageAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceAttribute(ctx context.Context, params *ec2.ModifyInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceAttribute")
	}

	var r0 *ec2.ModifyInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) *ec2.ModifyInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceAttribute'
type EC2_ModifyInstanceAttribute_Call struct {
	*mock.Call
}

// ModifyInstanceAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceAttribute_Call {
	return &EC2_ModifyInstanceAttribute_Call{Call: _e.mock.On("ModifyInstanceAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceAttribute_Call) Return(_a0 *ec2.ModifyInstanceAttributeOutput, _a1 error) *EC2_ModifyInstanceAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error)) *EC2_ModifyInstanceAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceCapacityReservationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceCapacityReservationAttributes(ctx context.Context, params *ec2.ModifyInstanceCapacityReservationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceCapacityReservationAttributes")
	}

	var r0 *ec2.ModifyInstanceCapacityReservationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCapacityReservationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCapacityReservationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceCapacityReservationAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceCapacityReservationAttributes'
type EC2_ModifyInstanceCapacityReservationAttributes_Call struct {
	*mock.Call
}

// ModifyInstanceCapacityReservationAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceCapacityReservationAttributesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceCapacityReservationAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceCapacityReservationAttributes_Call {
	return &EC2_ModifyInstanceCapacityReservationAttributes_Call{Call: _e.mock.On("ModifyInstanceCapacityReservationAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceCapacityReservationAttributes_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceCapacityReservationAttributesInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceCapacityReservationAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceCapacityReservationAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceCapacityReservationAttributes_Call) Return(_a0 *ec2.ModifyInstanceCapacityReservationAttributesOutput, _a1 error) *EC2_ModifyInstanceCapacityReservationAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceCapacityReservationAttributes_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error)) *EC2_ModifyInstanceCapacityReservationAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceCreditSpecification(ctx context.Context, params *ec2.ModifyInstanceCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceCreditSpecification")
	}

	var r0 *ec2.ModifyInstanceCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceCreditSpecification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceCreditSpecification'
type EC2_ModifyInstanceCreditSpecification_Call struct {
	*mock.Call
}

// ModifyInstanceCreditSpecification is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceCreditSpecificationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceCreditSpecification(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceCreditSpecification_Call {
	return &EC2_ModifyInstanceCreditSpecification_Call{Call: _e.mock.On("ModifyInstanceCreditSpecification",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceCreditSpecification_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceCreditSpecificationInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceCreditSpecification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceCreditSpecificationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceCreditSpecification_Call) Return(_a0 *ec2.ModifyInstanceCreditSpecificationOutput, _a1 error) *EC2_ModifyInstanceCreditSpecification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceCreditSpecification_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error)) *EC2_ModifyInstanceCreditSpecification_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceEventStartTime provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceEventStartTime(ctx context.Context, params *ec2.ModifyInstanceEventStartTimeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceEventStartTime")
	}

	var r0 *ec2.ModifyInstanceEventStartTimeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) *ec2.ModifyInstanceEventStartTimeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventStartTimeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceEventStartTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceEventStartTime'
type EC2_ModifyInstanceEventStartTime_Call struct {
	*mock.Call
}

// ModifyInstanceEventStartTime is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceEventStartTimeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceEventStartTime(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceEventStartTime_Call {
	return &EC2_ModifyInstanceEventStartTime_Call{Call: _e.mock.On("ModifyInstanceEventStartTime",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceEventStartTime_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceEventStartTimeInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceEventStartTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceEventStartTimeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceEventStartTime_Call) Return(_a0 *ec2.ModifyInstanceEventStartTimeOutput, _a1 error) *EC2_ModifyInstanceEventStartTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceEventStartTime_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error)) *EC2_ModifyInstanceEventStartTime_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceEventWindow(ctx context.Context, params *ec2.ModifyInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceEventWindow")
	}

	var r0 *ec2.ModifyInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.ModifyInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceEventWindow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceEventWindow'
type EC2_ModifyInstanceEventWindow_Call struct {
	*mock.Call
}

// ModifyInstanceEventWindow is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceEventWindowInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceEventWindow(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceEventWindow_Call {
	return &EC2_ModifyInstanceEventWindow_Call{Call: _e.mock.On("ModifyInstanceEventWindow",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceEventWindow_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceEventWindowInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceEventWindow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceEventWindowInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceEventWindow_Call) Return(_a0 *ec2.ModifyInstanceEventWindowOutput, _a1 error) *EC2_ModifyInstanceEventWindow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceEventWindow_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error)) *EC2_ModifyInstanceEventWindow_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceMaintenanceOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceMaintenanceOptions(ctx context.Context, params *ec2.ModifyInstanceMaintenanceOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceMaintenanceOptions")
	}

	var r0 *ec2.ModifyInstanceMaintenanceOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMaintenanceOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMaintenanceOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceMaintenanceOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceMaintenanceOptions'
type EC2_ModifyInstanceMaintenanceOptions_Call struct {
	*mock.Call
}

// ModifyInstanceMaintenanceOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceMaintenanceOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceMaintenanceOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceMaintenanceOptions_Call {
	return &EC2_ModifyInstanceMaintenanceOptions_Call{Call: _e.mock.On("ModifyInstanceMaintenanceOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceMaintenanceOptions_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceMaintenanceOptionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceMaintenanceOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceMaintenanceOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceMaintenanceOptions_Call) Return(_a0 *ec2.ModifyInstanceMaintenanceOptionsOutput, _a1 error) *EC2_ModifyInstanceMaintenanceOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceMaintenanceOptions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error)) *EC2_ModifyInstanceMaintenanceOptions_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstanceMetadataOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceMetadataOptions(ctx context.Context, params *ec2.ModifyInstanceMetadataOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstanceMetadataOptions")
	}

	var r0 *ec2.ModifyInstanceMetadataOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMetadataOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMetadataOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstanceMetadataOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstanceMetadataOptions'
type EC2_ModifyInstanceMetadataOptions_Call struct {
	*mock.Call
}

// ModifyInstanceMetadataOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstanceMetadataOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstanceMetadataOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstanceMetadataOptions_Call {
	return &EC2_ModifyInstanceMetadataOptions_Call{Call: _e.mock.On("ModifyInstanceMetadataOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstanceMetadataOptions_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstanceMetadataOptionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstanceMetadataOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstanceMetadataOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstanceMetadataOptions_Call) Return(_a0 *ec2.ModifyInstanceMetadataOptionsOutput, _a1 error) *EC2_ModifyInstanceMetadataOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstanceMetadataOptions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error)) *EC2_ModifyInstanceMetadataOptions_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyInstancePlacement provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstancePlacement(ctx context.Context, params *ec2.ModifyInstancePlacementInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyInstancePlacement")
	}

	var r0 *ec2.ModifyInstancePlacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) *ec2.ModifyInstancePlacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstancePlacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyInstancePlacement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyInstancePlacement'
type EC2_ModifyInstancePlacement_Call struct {
	*mock.Call
}

// ModifyInstancePlacement is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyInstancePlacementInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyInstancePlacement(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyInstancePlacement_Call {
	return &EC2_ModifyInstancePlacement_Call{Call: _e.mock.On("ModifyInstancePlacement",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyInstancePlacement_Call) Run(run func(ctx context.Context, params *ec2.ModifyInstancePlacementInput, optFns ...func(*ec2.Options))) *EC2_ModifyInstancePlacement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyInstancePlacementInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyInstancePlacement_Call) Return(_a0 *ec2.ModifyInstancePlacementOutput, _a1 error) *EC2_ModifyInstancePlacement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyInstancePlacement_Call) RunAndReturn(run func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error)) *EC2_ModifyInstancePlacement_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpam(ctx context.Context, params *ec2.ModifyIpamInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpam")
	}

	var r0 *ec2.ModifyIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) *ec2.ModifyIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyIpam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIpam'
type EC2_ModifyIpam_Call struct {
	*mock.Call
}

// ModifyIpam is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyIpamInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyIpam(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyIpam_Call {
	return &EC2_ModifyIpam_Call{Call: _e.mock.On("ModifyIpam",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyIpam_Call) Run(run func(ctx context.Context, params *ec2.ModifyIpamInput, optFns ...func(*ec2.Options))) *EC2_ModifyIpam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyIpamInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyIpam_Call) Return(_a0 *ec2.ModifyIpamOutput, _a1 error) *EC2_ModifyIpam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyIpam_Call) RunAndReturn(run func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error)) *EC2_ModifyIpam_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpamPool(ctx context.Context, params *ec2.ModifyIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamPool")
	}

	var r0 *ec2.ModifyIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) *ec2.ModifyIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyIpamPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIpamPool'
type EC2_ModifyIpamPool_Call struct {
	*mock.Call
}

// ModifyIpamPool is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyIpamPoolInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyIpamPool(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyIpamPool_Call {
	return &EC2_ModifyIpamPool_Call{Call: _e.mock.On("ModifyIpamPool",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyIpamPool_Call) Run(run func(ctx context.Context, params *ec2.ModifyIpamPoolInput, optFns ...func(*ec2.Options))) *EC2_ModifyIpamPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyIpamPoolInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyIpamPool_Call) Return(_a0 *ec2.ModifyIpamPoolOutput, _a1 error) *EC2_ModifyIpamPool_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyIpamPool_Call) RunAndReturn(run func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error)) *EC2_ModifyIpamPool_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIpamResourceCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpamResourceCidr(ctx context.Context, params *ec2.ModifyIpamResourceCidrInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamResourceCidr")
	}

	var r0 *ec2.ModifyIpamResourceCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) *ec2.ModifyIpamResourceCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamResourceCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyIpamResourceCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIpamResourceCidr'
type EC2_ModifyIpamResourceCidr_Call struct {
	*mock.Call
}

// ModifyIpamResourceCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyIpamResourceCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyIpamResourceCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyIpamResourceCidr_Call {
	return &EC2_ModifyIpamResourceCidr_Call{Call: _e.mock.On("ModifyIpamResourceCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyIpamResourceCidr_Call) Run(run func(ctx context.Context, params *ec2.ModifyIpamResourceCidrInput, optFns ...func(*ec2.Options))) *EC2_ModifyIpamResourceCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyIpamResourceCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyIpamResourceCidr_Call) Return(_a0 *ec2.ModifyIpamResourceCidrOutput, _a1 error) *EC2_ModifyIpamResourceCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyIpamResourceCidr_Call) RunAndReturn(run func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error)) *EC2_ModifyIpamResourceCidr_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpamScope(ctx context.Context, params *ec2.ModifyIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIpamScope")
	}

	var r0 *ec2.ModifyIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) *ec2.ModifyIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyIpamScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIpamScope'
type EC2_ModifyIpamScope_Call struct {
	*mock.Call
}

// ModifyIpamScope is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyIpamScopeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyIpamScope(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyIpamScope_Call {
	return &EC2_ModifyIpamScope_Call{Call: _e.mock.On("ModifyIpamScope",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyIpamScope_Call) Run(run func(ctx context.Context, params *ec2.ModifyIpamScopeInput, optFns ...func(*ec2.Options))) *EC2_ModifyIpamScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyIpamScopeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyIpamScope_Call) Return(_a0 *ec2.ModifyIpamScopeOutput, _a1 error) *EC2_ModifyIpamScope_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyIpamScope_Call) RunAndReturn(run func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error)) *EC2_ModifyIpamScope_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyLaunchTemplate(ctx context.Context, params *ec2.ModifyLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyLaunchTemplate")
	}

	var r0 *ec2.ModifyLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) *ec2.ModifyLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyLaunchTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyLaunchTemplate'
type EC2_ModifyLaunchTemplate_Call struct {
	*mock.Call
}

// ModifyLaunchTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyLaunchTemplateInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyLaunchTemplate(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyLaunchTemplate_Call {
	return &EC2_ModifyLaunchTemplate_Call{Call: _e.mock.On("ModifyLaunchTemplate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyLaunchTemplate_Call) Run(run func(ctx context.Context, params *ec2.ModifyLaunchTemplateInput, optFns ...func(*ec2.Options))) *EC2_ModifyLaunchTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyLaunchTemplateInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyLaunchTemplate_Call) Return(_a0 *ec2.ModifyLaunchTemplateOutput, _a1 error) *EC2_ModifyLaunchTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyLaunchTemplate_Call) RunAndReturn(run func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error)) *EC2_ModifyLaunchTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyManagedPrefixList(ctx context.Context, params *ec2.ModifyManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyManagedPrefixList")
	}

	var r0 *ec2.ModifyManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) *ec2.ModifyManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyManagedPrefixList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyManagedPrefixList'
type EC2_ModifyManagedPrefixList_Call struct {
	*mock.Call
}

// ModifyManagedPrefixList is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyManagedPrefixListInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyManagedPrefixList(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyManagedPrefixList_Call {
	return &EC2_ModifyManagedPrefixList_Call{Call: _e.mock.On("ModifyManagedPrefixList",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyManagedPrefixList_Call) Run(run func(ctx context.Context, params *ec2.ModifyManagedPrefixListInput, optFns ...func(*ec2.Options))) *EC2_ModifyManagedPrefixList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyManagedPrefixListInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyManagedPrefixList_Call) Return(_a0 *ec2.ModifyManagedPrefixListOutput, _a1 error) *EC2_ModifyManagedPrefixList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyManagedPrefixList_Call) RunAndReturn(run func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error)) *EC2_ModifyManagedPrefixList_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyNetworkInterfaceAttribute(ctx context.Context, params *ec2.ModifyNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyNetworkInterfaceAttribute")
	}

	var r0 *ec2.ModifyNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.ModifyNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyNetworkInterfaceAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyNetworkInterfaceAttribute'
type EC2_ModifyNetworkInterfaceAttribute_Call struct {
	*mock.Call
}

// ModifyNetworkInterfaceAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyNetworkInterfaceAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyNetworkInterfaceAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyNetworkInterfaceAttribute_Call {
	return &EC2_ModifyNetworkInterfaceAttribute_Call{Call: _e.mock.On("ModifyNetworkInterfaceAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyNetworkInterfaceAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyNetworkInterfaceAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyNetworkInterfaceAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyNetworkInterfaceAttribute_Call) Return(_a0 *ec2.ModifyNetworkInterfaceAttributeOutput, _a1 error) *EC2_ModifyNetworkInterfaceAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyNetworkInterfaceAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error)) *EC2_ModifyNetworkInterfaceAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyPrivateDnsNameOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyPrivateDnsNameOptions(ctx context.Context, params *ec2.ModifyPrivateDnsNameOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyPrivateDnsNameOptions")
	}

	var r0 *ec2.ModifyPrivateDnsNameOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) *ec2.ModifyPrivateDnsNameOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyPrivateDnsNameOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyPrivateDnsNameOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyPrivateDnsNameOptions'
type EC2_ModifyPrivateDnsNameOptions_Call struct {
	*mock.Call
}

// ModifyPrivateDnsNameOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyPrivateDnsNameOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyPrivateDnsNameOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyPrivateDnsNameOptions_Call {
	return &EC2_ModifyPrivateDnsNameOptions_Call{Call: _e.mock.On("ModifyPrivateDnsNameOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyPrivateDnsNameOptions_Call) Run(run func(ctx context.Context, params *ec2.ModifyPrivateDnsNameOptionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyPrivateDnsNameOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyPrivateDnsNameOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyPrivateDnsNameOptions_Call) Return(_a0 *ec2.ModifyPrivateDnsNameOptionsOutput, _a1 error) *EC2_ModifyPrivateDnsNameOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyPrivateDnsNameOptions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error)) *EC2_ModifyPrivateDnsNameOptions_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyReservedInstances(ctx context.Context, params *ec2.ModifyReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyReservedInstances")
	}

	var r0 *ec2.ModifyReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) *ec2.ModifyReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyReservedInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyReservedInstances'
type EC2_ModifyReservedInstances_Call struct {
	*mock.Call
}

// ModifyReservedInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyReservedInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyReservedInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyReservedInstances_Call {
	return &EC2_ModifyReservedInstances_Call{Call: _e.mock.On("ModifyReservedInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyReservedInstances_Call) Run(run func(ctx context.Context, params *ec2.ModifyReservedInstancesInput, optFns ...func(*ec2.Options))) *EC2_ModifyReservedInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyReservedInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyReservedInstances_Call) Return(_a0 *ec2.ModifyReservedInstancesOutput, _a1 error) *EC2_ModifyReservedInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyReservedInstances_Call) RunAndReturn(run func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error)) *EC2_ModifyReservedInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ModifySecurityGroupRules provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySecurityGroupRules(ctx context.Context, params *ec2.ModifySecurityGroupRulesInput, optFns ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySecurityGroupRules")
	}

	var r0 *ec2.ModifySecurityGroupRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) *ec2.ModifySecurityGroupRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySecurityGroupRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifySecurityGroupRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifySecurityGroupRules'
type EC2_ModifySecurityGroupRules_Call struct {
	*mock.Call
}

// ModifySecurityGroupRules is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifySecurityGroupRulesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifySecurityGroupRules(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifySecurityGroupRules_Call {
	return &EC2_ModifySecurityGroupRules_Call{Call: _e.mock.On("ModifySecurityGroupRules",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifySecurityGroupRules_Call) Run(run func(ctx context.Context, params *ec2.ModifySecurityGroupRulesInput, optFns ...func(*ec2.Options))) *EC2_ModifySecurityGroupRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifySecurityGroupRulesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifySecurityGroupRules_Call) Return(_a0 *ec2.ModifySecurityGroupRulesOutput, _a1 error) *EC2_ModifySecurityGroupRules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifySecurityGroupRules_Call) RunAndReturn(run func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error)) *EC2_ModifySecurityGroupRules_Call {
	_c.Call.Return(run)
	return _c
}

// ModifySnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySnapshotAttribute(ctx context.Context, params *ec2.ModifySnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySnapshotAttribute")
	}

	var r0 *ec2.ModifySnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) *ec2.ModifySnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifySnapshotAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifySnapshotAttribute'
type EC2_ModifySnapshotAttribute_Call struct {
	*mock.Call
}

// ModifySnapshotAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifySnapshotAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifySnapshotAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifySnapshotAttribute_Call {
	return &EC2_ModifySnapshotAttribute_Call{Call: _e.mock.On("ModifySnapshotAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifySnapshotAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifySnapshotAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifySnapshotAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifySnapshotAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifySnapshotAttribute_Call) Return(_a0 *ec2.ModifySnapshotAttributeOutput, _a1 error) *EC2_ModifySnapshotAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifySnapshotAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error)) *EC2_ModifySnapshotAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifySnapshotTier provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySnapshotTier(ctx context.Context, params *ec2.ModifySnapshotTierInput, optFns ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySnapshotTier")
	}

	var r0 *ec2.ModifySnapshotTierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) *ec2.ModifySnapshotTierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotTierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifySnapshotTier_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifySnapshotTier'
type EC2_ModifySnapshotTier_Call struct {
	*mock.Call
}

// ModifySnapshotTier is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifySnapshotTierInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifySnapshotTier(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifySnapshotTier_Call {
	return &EC2_ModifySnapshotTier_Call{Call: _e.mock.On("ModifySnapshotTier",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifySnapshotTier_Call) Run(run func(ctx context.Context, params *ec2.ModifySnapshotTierInput, optFns ...func(*ec2.Options))) *EC2_ModifySnapshotTier_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifySnapshotTierInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifySnapshotTier_Call) Return(_a0 *ec2.ModifySnapshotTierOutput, _a1 error) *EC2_ModifySnapshotTier_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifySnapshotTier_Call) RunAndReturn(run func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error)) *EC2_ModifySnapshotTier_Call {
	_c.Call.Return(run)
	return _c
}

// ModifySpotFleetRequest provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySpotFleetRequest(ctx context.Context, params *ec2.ModifySpotFleetRequestInput, optFns ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySpotFleetRequest")
	}

	var r0 *ec2.ModifySpotFleetRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) *ec2.ModifySpotFleetRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySpotFleetRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifySpotFleetRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifySpotFleetRequest'
type EC2_ModifySpotFleetRequest_Call struct {
	*mock.Call
}

// ModifySpotFleetRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifySpotFleetRequestInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifySpotFleetRequest(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifySpotFleetRequest_Call {
	return &EC2_ModifySpotFleetRequest_Call{Call: _e.mock.On("ModifySpotFleetRequest",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifySpotFleetRequest_Call) Run(run func(ctx context.Context, params *ec2.ModifySpotFleetRequestInput, optFns ...func(*ec2.Options))) *EC2_ModifySpotFleetRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifySpotFleetRequestInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifySpotFleetRequest_Call) Return(_a0 *ec2.ModifySpotFleetRequestOutput, _a1 error) *EC2_ModifySpotFleetRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifySpotFleetRequest_Call) RunAndReturn(run func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error)) *EC2_ModifySpotFleetRequest_Call {
	_c.Call.Return(run)
	return _c
}

// ModifySubnetAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySubnetAttribute(ctx context.Context, params *ec2.ModifySubnetAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifySubnetAttribute")
	}

	var r0 *ec2.ModifySubnetAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) *ec2.ModifySubnetAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySubnetAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifySubnetAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifySubnetAttribute'
type EC2_ModifySubnetAttribute_Call struct {
	*mock.Call
}

// ModifySubnetAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifySubnetAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifySubnetAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifySubnetAttribute_Call {
	return &EC2_ModifySubnetAttribute_Call{Call: _e.mock.On("ModifySubnetAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifySubnetAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifySubnetAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifySubnetAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifySubnetAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifySubnetAttribute_Call) Return(_a0 *ec2.ModifySubnetAttributeOutput, _a1 error) *EC2_ModifySubnetAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifySubnetAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error)) *EC2_ModifySubnetAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyTrafficMirrorFilterNetworkServices provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTrafficMirrorFilterNetworkServices(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrafficMirrorFilterNetworkServices")
	}

	var r0 *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyTrafficMirrorFilterNetworkServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyTrafficMirrorFilterNetworkServices'
type EC2_ModifyTrafficMirrorFilterNetworkServices_Call struct {
	*mock.Call
}

// ModifyTrafficMirrorFilterNetworkServices is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyTrafficMirrorFilterNetworkServicesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyTrafficMirrorFilterNetworkServices(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyTrafficMirrorFilterNetworkServices_Call {
	return &EC2_ModifyTrafficMirrorFilterNetworkServices_Call{Call: _e.mock.On("ModifyTrafficMirrorFilterNetworkServices",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyTrafficMirrorFilterNetworkServices_Call) Run(run func(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, optFns ...func(*ec2.Options))) *EC2_ModifyTrafficMirrorFilterNetworkServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyTrafficMirrorFilterNetworkServicesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyTrafficMirrorFilterNetworkServices_Call) Return(_a0 *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, _a1 error) *EC2_ModifyTrafficMirrorFilterNetworkServices_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyTrafficMirrorFilterNetworkServices_Call) RunAndReturn(run func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error)) *EC2_ModifyTrafficMirrorFilterNetworkServices_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTrafficMirrorFilterRule(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrafficMirrorFilterRule")
	}

	var r0 *ec2.ModifyTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyTrafficMirrorFilterRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyTrafficMirrorFilterRule'
type EC2_ModifyTrafficMirrorFilterRule_Call struct {
	*mock.Call
}

// ModifyTrafficMirrorFilterRule is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyTrafficMirrorFilterRuleInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyTrafficMirrorFilterRule(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyTrafficMirrorFilterRule_Call {
	return &EC2_ModifyTrafficMirrorFilterRule_Call{Call: _e.mock.On("ModifyTrafficMirrorFilterRule",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyTrafficMirrorFilterRule_Call) Run(run func(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options))) *EC2_ModifyTrafficMirrorFilterRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyTrafficMirrorFilterRuleInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyTrafficMirrorFilterRule_Call) Return(_a0 *ec2.ModifyTrafficMirrorFilterRuleOutput, _a1 error) *EC2_ModifyTrafficMirrorFilterRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyTrafficMirrorFilterRule_Call) RunAndReturn(run func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error)) *EC2_ModifyTrafficMirrorFilterRule_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTrafficMirrorSession(ctx context.Context, params *ec2.ModifyTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTrafficMirrorSession")
	}

	var r0 *ec2.ModifyTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyTrafficMirrorSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyTrafficMirrorSession'
type EC2_ModifyTrafficMirrorSession_Call struct {
	*mock.Call
}

// ModifyTrafficMirrorSession is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyTrafficMirrorSessionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyTrafficMirrorSession(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyTrafficMirrorSession_Call {
	return &EC2_ModifyTrafficMirrorSession_Call{Call: _e.mock.On("ModifyTrafficMirrorSession",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyTrafficMirrorSession_Call) Run(run func(ctx context.Context, params *ec2.ModifyTrafficMirrorSessionInput, optFns ...func(*ec2.Options))) *EC2_ModifyTrafficMirrorSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyTrafficMirrorSessionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyTrafficMirrorSession_Call) Return(_a0 *ec2.ModifyTrafficMirrorSessionOutput, _a1 error) *EC2_ModifyTrafficMirrorSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyTrafficMirrorSession_Call) RunAndReturn(run func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error)) *EC2_ModifyTrafficMirrorSession_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTransitGateway(ctx context.Context, params *ec2.ModifyTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGateway")
	}

	var r0 *ec2.ModifyTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyTransitGateway_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyTransitGateway'
type EC2_ModifyTransitGateway_Call struct {
	*mock.Call
}

// ModifyTransitGateway is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyTransitGatewayInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyTransitGateway(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyTransitGateway_Call {
	return &EC2_ModifyTransitGateway_Call{Call: _e.mock.On("ModifyTransitGateway",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyTransitGateway_Call) Run(run func(ctx context.Context, params *ec2.ModifyTransitGatewayInput, optFns ...func(*ec2.Options))) *EC2_ModifyTransitGateway_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyTransitGatewayInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyTransitGateway_Call) Return(_a0 *ec2.ModifyTransitGatewayOutput, _a1 error) *EC2_ModifyTransitGateway_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyTransitGateway_Call) RunAndReturn(run func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error)) *EC2_ModifyTransitGateway_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTransitGatewayPrefixListReference(ctx context.Context, params *ec2.ModifyTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGatewayPrefixListReference")
	}

	var r0 *ec2.ModifyTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyTransitGatewayPrefixListReference_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyTransitGatewayPrefixListReference'
type EC2_ModifyTransitGatewayPrefixListReference_Call struct {
	*mock.Call
}

// ModifyTransitGatewayPrefixListReference is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyTransitGatewayPrefixListReferenceInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyTransitGatewayPrefixListReference(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyTransitGatewayPrefixListReference_Call {
	return &EC2_ModifyTransitGatewayPrefixListReference_Call{Call: _e.mock.On("ModifyTransitGatewayPrefixListReference",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyTransitGatewayPrefixListReference_Call) Run(run func(ctx context.Context, params *ec2.ModifyTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options))) *EC2_ModifyTransitGatewayPrefixListReference_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyTransitGatewayPrefixListReferenceInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyTransitGatewayPrefixListReference_Call) Return(_a0 *ec2.ModifyTransitGatewayPrefixListReferenceOutput, _a1 error) *EC2_ModifyTransitGatewayPrefixListReference_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyTransitGatewayPrefixListReference_Call) RunAndReturn(run func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error)) *EC2_ModifyTransitGatewayPrefixListReference_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTransitGatewayVpcAttachment(ctx context.Context, params *ec2.ModifyTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyTransitGatewayVpcAttachment")
	}

	var r0 *ec2.ModifyTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyTransitGatewayVpcAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyTransitGatewayVpcAttachment'
type EC2_ModifyTransitGatewayVpcAttachment_Call struct {
	*mock.Call
}

// ModifyTransitGatewayVpcAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyTransitGatewayVpcAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyTransitGatewayVpcAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyTransitGatewayVpcAttachment_Call {
	return &EC2_ModifyTransitGatewayVpcAttachment_Call{Call: _e.mock.On("ModifyTransitGatewayVpcAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyTransitGatewayVpcAttachment_Call) Run(run func(ctx context.Context, params *ec2.ModifyTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options))) *EC2_ModifyTransitGatewayVpcAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyTransitGatewayVpcAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyTransitGatewayVpcAttachment_Call) Return(_a0 *ec2.ModifyTransitGatewayVpcAttachmentOutput, _a1 error) *EC2_ModifyTransitGatewayVpcAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyTransitGatewayVpcAttachment_Call) RunAndReturn(run func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error)) *EC2_ModifyTransitGatewayVpcAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVolume(ctx context.Context, params *ec2.ModifyVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVolume")
	}

	var r0 *ec2.ModifyVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) *ec2.ModifyVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVolume'
type EC2_ModifyVolume_Call struct {
	*mock.Call
}

// ModifyVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVolumeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVolume(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVolume_Call {
	return &EC2_ModifyVolume_Call{Call: _e.mock.On("ModifyVolume",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVolume_Call) Run(run func(ctx context.Context, params *ec2.ModifyVolumeInput, optFns ...func(*ec2.Options))) *EC2_ModifyVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVolumeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVolume_Call) Return(_a0 *ec2.ModifyVolumeOutput, _a1 error) *EC2_ModifyVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVolume_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error)) *EC2_ModifyVolume_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVolumeAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVolumeAttribute(ctx context.Context, params *ec2.ModifyVolumeAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVolumeAttribute")
	}

	var r0 *ec2.ModifyVolumeAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) *ec2.ModifyVolumeAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVolumeAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVolumeAttribute'
type EC2_ModifyVolumeAttribute_Call struct {
	*mock.Call
}

// ModifyVolumeAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVolumeAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVolumeAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVolumeAttribute_Call {
	return &EC2_ModifyVolumeAttribute_Call{Call: _e.mock.On("ModifyVolumeAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVolumeAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyVolumeAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyVolumeAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVolumeAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVolumeAttribute_Call) Return(_a0 *ec2.ModifyVolumeAttributeOutput, _a1 error) *EC2_ModifyVolumeAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVolumeAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error)) *EC2_ModifyVolumeAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcAttribute(ctx context.Context, params *ec2.ModifyVpcAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcAttribute")
	}

	var r0 *ec2.ModifyVpcAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) *ec2.ModifyVpcAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcAttribute'
type EC2_ModifyVpcAttribute_Call struct {
	*mock.Call
}

// ModifyVpcAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcAttribute_Call {
	return &EC2_ModifyVpcAttribute_Call{Call: _e.mock.On("ModifyVpcAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcAttribute_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcAttributeInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcAttribute_Call) Return(_a0 *ec2.ModifyVpcAttributeOutput, _a1 error) *EC2_ModifyVpcAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error)) *EC2_ModifyVpcAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpoint(ctx context.Context, params *ec2.ModifyVpcEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpoint")
	}

	var r0 *ec2.ModifyVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcEndpoint'
type EC2_ModifyVpcEndpoint_Call struct {
	*mock.Call
}

// ModifyVpcEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcEndpointInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcEndpoint(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcEndpoint_Call {
	return &EC2_ModifyVpcEndpoint_Call{Call: _e.mock.On("ModifyVpcEndpoint",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcEndpoint_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcEndpointInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcEndpointInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcEndpoint_Call) Return(_a0 *ec2.ModifyVpcEndpointOutput, _a1 error) *EC2_ModifyVpcEndpoint_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcEndpoint_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error)) *EC2_ModifyVpcEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcEndpointConnectionNotification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointConnectionNotification(ctx context.Context, params *ec2.ModifyVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointConnectionNotification")
	}

	var r0 *ec2.ModifyVpcEndpointConnectionNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointConnectionNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcEndpointConnectionNotification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcEndpointConnectionNotification'
type EC2_ModifyVpcEndpointConnectionNotification_Call struct {
	*mock.Call
}

// ModifyVpcEndpointConnectionNotification is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcEndpointConnectionNotificationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcEndpointConnectionNotification(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcEndpointConnectionNotification_Call {
	return &EC2_ModifyVpcEndpointConnectionNotification_Call{Call: _e.mock.On("ModifyVpcEndpointConnectionNotification",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcEndpointConnectionNotification_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcEndpointConnectionNotification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcEndpointConnectionNotificationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcEndpointConnectionNotification_Call) Return(_a0 *ec2.ModifyVpcEndpointConnectionNotificationOutput, _a1 error) *EC2_ModifyVpcEndpointConnectionNotification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcEndpointConnectionNotification_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error)) *EC2_ModifyVpcEndpointConnectionNotification_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcEndpointServiceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointServiceConfiguration(ctx context.Context, params *ec2.ModifyVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointServiceConfiguration")
	}

	var r0 *ec2.ModifyVpcEndpointServiceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServiceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcEndpointServiceConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcEndpointServiceConfiguration'
type EC2_ModifyVpcEndpointServiceConfiguration_Call struct {
	*mock.Call
}

// ModifyVpcEndpointServiceConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcEndpointServiceConfigurationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcEndpointServiceConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcEndpointServiceConfiguration_Call {
	return &EC2_ModifyVpcEndpointServiceConfiguration_Call{Call: _e.mock.On("ModifyVpcEndpointServiceConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcEndpointServiceConfiguration_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcEndpointServiceConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcEndpointServiceConfigurationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcEndpointServiceConfiguration_Call) Return(_a0 *ec2.ModifyVpcEndpointServiceConfigurationOutput, _a1 error) *EC2_ModifyVpcEndpointServiceConfiguration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcEndpointServiceConfiguration_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error)) *EC2_ModifyVpcEndpointServiceConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcEndpointServicePayerResponsibility provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointServicePayerResponsibility(ctx context.Context, params *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointServicePayerResponsibility")
	}

	var r0 *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcEndpointServicePayerResponsibility_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcEndpointServicePayerResponsibility'
type EC2_ModifyVpcEndpointServicePayerResponsibility_Call struct {
	*mock.Call
}

// ModifyVpcEndpointServicePayerResponsibility is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcEndpointServicePayerResponsibilityInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcEndpointServicePayerResponsibility(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcEndpointServicePayerResponsibility_Call {
	return &EC2_ModifyVpcEndpointServicePayerResponsibility_Call{Call: _e.mock.On("ModifyVpcEndpointServicePayerResponsibility",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcEndpointServicePayerResponsibility_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcEndpointServicePayerResponsibility_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcEndpointServicePayerResponsibilityInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcEndpointServicePayerResponsibility_Call) Return(_a0 *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, _a1 error) *EC2_ModifyVpcEndpointServicePayerResponsibility_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcEndpointServicePayerResponsibility_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error)) *EC2_ModifyVpcEndpointServicePayerResponsibility_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcEndpointServicePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointServicePermissions(ctx context.Context, params *ec2.ModifyVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcEndpointServicePermissions")
	}

	var r0 *ec2.ModifyVpcEndpointServicePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcEndpointServicePermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcEndpointServicePermissions'
type EC2_ModifyVpcEndpointServicePermissions_Call struct {
	*mock.Call
}

// ModifyVpcEndpointServicePermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcEndpointServicePermissionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcEndpointServicePermissions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcEndpointServicePermissions_Call {
	return &EC2_ModifyVpcEndpointServicePermissions_Call{Call: _e.mock.On("ModifyVpcEndpointServicePermissions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcEndpointServicePermissions_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcEndpointServicePermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcEndpointServicePermissionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcEndpointServicePermissions_Call) Return(_a0 *ec2.ModifyVpcEndpointServicePermissionsOutput, _a1 error) *EC2_ModifyVpcEndpointServicePermissions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcEndpointServicePermissions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error)) *EC2_ModifyVpcEndpointServicePermissions_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcPeeringConnectionOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcPeeringConnectionOptions(ctx context.Context, params *ec2.ModifyVpcPeeringConnectionOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcPeeringConnectionOptions")
	}

	var r0 *ec2.ModifyVpcPeeringConnectionOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcPeeringConnectionOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcPeeringConnectionOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcPeeringConnectionOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcPeeringConnectionOptions'
type EC2_ModifyVpcPeeringConnectionOptions_Call struct {
	*mock.Call
}

// ModifyVpcPeeringConnectionOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcPeeringConnectionOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcPeeringConnectionOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcPeeringConnectionOptions_Call {
	return &EC2_ModifyVpcPeeringConnectionOptions_Call{Call: _e.mock.On("ModifyVpcPeeringConnectionOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcPeeringConnectionOptions_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcPeeringConnectionOptionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcPeeringConnectionOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcPeeringConnectionOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcPeeringConnectionOptions_Call) Return(_a0 *ec2.ModifyVpcPeeringConnectionOptionsOutput, _a1 error) *EC2_ModifyVpcPeeringConnectionOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcPeeringConnectionOptions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error)) *EC2_ModifyVpcPeeringConnectionOptions_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpcTenancy provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcTenancy(ctx context.Context, params *ec2.ModifyVpcTenancyInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpcTenancy")
	}

	var r0 *ec2.ModifyVpcTenancyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) *ec2.ModifyVpcTenancyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcTenancyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpcTenancy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpcTenancy'
type EC2_ModifyVpcTenancy_Call struct {
	*mock.Call
}

// ModifyVpcTenancy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpcTenancyInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpcTenancy(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpcTenancy_Call {
	return &EC2_ModifyVpcTenancy_Call{Call: _e.mock.On("ModifyVpcTenancy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpcTenancy_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpcTenancyInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpcTenancy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpcTenancyInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpcTenancy_Call) Return(_a0 *ec2.ModifyVpcTenancyOutput, _a1 error) *EC2_ModifyVpcTenancy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpcTenancy_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error)) *EC2_ModifyVpcTenancy_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnConnection(ctx context.Context, params *ec2.ModifyVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnConnection")
	}

	var r0 *ec2.ModifyVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) *ec2.ModifyVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpnConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpnConnection'
type EC2_ModifyVpnConnection_Call struct {
	*mock.Call
}

// ModifyVpnConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpnConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpnConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpnConnection_Call {
	return &EC2_ModifyVpnConnection_Call{Call: _e.mock.On("ModifyVpnConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpnConnection_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpnConnectionInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpnConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpnConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpnConnection_Call) Return(_a0 *ec2.ModifyVpnConnectionOutput, _a1 error) *EC2_ModifyVpnConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpnConnection_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error)) *EC2_ModifyVpnConnection_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpnConnectionOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnConnectionOptions(ctx context.Context, params *ec2.ModifyVpnConnectionOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnConnectionOptions")
	}

	var r0 *ec2.ModifyVpnConnectionOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpnConnectionOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpnConnectionOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpnConnectionOptions'
type EC2_ModifyVpnConnectionOptions_Call struct {
	*mock.Call
}

// ModifyVpnConnectionOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpnConnectionOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpnConnectionOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpnConnectionOptions_Call {
	return &EC2_ModifyVpnConnectionOptions_Call{Call: _e.mock.On("ModifyVpnConnectionOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpnConnectionOptions_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpnConnectionOptionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpnConnectionOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpnConnectionOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpnConnectionOptions_Call) Return(_a0 *ec2.ModifyVpnConnectionOptionsOutput, _a1 error) *EC2_ModifyVpnConnectionOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpnConnectionOptions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error)) *EC2_ModifyVpnConnectionOptions_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpnTunnelCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnTunnelCertificate(ctx context.Context, params *ec2.ModifyVpnTunnelCertificateInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnTunnelCertificate")
	}

	var r0 *ec2.ModifyVpnTunnelCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) *ec2.ModifyVpnTunnelCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpnTunnelCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpnTunnelCertificate'
type EC2_ModifyVpnTunnelCertificate_Call struct {
	*mock.Call
}

// ModifyVpnTunnelCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpnTunnelCertificateInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpnTunnelCertificate(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpnTunnelCertificate_Call {
	return &EC2_ModifyVpnTunnelCertificate_Call{Call: _e.mock.On("ModifyVpnTunnelCertificate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpnTunnelCertificate_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpnTunnelCertificateInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpnTunnelCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpnTunnelCertificateInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpnTunnelCertificate_Call) Return(_a0 *ec2.ModifyVpnTunnelCertificateOutput, _a1 error) *EC2_ModifyVpnTunnelCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpnTunnelCertificate_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error)) *EC2_ModifyVpnTunnelCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyVpnTunnelOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnTunnelOptions(ctx context.Context, params *ec2.ModifyVpnTunnelOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyVpnTunnelOptions")
	}

	var r0 *ec2.ModifyVpnTunnelOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpnTunnelOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ModifyVpnTunnelOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyVpnTunnelOptions'
type EC2_ModifyVpnTunnelOptions_Call struct {
	*mock.Call
}

// ModifyVpnTunnelOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ModifyVpnTunnelOptionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ModifyVpnTunnelOptions(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ModifyVpnTunnelOptions_Call {
	return &EC2_ModifyVpnTunnelOptions_Call{Call: _e.mock.On("ModifyVpnTunnelOptions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ModifyVpnTunnelOptions_Call) Run(run func(ctx context.Context, params *ec2.ModifyVpnTunnelOptionsInput, optFns ...func(*ec2.Options))) *EC2_ModifyVpnTunnelOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ModifyVpnTunnelOptionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ModifyVpnTunnelOptions_Call) Return(_a0 *ec2.ModifyVpnTunnelOptionsOutput, _a1 error) *EC2_ModifyVpnTunnelOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ModifyVpnTunnelOptions_Call) RunAndReturn(run func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error)) *EC2_ModifyVpnTunnelOptions_Call {
	_c.Call.Return(run)
	return _c
}

// MonitorInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) MonitorInstances(ctx context.Context, params *ec2.MonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MonitorInstances")
	}

	var r0 *ec2.MonitorInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) *ec2.MonitorInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MonitorInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_MonitorInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MonitorInstances'
type EC2_MonitorInstances_Call struct {
	*mock.Call
}

// MonitorInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.MonitorInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) MonitorInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_MonitorInstances_Call {
	return &EC2_MonitorInstances_Call{Call: _e.mock.On("MonitorInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_MonitorInstances_Call) Run(run func(ctx context.Context, params *ec2.MonitorInstancesInput, optFns ...func(*ec2.Options))) *EC2_MonitorInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.MonitorInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_MonitorInstances_Call) Return(_a0 *ec2.MonitorInstancesOutput, _a1 error) *EC2_MonitorInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_MonitorInstances_Call) RunAndReturn(run func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error)) *EC2_MonitorInstances_Call {
	_c.Call.Return(run)
	return _c
}

// MoveAddressToVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) MoveAddressToVpc(ctx context.Context, params *ec2.MoveAddressToVpcInput, optFns ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MoveAddressToVpc")
	}

	var r0 *ec2.MoveAddressToVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) *ec2.MoveAddressToVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveAddressToVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_MoveAddressToVpc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveAddressToVpc'
type EC2_MoveAddressToVpc_Call struct {
	*mock.Call
}

// MoveAddressToVpc is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.MoveAddressToVpcInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) MoveAddressToVpc(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_MoveAddressToVpc_Call {
	return &EC2_MoveAddressToVpc_Call{Call: _e.mock.On("MoveAddressToVpc",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_MoveAddressToVpc_Call) Run(run func(ctx context.Context, params *ec2.MoveAddressToVpcInput, optFns ...func(*ec2.Options))) *EC2_MoveAddressToVpc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.MoveAddressToVpcInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_MoveAddressToVpc_Call) Return(_a0 *ec2.MoveAddressToVpcOutput, _a1 error) *EC2_MoveAddressToVpc_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_MoveAddressToVpc_Call) RunAndReturn(run func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error)) *EC2_MoveAddressToVpc_Call {
	_c.Call.Return(run)
	return _c
}

// MoveByoipCidrToIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) MoveByoipCidrToIpam(ctx context.Context, params *ec2.MoveByoipCidrToIpamInput, optFns ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MoveByoipCidrToIpam")
	}

	var r0 *ec2.MoveByoipCidrToIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) *ec2.MoveByoipCidrToIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveByoipCidrToIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_MoveByoipCidrToIpam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveByoipCidrToIpam'
type EC2_MoveByoipCidrToIpam_Call struct {
	*mock.Call
}

// MoveByoipCidrToIpam is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.MoveByoipCidrToIpamInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) MoveByoipCidrToIpam(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_MoveByoipCidrToIpam_Call {
	return &EC2_MoveByoipCidrToIpam_Call{Call: _e.mock.On("MoveByoipCidrToIpam",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_MoveByoipCidrToIpam_Call) Run(run func(ctx context.Context, params *ec2.MoveByoipCidrToIpamInput, optFns ...func(*ec2.Options))) *EC2_MoveByoipCidrToIpam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.MoveByoipCidrToIpamInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_MoveByoipCidrToIpam_Call) Return(_a0 *ec2.MoveByoipCidrToIpamOutput, _a1 error) *EC2_MoveByoipCidrToIpam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_MoveByoipCidrToIpam_Call) RunAndReturn(run func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error)) *EC2_MoveByoipCidrToIpam_Call {
	_c.Call.Return(run)
	return _c
}

// ProvisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ProvisionByoipCidr(ctx context.Context, params *ec2.ProvisionByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionByoipCidr")
	}

	var r0 *ec2.ProvisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) *ec2.ProvisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ProvisionByoipCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProvisionByoipCidr'
type EC2_ProvisionByoipCidr_Call struct {
	*mock.Call
}

// ProvisionByoipCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ProvisionByoipCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ProvisionByoipCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ProvisionByoipCidr_Call {
	return &EC2_ProvisionByoipCidr_Call{Call: _e.mock.On("ProvisionByoipCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ProvisionByoipCidr_Call) Run(run func(ctx context.Context, params *ec2.ProvisionByoipCidrInput, optFns ...func(*ec2.Options))) *EC2_ProvisionByoipCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ProvisionByoipCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ProvisionByoipCidr_Call) Return(_a0 *ec2.ProvisionByoipCidrOutput, _a1 error) *EC2_ProvisionByoipCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ProvisionByoipCidr_Call) RunAndReturn(run func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error)) *EC2_ProvisionByoipCidr_Call {
	_c.Call.Return(run)
	return _c
}

// ProvisionIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ProvisionIpamPoolCidr(ctx context.Context, params *ec2.ProvisionIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionIpamPoolCidr")
	}

	var r0 *ec2.ProvisionIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.ProvisionIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ProvisionIpamPoolCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProvisionIpamPoolCidr'
type EC2_ProvisionIpamPoolCidr_Call struct {
	*mock.Call
}

// ProvisionIpamPoolCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ProvisionIpamPoolCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ProvisionIpamPoolCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ProvisionIpamPoolCidr_Call {
	return &EC2_ProvisionIpamPoolCidr_Call{Call: _e.mock.On("ProvisionIpamPoolCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ProvisionIpamPoolCidr_Call) Run(run func(ctx context.Context, params *ec2.ProvisionIpamPoolCidrInput, optFns ...func(*ec2.Options))) *EC2_ProvisionIpamPoolCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ProvisionIpamPoolCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ProvisionIpamPoolCidr_Call) Return(_a0 *ec2.ProvisionIpamPoolCidrOutput, _a1 error) *EC2_ProvisionIpamPoolCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ProvisionIpamPoolCidr_Call) RunAndReturn(run func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error)) *EC2_ProvisionIpamPoolCidr_Call {
	_c.Call.Return(run)
	return _c
}

// ProvisionPublicIpv4PoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ProvisionPublicIpv4PoolCidr(ctx context.Context, params *ec2.ProvisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProvisionPublicIpv4PoolCidr")
	}

	var r0 *ec2.ProvisionPublicIpv4PoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) *ec2.ProvisionPublicIpv4PoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionPublicIpv4PoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ProvisionPublicIpv4PoolCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProvisionPublicIpv4PoolCidr'
type EC2_ProvisionPublicIpv4PoolCidr_Call struct {
	*mock.Call
}

// ProvisionPublicIpv4PoolCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ProvisionPublicIpv4PoolCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ProvisionPublicIpv4PoolCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ProvisionPublicIpv4PoolCidr_Call {
	return &EC2_ProvisionPublicIpv4PoolCidr_Call{Call: _e.mock.On("ProvisionPublicIpv4PoolCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ProvisionPublicIpv4PoolCidr_Call) Run(run func(ctx context.Context, params *ec2.ProvisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options))) *EC2_ProvisionPublicIpv4PoolCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ProvisionPublicIpv4PoolCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ProvisionPublicIpv4PoolCidr_Call) Return(_a0 *ec2.ProvisionPublicIpv4PoolCidrOutput, _a1 error) *EC2_ProvisionPublicIpv4PoolCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ProvisionPublicIpv4PoolCidr_Call) RunAndReturn(run func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error)) *EC2_ProvisionPublicIpv4PoolCidr_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseHostReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) PurchaseHostReservation(ctx context.Context, params *ec2.PurchaseHostReservationInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseHostReservation")
	}

	var r0 *ec2.PurchaseHostReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) *ec2.PurchaseHostReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseHostReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_PurchaseHostReservation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseHostReservation'
type EC2_PurchaseHostReservation_Call struct {
	*mock.Call
}

// PurchaseHostReservation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.PurchaseHostReservationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) PurchaseHostReservation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_PurchaseHostReservation_Call {
	return &EC2_PurchaseHostReservation_Call{Call: _e.mock.On("PurchaseHostReservation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_PurchaseHostReservation_Call) Run(run func(ctx context.Context, params *ec2.PurchaseHostReservationInput, optFns ...func(*ec2.Options))) *EC2_PurchaseHostReservation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.PurchaseHostReservationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_PurchaseHostReservation_Call) Return(_a0 *ec2.PurchaseHostReservationOutput, _a1 error) *EC2_PurchaseHostReservation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_PurchaseHostReservation_Call) RunAndReturn(run func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error)) *EC2_PurchaseHostReservation_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseReservedInstancesOffering provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) PurchaseReservedInstancesOffering(ctx context.Context, params *ec2.PurchaseReservedInstancesOfferingInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseReservedInstancesOffering")
	}

	var r0 *ec2.PurchaseReservedInstancesOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) *ec2.PurchaseReservedInstancesOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseReservedInstancesOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_PurchaseReservedInstancesOffering_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseReservedInstancesOffering'
type EC2_PurchaseReservedInstancesOffering_Call struct {
	*mock.Call
}

// PurchaseReservedInstancesOffering is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.PurchaseReservedInstancesOfferingInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) PurchaseReservedInstancesOffering(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_PurchaseReservedInstancesOffering_Call {
	return &EC2_PurchaseReservedInstancesOffering_Call{Call: _e.mock.On("PurchaseReservedInstancesOffering",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_PurchaseReservedInstancesOffering_Call) Run(run func(ctx context.Context, params *ec2.PurchaseReservedInstancesOfferingInput, optFns ...func(*ec2.Options))) *EC2_PurchaseReservedInstancesOffering_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.PurchaseReservedInstancesOfferingInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_PurchaseReservedInstancesOffering_Call) Return(_a0 *ec2.PurchaseReservedInstancesOfferingOutput, _a1 error) *EC2_PurchaseReservedInstancesOffering_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_PurchaseReservedInstancesOffering_Call) RunAndReturn(run func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error)) *EC2_PurchaseReservedInstancesOffering_Call {
	_c.Call.Return(run)
	return _c
}

// PurchaseScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) PurchaseScheduledInstances(ctx context.Context, params *ec2.PurchaseScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PurchaseScheduledInstances")
	}

	var r0 *ec2.PurchaseScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) *ec2.PurchaseScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_PurchaseScheduledInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PurchaseScheduledInstances'
type EC2_PurchaseScheduledInstances_Call struct {
	*mock.Call
}

// PurchaseScheduledInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.PurchaseScheduledInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) PurchaseScheduledInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_PurchaseScheduledInstances_Call {
	return &EC2_PurchaseScheduledInstances_Call{Call: _e.mock.On("PurchaseScheduledInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_PurchaseScheduledInstances_Call) Run(run func(ctx context.Context, params *ec2.PurchaseScheduledInstancesInput, optFns ...func(*ec2.Options))) *EC2_PurchaseScheduledInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.PurchaseScheduledInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_PurchaseScheduledInstances_Call) Return(_a0 *ec2.PurchaseScheduledInstancesOutput, _a1 error) *EC2_PurchaseScheduledInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_PurchaseScheduledInstances_Call) RunAndReturn(run func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error)) *EC2_PurchaseScheduledInstances_Call {
	_c.Call.Return(run)
	return _c
}

// RebootInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RebootInstances(ctx context.Context, params *ec2.RebootInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebootInstances")
	}

	var r0 *ec2.RebootInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) *ec2.RebootInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RebootInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RebootInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RebootInstances'
type EC2_RebootInstances_Call struct {
	*mock.Call
}

// RebootInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RebootInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RebootInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RebootInstances_Call {
	return &EC2_RebootInstances_Call{Call: _e.mock.On("RebootInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RebootInstances_Call) Run(run func(ctx context.Context, params *ec2.RebootInstancesInput, optFns ...func(*ec2.Options))) *EC2_RebootInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RebootInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RebootInstances_Call) Return(_a0 *ec2.RebootInstancesOutput, _a1 error) *EC2_RebootInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RebootInstances_Call) RunAndReturn(run func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error)) *EC2_RebootInstances_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterImage(ctx context.Context, params *ec2.RegisterImageInput, optFns ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterImage")
	}

	var r0 *ec2.RegisterImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) *ec2.RegisterImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RegisterImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterImage'
type EC2_RegisterImage_Call struct {
	*mock.Call
}

// RegisterImage is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RegisterImageInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RegisterImage(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RegisterImage_Call {
	return &EC2_RegisterImage_Call{Call: _e.mock.On("RegisterImage",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RegisterImage_Call) Run(run func(ctx context.Context, params *ec2.RegisterImageInput, optFns ...func(*ec2.Options))) *EC2_RegisterImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RegisterImageInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RegisterImage_Call) Return(_a0 *ec2.RegisterImageOutput, _a1 error) *EC2_RegisterImage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RegisterImage_Call) RunAndReturn(run func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error)) *EC2_RegisterImage_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterInstanceEventNotificationAttributes(ctx context.Context, params *ec2.RegisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterInstanceEventNotificationAttributes")
	}

	var r0 *ec2.RegisterInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.RegisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RegisterInstanceEventNotificationAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterInstanceEventNotificationAttributes'
type EC2_RegisterInstanceEventNotificationAttributes_Call struct {
	*mock.Call
}

// RegisterInstanceEventNotificationAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RegisterInstanceEventNotificationAttributesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RegisterInstanceEventNotificationAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RegisterInstanceEventNotificationAttributes_Call {
	return &EC2_RegisterInstanceEventNotificationAttributes_Call{Call: _e.mock.On("RegisterInstanceEventNotificationAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RegisterInstanceEventNotificationAttributes_Call) Run(run func(ctx context.Context, params *ec2.RegisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options))) *EC2_RegisterInstanceEventNotificationAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RegisterInstanceEventNotificationAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RegisterInstanceEventNotificationAttributes_Call) Return(_a0 *ec2.RegisterInstanceEventNotificationAttributesOutput, _a1 error) *EC2_RegisterInstanceEventNotificationAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RegisterInstanceEventNotificationAttributes_Call) RunAndReturn(run func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error)) *EC2_RegisterInstanceEventNotificationAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterTransitGatewayMulticastGroupMembers provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterTransitGatewayMulticastGroupMembers(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTransitGatewayMulticastGroupMembers")
	}

	var r0 *ec2.RegisterTransitGatewayMulticastGroupMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) *ec2.RegisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RegisterTransitGatewayMulticastGroupMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterTransitGatewayMulticastGroupMembers'
type EC2_RegisterTransitGatewayMulticastGroupMembers_Call struct {
	*mock.Call
}

// RegisterTransitGatewayMulticastGroupMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RegisterTransitGatewayMulticastGroupMembersInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RegisterTransitGatewayMulticastGroupMembers(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RegisterTransitGatewayMulticastGroupMembers_Call {
	return &EC2_RegisterTransitGatewayMulticastGroupMembers_Call{Call: _e.mock.On("RegisterTransitGatewayMulticastGroupMembers",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RegisterTransitGatewayMulticastGroupMembers_Call) Run(run func(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options))) *EC2_RegisterTransitGatewayMulticastGroupMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RegisterTransitGatewayMulticastGroupMembersInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RegisterTransitGatewayMulticastGroupMembers_Call) Return(_a0 *ec2.RegisterTransitGatewayMulticastGroupMembersOutput, _a1 error) *EC2_RegisterTransitGatewayMulticastGroupMembers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RegisterTransitGatewayMulticastGroupMembers_Call) RunAndReturn(run func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error)) *EC2_RegisterTransitGatewayMulticastGroupMembers_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterTransitGatewayMulticastGroupSources provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterTransitGatewayMulticastGroupSources(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterTransitGatewayMulticastGroupSources")
	}

	var r0 *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RegisterTransitGatewayMulticastGroupSources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterTransitGatewayMulticastGroupSources'
type EC2_RegisterTransitGatewayMulticastGroupSources_Call struct {
	*mock.Call
}

// RegisterTransitGatewayMulticastGroupSources is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RegisterTransitGatewayMulticastGroupSourcesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RegisterTransitGatewayMulticastGroupSources(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RegisterTransitGatewayMulticastGroupSources_Call {
	return &EC2_RegisterTransitGatewayMulticastGroupSources_Call{Call: _e.mock.On("RegisterTransitGatewayMulticastGroupSources",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RegisterTransitGatewayMulticastGroupSources_Call) Run(run func(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options))) *EC2_RegisterTransitGatewayMulticastGroupSources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RegisterTransitGatewayMulticastGroupSourcesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RegisterTransitGatewayMulticastGroupSources_Call) Return(_a0 *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, _a1 error) *EC2_RegisterTransitGatewayMulticastGroupSources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RegisterTransitGatewayMulticastGroupSources_Call) RunAndReturn(run func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error)) *EC2_RegisterTransitGatewayMulticastGroupSources_Call {
	_c.Call.Return(run)
	return _c
}

// RejectTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectTransitGatewayMulticastDomainAssociations")
	}

	var r0 *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RejectTransitGatewayMulticastDomainAssociations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectTransitGatewayMulticastDomainAssociations'
type EC2_RejectTransitGatewayMulticastDomainAssociations_Call struct {
	*mock.Call
}

// RejectTransitGatewayMulticastDomainAssociations is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RejectTransitGatewayMulticastDomainAssociationsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RejectTransitGatewayMulticastDomainAssociations(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RejectTransitGatewayMulticastDomainAssociations_Call {
	return &EC2_RejectTransitGatewayMulticastDomainAssociations_Call{Call: _e.mock.On("RejectTransitGatewayMulticastDomainAssociations",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RejectTransitGatewayMulticastDomainAssociations_Call) Run(run func(ctx context.Context, params *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options))) *EC2_RejectTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RejectTransitGatewayMulticastDomainAssociationsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RejectTransitGatewayMulticastDomainAssociations_Call) Return(_a0 *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, _a1 error) *EC2_RejectTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RejectTransitGatewayMulticastDomainAssociations_Call) RunAndReturn(run func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error)) *EC2_RejectTransitGatewayMulticastDomainAssociations_Call {
	_c.Call.Return(run)
	return _c
}

// RejectTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.RejectTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectTransitGatewayPeeringAttachment")
	}

	var r0 *ec2.RejectTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RejectTransitGatewayPeeringAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectTransitGatewayPeeringAttachment'
type EC2_RejectTransitGatewayPeeringAttachment_Call struct {
	*mock.Call
}

// RejectTransitGatewayPeeringAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RejectTransitGatewayPeeringAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RejectTransitGatewayPeeringAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RejectTransitGatewayPeeringAttachment_Call {
	return &EC2_RejectTransitGatewayPeeringAttachment_Call{Call: _e.mock.On("RejectTransitGatewayPeeringAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RejectTransitGatewayPeeringAttachment_Call) Run(run func(ctx context.Context, params *ec2.RejectTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options))) *EC2_RejectTransitGatewayPeeringAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RejectTransitGatewayPeeringAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RejectTransitGatewayPeeringAttachment_Call) Return(_a0 *ec2.RejectTransitGatewayPeeringAttachmentOutput, _a1 error) *EC2_RejectTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RejectTransitGatewayPeeringAttachment_Call) RunAndReturn(run func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error)) *EC2_RejectTransitGatewayPeeringAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// RejectTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectTransitGatewayVpcAttachment(ctx context.Context, params *ec2.RejectTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectTransitGatewayVpcAttachment")
	}

	var r0 *ec2.RejectTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RejectTransitGatewayVpcAttachment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectTransitGatewayVpcAttachment'
type EC2_RejectTransitGatewayVpcAttachment_Call struct {
	*mock.Call
}

// RejectTransitGatewayVpcAttachment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RejectTransitGatewayVpcAttachmentInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RejectTransitGatewayVpcAttachment(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RejectTransitGatewayVpcAttachment_Call {
	return &EC2_RejectTransitGatewayVpcAttachment_Call{Call: _e.mock.On("RejectTransitGatewayVpcAttachment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RejectTransitGatewayVpcAttachment_Call) Run(run func(ctx context.Context, params *ec2.RejectTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options))) *EC2_RejectTransitGatewayVpcAttachment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RejectTransitGatewayVpcAttachmentInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RejectTransitGatewayVpcAttachment_Call) Return(_a0 *ec2.RejectTransitGatewayVpcAttachmentOutput, _a1 error) *EC2_RejectTransitGatewayVpcAttachment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RejectTransitGatewayVpcAttachment_Call) RunAndReturn(run func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error)) *EC2_RejectTransitGatewayVpcAttachment_Call {
	_c.Call.Return(run)
	return _c
}

// RejectVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectVpcEndpointConnections(ctx context.Context, params *ec2.RejectVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectVpcEndpointConnections")
	}

	var r0 *ec2.RejectVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.RejectVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RejectVpcEndpointConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectVpcEndpointConnections'
type EC2_RejectVpcEndpointConnections_Call struct {
	*mock.Call
}

// RejectVpcEndpointConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RejectVpcEndpointConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RejectVpcEndpointConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RejectVpcEndpointConnections_Call {
	return &EC2_RejectVpcEndpointConnections_Call{Call: _e.mock.On("RejectVpcEndpointConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RejectVpcEndpointConnections_Call) Run(run func(ctx context.Context, params *ec2.RejectVpcEndpointConnectionsInput, optFns ...func(*ec2.Options))) *EC2_RejectVpcEndpointConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RejectVpcEndpointConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RejectVpcEndpointConnections_Call) Return(_a0 *ec2.RejectVpcEndpointConnectionsOutput, _a1 error) *EC2_RejectVpcEndpointConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RejectVpcEndpointConnections_Call) RunAndReturn(run func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error)) *EC2_RejectVpcEndpointConnections_Call {
	_c.Call.Return(run)
	return _c
}

// RejectVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectVpcPeeringConnection(ctx context.Context, params *ec2.RejectVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectVpcPeeringConnection")
	}

	var r0 *ec2.RejectVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.RejectVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RejectVpcPeeringConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectVpcPeeringConnection'
type EC2_RejectVpcPeeringConnection_Call struct {
	*mock.Call
}

// RejectVpcPeeringConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RejectVpcPeeringConnectionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RejectVpcPeeringConnection(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RejectVpcPeeringConnection_Call {
	return &EC2_RejectVpcPeeringConnection_Call{Call: _e.mock.On("RejectVpcPeeringConnection",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RejectVpcPeeringConnection_Call) Run(run func(ctx context.Context, params *ec2.RejectVpcPeeringConnectionInput, optFns ...func(*ec2.Options))) *EC2_RejectVpcPeeringConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RejectVpcPeeringConnectionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RejectVpcPeeringConnection_Call) Return(_a0 *ec2.RejectVpcPeeringConnectionOutput, _a1 error) *EC2_RejectVpcPeeringConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RejectVpcPeeringConnection_Call) RunAndReturn(run func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error)) *EC2_RejectVpcPeeringConnection_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReleaseAddress(ctx context.Context, params *ec2.ReleaseAddressInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseAddress")
	}

	var r0 *ec2.ReleaseAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) *ec2.ReleaseAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReleaseAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseAddress'
type EC2_ReleaseAddress_Call struct {
	*mock.Call
}

// ReleaseAddress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReleaseAddressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReleaseAddress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReleaseAddress_Call {
	return &EC2_ReleaseAddress_Call{Call: _e.mock.On("ReleaseAddress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReleaseAddress_Call) Run(run func(ctx context.Context, params *ec2.ReleaseAddressInput, optFns ...func(*ec2.Options))) *EC2_ReleaseAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReleaseAddressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReleaseAddress_Call) Return(_a0 *ec2.ReleaseAddressOutput, _a1 error) *EC2_ReleaseAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReleaseAddress_Call) RunAndReturn(run func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error)) *EC2_ReleaseAddress_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReleaseHosts(ctx context.Context, params *ec2.ReleaseHostsInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseHosts")
	}

	var r0 *ec2.ReleaseHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) *ec2.ReleaseHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReleaseHosts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseHosts'
type EC2_ReleaseHosts_Call struct {
	*mock.Call
}

// ReleaseHosts is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReleaseHostsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReleaseHosts(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReleaseHosts_Call {
	return &EC2_ReleaseHosts_Call{Call: _e.mock.On("ReleaseHosts",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReleaseHosts_Call) Run(run func(ctx context.Context, params *ec2.ReleaseHostsInput, optFns ...func(*ec2.Options))) *EC2_ReleaseHosts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReleaseHostsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReleaseHosts_Call) Return(_a0 *ec2.ReleaseHostsOutput, _a1 error) *EC2_ReleaseHosts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReleaseHosts_Call) RunAndReturn(run func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error)) *EC2_ReleaseHosts_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseIpamPoolAllocation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReleaseIpamPoolAllocation(ctx context.Context, params *ec2.ReleaseIpamPoolAllocationInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseIpamPoolAllocation")
	}

	var r0 *ec2.ReleaseIpamPoolAllocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) *ec2.ReleaseIpamPoolAllocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseIpamPoolAllocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReleaseIpamPoolAllocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseIpamPoolAllocation'
type EC2_ReleaseIpamPoolAllocation_Call struct {
	*mock.Call
}

// ReleaseIpamPoolAllocation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReleaseIpamPoolAllocationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReleaseIpamPoolAllocation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReleaseIpamPoolAllocation_Call {
	return &EC2_ReleaseIpamPoolAllocation_Call{Call: _e.mock.On("ReleaseIpamPoolAllocation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReleaseIpamPoolAllocation_Call) Run(run func(ctx context.Context, params *ec2.ReleaseIpamPoolAllocationInput, optFns ...func(*ec2.Options))) *EC2_ReleaseIpamPoolAllocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReleaseIpamPoolAllocationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReleaseIpamPoolAllocation_Call) Return(_a0 *ec2.ReleaseIpamPoolAllocationOutput, _a1 error) *EC2_ReleaseIpamPoolAllocation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReleaseIpamPoolAllocation_Call) RunAndReturn(run func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error)) *EC2_ReleaseIpamPoolAllocation_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceIamInstanceProfileAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceIamInstanceProfileAssociation(ctx context.Context, params *ec2.ReplaceIamInstanceProfileAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceIamInstanceProfileAssociation")
	}

	var r0 *ec2.ReplaceIamInstanceProfileAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceIamInstanceProfileAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceIamInstanceProfileAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReplaceIamInstanceProfileAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceIamInstanceProfileAssociation'
type EC2_ReplaceIamInstanceProfileAssociation_Call struct {
	*mock.Call
}

// ReplaceIamInstanceProfileAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReplaceIamInstanceProfileAssociationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReplaceIamInstanceProfileAssociation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReplaceIamInstanceProfileAssociation_Call {
	return &EC2_ReplaceIamInstanceProfileAssociation_Call{Call: _e.mock.On("ReplaceIamInstanceProfileAssociation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReplaceIamInstanceProfileAssociation_Call) Run(run func(ctx context.Context, params *ec2.ReplaceIamInstanceProfileAssociationInput, optFns ...func(*ec2.Options))) *EC2_ReplaceIamInstanceProfileAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReplaceIamInstanceProfileAssociationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReplaceIamInstanceProfileAssociation_Call) Return(_a0 *ec2.ReplaceIamInstanceProfileAssociationOutput, _a1 error) *EC2_ReplaceIamInstanceProfileAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReplaceIamInstanceProfileAssociation_Call) RunAndReturn(run func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error)) *EC2_ReplaceIamInstanceProfileAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceNetworkAclAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceNetworkAclAssociation(ctx context.Context, params *ec2.ReplaceNetworkAclAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceNetworkAclAssociation")
	}

	var r0 *ec2.ReplaceNetworkAclAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceNetworkAclAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReplaceNetworkAclAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceNetworkAclAssociation'
type EC2_ReplaceNetworkAclAssociation_Call struct {
	*mock.Call
}

// ReplaceNetworkAclAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReplaceNetworkAclAssociationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReplaceNetworkAclAssociation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReplaceNetworkAclAssociation_Call {
	return &EC2_ReplaceNetworkAclAssociation_Call{Call: _e.mock.On("ReplaceNetworkAclAssociation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReplaceNetworkAclAssociation_Call) Run(run func(ctx context.Context, params *ec2.ReplaceNetworkAclAssociationInput, optFns ...func(*ec2.Options))) *EC2_ReplaceNetworkAclAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReplaceNetworkAclAssociationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReplaceNetworkAclAssociation_Call) Return(_a0 *ec2.ReplaceNetworkAclAssociationOutput, _a1 error) *EC2_ReplaceNetworkAclAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReplaceNetworkAclAssociation_Call) RunAndReturn(run func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error)) *EC2_ReplaceNetworkAclAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceNetworkAclEntry(ctx context.Context, params *ec2.ReplaceNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceNetworkAclEntry")
	}

	var r0 *ec2.ReplaceNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.ReplaceNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReplaceNetworkAclEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceNetworkAclEntry'
type EC2_ReplaceNetworkAclEntry_Call struct {
	*mock.Call
}

// ReplaceNetworkAclEntry is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReplaceNetworkAclEntryInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReplaceNetworkAclEntry(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReplaceNetworkAclEntry_Call {
	return &EC2_ReplaceNetworkAclEntry_Call{Call: _e.mock.On("ReplaceNetworkAclEntry",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReplaceNetworkAclEntry_Call) Run(run func(ctx context.Context, params *ec2.ReplaceNetworkAclEntryInput, optFns ...func(*ec2.Options))) *EC2_ReplaceNetworkAclEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReplaceNetworkAclEntryInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReplaceNetworkAclEntry_Call) Return(_a0 *ec2.ReplaceNetworkAclEntryOutput, _a1 error) *EC2_ReplaceNetworkAclEntry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReplaceNetworkAclEntry_Call) RunAndReturn(run func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error)) *EC2_ReplaceNetworkAclEntry_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceRoute(ctx context.Context, params *ec2.ReplaceRouteInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceRoute")
	}

	var r0 *ec2.ReplaceRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) *ec2.ReplaceRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReplaceRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceRoute'
type EC2_ReplaceRoute_Call struct {
	*mock.Call
}

// ReplaceRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReplaceRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReplaceRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReplaceRoute_Call {
	return &EC2_ReplaceRoute_Call{Call: _e.mock.On("ReplaceRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReplaceRoute_Call) Run(run func(ctx context.Context, params *ec2.ReplaceRouteInput, optFns ...func(*ec2.Options))) *EC2_ReplaceRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReplaceRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReplaceRoute_Call) Return(_a0 *ec2.ReplaceRouteOutput, _a1 error) *EC2_ReplaceRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReplaceRoute_Call) RunAndReturn(run func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error)) *EC2_ReplaceRoute_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceRouteTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceRouteTableAssociation(ctx context.Context, params *ec2.ReplaceRouteTableAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceRouteTableAssociation")
	}

	var r0 *ec2.ReplaceRouteTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceRouteTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReplaceRouteTableAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceRouteTableAssociation'
type EC2_ReplaceRouteTableAssociation_Call struct {
	*mock.Call
}

// ReplaceRouteTableAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReplaceRouteTableAssociationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReplaceRouteTableAssociation(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReplaceRouteTableAssociation_Call {
	return &EC2_ReplaceRouteTableAssociation_Call{Call: _e.mock.On("ReplaceRouteTableAssociation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReplaceRouteTableAssociation_Call) Run(run func(ctx context.Context, params *ec2.ReplaceRouteTableAssociationInput, optFns ...func(*ec2.Options))) *EC2_ReplaceRouteTableAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReplaceRouteTableAssociationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReplaceRouteTableAssociation_Call) Return(_a0 *ec2.ReplaceRouteTableAssociationOutput, _a1 error) *EC2_ReplaceRouteTableAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReplaceRouteTableAssociation_Call) RunAndReturn(run func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error)) *EC2_ReplaceRouteTableAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceTransitGatewayRoute(ctx context.Context, params *ec2.ReplaceTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceTransitGatewayRoute")
	}

	var r0 *ec2.ReplaceTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.ReplaceTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReplaceTransitGatewayRoute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceTransitGatewayRoute'
type EC2_ReplaceTransitGatewayRoute_Call struct {
	*mock.Call
}

// ReplaceTransitGatewayRoute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReplaceTransitGatewayRouteInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReplaceTransitGatewayRoute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReplaceTransitGatewayRoute_Call {
	return &EC2_ReplaceTransitGatewayRoute_Call{Call: _e.mock.On("ReplaceTransitGatewayRoute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReplaceTransitGatewayRoute_Call) Run(run func(ctx context.Context, params *ec2.ReplaceTransitGatewayRouteInput, optFns ...func(*ec2.Options))) *EC2_ReplaceTransitGatewayRoute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReplaceTransitGatewayRouteInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReplaceTransitGatewayRoute_Call) Return(_a0 *ec2.ReplaceTransitGatewayRouteOutput, _a1 error) *EC2_ReplaceTransitGatewayRoute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReplaceTransitGatewayRoute_Call) RunAndReturn(run func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error)) *EC2_ReplaceTransitGatewayRoute_Call {
	_c.Call.Return(run)
	return _c
}

// ReportInstanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReportInstanceStatus(ctx context.Context, params *ec2.ReportInstanceStatusInput, optFns ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReportInstanceStatus")
	}

	var r0 *ec2.ReportInstanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) *ec2.ReportInstanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReportInstanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ReportInstanceStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportInstanceStatus'
type EC2_ReportInstanceStatus_Call struct {
	*mock.Call
}

// ReportInstanceStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ReportInstanceStatusInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ReportInstanceStatus(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ReportInstanceStatus_Call {
	return &EC2_ReportInstanceStatus_Call{Call: _e.mock.On("ReportInstanceStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ReportInstanceStatus_Call) Run(run func(ctx context.Context, params *ec2.ReportInstanceStatusInput, optFns ...func(*ec2.Options))) *EC2_ReportInstanceStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ReportInstanceStatusInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ReportInstanceStatus_Call) Return(_a0 *ec2.ReportInstanceStatusOutput, _a1 error) *EC2_ReportInstanceStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ReportInstanceStatus_Call) RunAndReturn(run func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error)) *EC2_ReportInstanceStatus_Call {
	_c.Call.Return(run)
	return _c
}

// RequestSpotFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RequestSpotFleet(ctx context.Context, params *ec2.RequestSpotFleetInput, optFns ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestSpotFleet")
	}

	var r0 *ec2.RequestSpotFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) *ec2.RequestSpotFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RequestSpotFleet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestSpotFleet'
type EC2_RequestSpotFleet_Call struct {
	*mock.Call
}

// RequestSpotFleet is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RequestSpotFleetInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RequestSpotFleet(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RequestSpotFleet_Call {
	return &EC2_RequestSpotFleet_Call{Call: _e.mock.On("RequestSpotFleet",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RequestSpotFleet_Call) Run(run func(ctx context.Context, params *ec2.RequestSpotFleetInput, optFns ...func(*ec2.Options))) *EC2_RequestSpotFleet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RequestSpotFleetInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RequestSpotFleet_Call) Return(_a0 *ec2.RequestSpotFleetOutput, _a1 error) *EC2_RequestSpotFleet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RequestSpotFleet_Call) RunAndReturn(run func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error)) *EC2_RequestSpotFleet_Call {
	_c.Call.Return(run)
	return _c
}

// RequestSpotInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RequestSpotInstances(ctx context.Context, params *ec2.RequestSpotInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RequestSpotInstances")
	}

	var r0 *ec2.RequestSpotInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) *ec2.RequestSpotInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RequestSpotInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestSpotInstances'
type EC2_RequestSpotInstances_Call struct {
	*mock.Call
}

// RequestSpotInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RequestSpotInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RequestSpotInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RequestSpotInstances_Call {
	return &EC2_RequestSpotInstances_Call{Call: _e.mock.On("RequestSpotInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RequestSpotInstances_Call) Run(run func(ctx context.Context, params *ec2.RequestSpotInstancesInput, optFns ...func(*ec2.Options))) *EC2_RequestSpotInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RequestSpotInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RequestSpotInstances_Call) Return(_a0 *ec2.RequestSpotInstancesOutput, _a1 error) *EC2_RequestSpotInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RequestSpotInstances_Call) RunAndReturn(run func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error)) *EC2_RequestSpotInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ResetAddressAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetAddressAttribute(ctx context.Context, params *ec2.ResetAddressAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetAddressAttribute")
	}

	var r0 *ec2.ResetAddressAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) *ec2.ResetAddressAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetAddressAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetAddressAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetAddressAttribute'
type EC2_ResetAddressAttribute_Call struct {
	*mock.Call
}

// ResetAddressAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetAddressAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetAddressAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetAddressAttribute_Call {
	return &EC2_ResetAddressAttribute_Call{Call: _e.mock.On("ResetAddressAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetAddressAttribute_Call) Run(run func(ctx context.Context, params *ec2.ResetAddressAttributeInput, optFns ...func(*ec2.Options))) *EC2_ResetAddressAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetAddressAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetAddressAttribute_Call) Return(_a0 *ec2.ResetAddressAttributeOutput, _a1 error) *EC2_ResetAddressAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetAddressAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error)) *EC2_ResetAddressAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ResetEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetEbsDefaultKmsKeyId(ctx context.Context, params *ec2.ResetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetEbsDefaultKmsKeyId")
	}

	var r0 *ec2.ResetEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.ResetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetEbsDefaultKmsKeyId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetEbsDefaultKmsKeyId'
type EC2_ResetEbsDefaultKmsKeyId_Call struct {
	*mock.Call
}

// ResetEbsDefaultKmsKeyId is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetEbsDefaultKmsKeyIdInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetEbsDefaultKmsKeyId(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetEbsDefaultKmsKeyId_Call {
	return &EC2_ResetEbsDefaultKmsKeyId_Call{Call: _e.mock.On("ResetEbsDefaultKmsKeyId",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetEbsDefaultKmsKeyId_Call) Run(run func(ctx context.Context, params *ec2.ResetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options))) *EC2_ResetEbsDefaultKmsKeyId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetEbsDefaultKmsKeyIdInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetEbsDefaultKmsKeyId_Call) Return(_a0 *ec2.ResetEbsDefaultKmsKeyIdOutput, _a1 error) *EC2_ResetEbsDefaultKmsKeyId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetEbsDefaultKmsKeyId_Call) RunAndReturn(run func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error)) *EC2_ResetEbsDefaultKmsKeyId_Call {
	_c.Call.Return(run)
	return _c
}

// ResetFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetFpgaImageAttribute(ctx context.Context, params *ec2.ResetFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetFpgaImageAttribute")
	}

	var r0 *ec2.ResetFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.ResetFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetFpgaImageAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetFpgaImageAttribute'
type EC2_ResetFpgaImageAttribute_Call struct {
	*mock.Call
}

// ResetFpgaImageAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetFpgaImageAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetFpgaImageAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetFpgaImageAttribute_Call {
	return &EC2_ResetFpgaImageAttribute_Call{Call: _e.mock.On("ResetFpgaImageAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetFpgaImageAttribute_Call) Run(run func(ctx context.Context, params *ec2.ResetFpgaImageAttributeInput, optFns ...func(*ec2.Options))) *EC2_ResetFpgaImageAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetFpgaImageAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetFpgaImageAttribute_Call) Return(_a0 *ec2.ResetFpgaImageAttributeOutput, _a1 error) *EC2_ResetFpgaImageAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetFpgaImageAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error)) *EC2_ResetFpgaImageAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ResetImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetImageAttribute(ctx context.Context, params *ec2.ResetImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetImageAttribute")
	}

	var r0 *ec2.ResetImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) *ec2.ResetImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetImageAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetImageAttribute'
type EC2_ResetImageAttribute_Call struct {
	*mock.Call
}

// ResetImageAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetImageAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetImageAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetImageAttribute_Call {
	return &EC2_ResetImageAttribute_Call{Call: _e.mock.On("ResetImageAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetImageAttribute_Call) Run(run func(ctx context.Context, params *ec2.ResetImageAttributeInput, optFns ...func(*ec2.Options))) *EC2_ResetImageAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetImageAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetImageAttribute_Call) Return(_a0 *ec2.ResetImageAttributeOutput, _a1 error) *EC2_ResetImageAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetImageAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error)) *EC2_ResetImageAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ResetInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetInstanceAttribute(ctx context.Context, params *ec2.ResetInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetInstanceAttribute")
	}

	var r0 *ec2.ResetInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) *ec2.ResetInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetInstanceAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetInstanceAttribute'
type EC2_ResetInstanceAttribute_Call struct {
	*mock.Call
}

// ResetInstanceAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetInstanceAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetInstanceAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetInstanceAttribute_Call {
	return &EC2_ResetInstanceAttribute_Call{Call: _e.mock.On("ResetInstanceAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetInstanceAttribute_Call) Run(run func(ctx context.Context, params *ec2.ResetInstanceAttributeInput, optFns ...func(*ec2.Options))) *EC2_ResetInstanceAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetInstanceAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetInstanceAttribute_Call) Return(_a0 *ec2.ResetInstanceAttributeOutput, _a1 error) *EC2_ResetInstanceAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetInstanceAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error)) *EC2_ResetInstanceAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ResetNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetNetworkInterfaceAttribute(ctx context.Context, params *ec2.ResetNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetNetworkInterfaceAttribute")
	}

	var r0 *ec2.ResetNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.ResetNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetNetworkInterfaceAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetNetworkInterfaceAttribute'
type EC2_ResetNetworkInterfaceAttribute_Call struct {
	*mock.Call
}

// ResetNetworkInterfaceAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetNetworkInterfaceAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetNetworkInterfaceAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetNetworkInterfaceAttribute_Call {
	return &EC2_ResetNetworkInterfaceAttribute_Call{Call: _e.mock.On("ResetNetworkInterfaceAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetNetworkInterfaceAttribute_Call) Run(run func(ctx context.Context, params *ec2.ResetNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options))) *EC2_ResetNetworkInterfaceAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetNetworkInterfaceAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetNetworkInterfaceAttribute_Call) Return(_a0 *ec2.ResetNetworkInterfaceAttributeOutput, _a1 error) *EC2_ResetNetworkInterfaceAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetNetworkInterfaceAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error)) *EC2_ResetNetworkInterfaceAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// ResetSnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetSnapshotAttribute(ctx context.Context, params *ec2.ResetSnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetSnapshotAttribute")
	}

	var r0 *ec2.ResetSnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) *ec2.ResetSnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetSnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_ResetSnapshotAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetSnapshotAttribute'
type EC2_ResetSnapshotAttribute_Call struct {
	*mock.Call
}

// ResetSnapshotAttribute is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.ResetSnapshotAttributeInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) ResetSnapshotAttribute(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_ResetSnapshotAttribute_Call {
	return &EC2_ResetSnapshotAttribute_Call{Call: _e.mock.On("ResetSnapshotAttribute",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_ResetSnapshotAttribute_Call) Run(run func(ctx context.Context, params *ec2.ResetSnapshotAttributeInput, optFns ...func(*ec2.Options))) *EC2_ResetSnapshotAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.ResetSnapshotAttributeInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_ResetSnapshotAttribute_Call) Return(_a0 *ec2.ResetSnapshotAttributeOutput, _a1 error) *EC2_ResetSnapshotAttribute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_ResetSnapshotAttribute_Call) RunAndReturn(run func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error)) *EC2_ResetSnapshotAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreAddressToClassic provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreAddressToClassic(ctx context.Context, params *ec2.RestoreAddressToClassicInput, optFns ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreAddressToClassic")
	}

	var r0 *ec2.RestoreAddressToClassicOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) *ec2.RestoreAddressToClassicOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreAddressToClassicOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RestoreAddressToClassic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreAddressToClassic'
type EC2_RestoreAddressToClassic_Call struct {
	*mock.Call
}

// RestoreAddressToClassic is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RestoreAddressToClassicInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RestoreAddressToClassic(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RestoreAddressToClassic_Call {
	return &EC2_RestoreAddressToClassic_Call{Call: _e.mock.On("RestoreAddressToClassic",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RestoreAddressToClassic_Call) Run(run func(ctx context.Context, params *ec2.RestoreAddressToClassicInput, optFns ...func(*ec2.Options))) *EC2_RestoreAddressToClassic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RestoreAddressToClassicInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RestoreAddressToClassic_Call) Return(_a0 *ec2.RestoreAddressToClassicOutput, _a1 error) *EC2_RestoreAddressToClassic_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RestoreAddressToClassic_Call) RunAndReturn(run func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error)) *EC2_RestoreAddressToClassic_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreImageFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreImageFromRecycleBin(ctx context.Context, params *ec2.RestoreImageFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreImageFromRecycleBin")
	}

	var r0 *ec2.RestoreImageFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreImageFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreImageFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RestoreImageFromRecycleBin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreImageFromRecycleBin'
type EC2_RestoreImageFromRecycleBin_Call struct {
	*mock.Call
}

// RestoreImageFromRecycleBin is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RestoreImageFromRecycleBinInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RestoreImageFromRecycleBin(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RestoreImageFromRecycleBin_Call {
	return &EC2_RestoreImageFromRecycleBin_Call{Call: _e.mock.On("RestoreImageFromRecycleBin",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RestoreImageFromRecycleBin_Call) Run(run func(ctx context.Context, params *ec2.RestoreImageFromRecycleBinInput, optFns ...func(*ec2.Options))) *EC2_RestoreImageFromRecycleBin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RestoreImageFromRecycleBinInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RestoreImageFromRecycleBin_Call) Return(_a0 *ec2.RestoreImageFromRecycleBinOutput, _a1 error) *EC2_RestoreImageFromRecycleBin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RestoreImageFromRecycleBin_Call) RunAndReturn(run func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error)) *EC2_RestoreImageFromRecycleBin_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreManagedPrefixListVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreManagedPrefixListVersion(ctx context.Context, params *ec2.RestoreManagedPrefixListVersionInput, optFns ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreManagedPrefixListVersion")
	}

	var r0 *ec2.RestoreManagedPrefixListVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) *ec2.RestoreManagedPrefixListVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreManagedPrefixListVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RestoreManagedPrefixListVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreManagedPrefixListVersion'
type EC2_RestoreManagedPrefixListVersion_Call struct {
	*mock.Call
}

// RestoreManagedPrefixListVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RestoreManagedPrefixListVersionInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RestoreManagedPrefixListVersion(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RestoreManagedPrefixListVersion_Call {
	return &EC2_RestoreManagedPrefixListVersion_Call{Call: _e.mock.On("RestoreManagedPrefixListVersion",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RestoreManagedPrefixListVersion_Call) Run(run func(ctx context.Context, params *ec2.RestoreManagedPrefixListVersionInput, optFns ...func(*ec2.Options))) *EC2_RestoreManagedPrefixListVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RestoreManagedPrefixListVersionInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RestoreManagedPrefixListVersion_Call) Return(_a0 *ec2.RestoreManagedPrefixListVersionOutput, _a1 error) *EC2_RestoreManagedPrefixListVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RestoreManagedPrefixListVersion_Call) RunAndReturn(run func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error)) *EC2_RestoreManagedPrefixListVersion_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreSnapshotFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreSnapshotFromRecycleBin(ctx context.Context, params *ec2.RestoreSnapshotFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreSnapshotFromRecycleBin")
	}

	var r0 *ec2.RestoreSnapshotFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreSnapshotFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreSnapshotFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RestoreSnapshotFromRecycleBin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreSnapshotFromRecycleBin'
type EC2_RestoreSnapshotFromRecycleBin_Call struct {
	*mock.Call
}

// RestoreSnapshotFromRecycleBin is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RestoreSnapshotFromRecycleBinInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RestoreSnapshotFromRecycleBin(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RestoreSnapshotFromRecycleBin_Call {
	return &EC2_RestoreSnapshotFromRecycleBin_Call{Call: _e.mock.On("RestoreSnapshotFromRecycleBin",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RestoreSnapshotFromRecycleBin_Call) Run(run func(ctx context.Context, params *ec2.RestoreSnapshotFromRecycleBinInput, optFns ...func(*ec2.Options))) *EC2_RestoreSnapshotFromRecycleBin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RestoreSnapshotFromRecycleBinInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RestoreSnapshotFromRecycleBin_Call) Return(_a0 *ec2.RestoreSnapshotFromRecycleBinOutput, _a1 error) *EC2_RestoreSnapshotFromRecycleBin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RestoreSnapshotFromRecycleBin_Call) RunAndReturn(run func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error)) *EC2_RestoreSnapshotFromRecycleBin_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreSnapshotTier provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreSnapshotTier(ctx context.Context, params *ec2.RestoreSnapshotTierInput, optFns ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreSnapshotTier")
	}

	var r0 *ec2.RestoreSnapshotTierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) *ec2.RestoreSnapshotTierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreSnapshotTierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RestoreSnapshotTier_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreSnapshotTier'
type EC2_RestoreSnapshotTier_Call struct {
	*mock.Call
}

// RestoreSnapshotTier is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RestoreSnapshotTierInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RestoreSnapshotTier(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RestoreSnapshotTier_Call {
	return &EC2_RestoreSnapshotTier_Call{Call: _e.mock.On("RestoreSnapshotTier",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RestoreSnapshotTier_Call) Run(run func(ctx context.Context, params *ec2.RestoreSnapshotTierInput, optFns ...func(*ec2.Options))) *EC2_RestoreSnapshotTier_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RestoreSnapshotTierInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RestoreSnapshotTier_Call) Return(_a0 *ec2.RestoreSnapshotTierOutput, _a1 error) *EC2_RestoreSnapshotTier_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RestoreSnapshotTier_Call) RunAndReturn(run func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error)) *EC2_RestoreSnapshotTier_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeClientVpnIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RevokeClientVpnIngress(ctx context.Context, params *ec2.RevokeClientVpnIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeClientVpnIngress")
	}

	var r0 *ec2.RevokeClientVpnIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) *ec2.RevokeClientVpnIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeClientVpnIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RevokeClientVpnIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeClientVpnIngress'
type EC2_RevokeClientVpnIngress_Call struct {
	*mock.Call
}

// RevokeClientVpnIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RevokeClientVpnIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RevokeClientVpnIngress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RevokeClientVpnIngress_Call {
	return &EC2_RevokeClientVpnIngress_Call{Call: _e.mock.On("RevokeClientVpnIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RevokeClientVpnIngress_Call) Run(run func(ctx context.Context, params *ec2.RevokeClientVpnIngressInput, optFns ...func(*ec2.Options))) *EC2_RevokeClientVpnIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RevokeClientVpnIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RevokeClientVpnIngress_Call) Return(_a0 *ec2.RevokeClientVpnIngressOutput, _a1 error) *EC2_RevokeClientVpnIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RevokeClientVpnIngress_Call) RunAndReturn(run func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error)) *EC2_RevokeClientVpnIngress_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeSecurityGroupEgress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RevokeSecurityGroupEgress(ctx context.Context, params *ec2.RevokeSecurityGroupEgressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeSecurityGroupEgress")
	}

	var r0 *ec2.RevokeSecurityGroupEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RevokeSecurityGroupEgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeSecurityGroupEgress'
type EC2_RevokeSecurityGroupEgress_Call struct {
	*mock.Call
}

// RevokeSecurityGroupEgress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RevokeSecurityGroupEgressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RevokeSecurityGroupEgress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RevokeSecurityGroupEgress_Call {
	return &EC2_RevokeSecurityGroupEgress_Call{Call: _e.mock.On("RevokeSecurityGroupEgress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RevokeSecurityGroupEgress_Call) Run(run func(ctx context.Context, params *ec2.RevokeSecurityGroupEgressInput, optFns ...func(*ec2.Options))) *EC2_RevokeSecurityGroupEgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RevokeSecurityGroupEgressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RevokeSecurityGroupEgress_Call) Return(_a0 *ec2.RevokeSecurityGroupEgressOutput, _a1 error) *EC2_RevokeSecurityGroupEgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RevokeSecurityGroupEgress_Call) RunAndReturn(run func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error)) *EC2_RevokeSecurityGroupEgress_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RevokeSecurityGroupIngress(ctx context.Context, params *ec2.RevokeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeSecurityGroupIngress")
	}

	var r0 *ec2.RevokeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RevokeSecurityGroupIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeSecurityGroupIngress'
type EC2_RevokeSecurityGroupIngress_Call struct {
	*mock.Call
}

// RevokeSecurityGroupIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RevokeSecurityGroupIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RevokeSecurityGroupIngress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RevokeSecurityGroupIngress_Call {
	return &EC2_RevokeSecurityGroupIngress_Call{Call: _e.mock.On("RevokeSecurityGroupIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RevokeSecurityGroupIngress_Call) Run(run func(ctx context.Context, params *ec2.RevokeSecurityGroupIngressInput, optFns ...func(*ec2.Options))) *EC2_RevokeSecurityGroupIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RevokeSecurityGroupIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RevokeSecurityGroupIngress_Call) Return(_a0 *ec2.RevokeSecurityGroupIngressOutput, _a1 error) *EC2_RevokeSecurityGroupIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RevokeSecurityGroupIngress_Call) RunAndReturn(run func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error)) *EC2_RevokeSecurityGroupIngress_Call {
	_c.Call.Return(run)
	return _c
}

// RunInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RunInstances(ctx context.Context, params *ec2.RunInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunInstances")
	}

	var r0 *ec2.RunInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) *ec2.RunInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RunInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunInstances'
type EC2_RunInstances_Call struct {
	*mock.Call
}

// RunInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RunInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RunInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RunInstances_Call {
	return &EC2_RunInstances_Call{Call: _e.mock.On("RunInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RunInstances_Call) Run(run func(ctx context.Context, params *ec2.RunInstancesInput, optFns ...func(*ec2.Options))) *EC2_RunInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RunInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RunInstances_Call) Return(_a0 *ec2.RunInstancesOutput, _a1 error) *EC2_RunInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RunInstances_Call) RunAndReturn(run func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error)) *EC2_RunInstances_Call {
	_c.Call.Return(run)
	return _c
}

// RunScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RunScheduledInstances(ctx context.Context, params *ec2.RunScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunScheduledInstances")
	}

	var r0 *ec2.RunScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) *ec2.RunScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_RunScheduledInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunScheduledInstances'
type EC2_RunScheduledInstances_Call struct {
	*mock.Call
}

// RunScheduledInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RunScheduledInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) RunScheduledInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_RunScheduledInstances_Call {
	return &EC2_RunScheduledInstances_Call{Call: _e.mock.On("RunScheduledInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_RunScheduledInstances_Call) Run(run func(ctx context.Context, params *ec2.RunScheduledInstancesInput, optFns ...func(*ec2.Options))) *EC2_RunScheduledInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RunScheduledInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_RunScheduledInstances_Call) Return(_a0 *ec2.RunScheduledInstancesOutput, _a1 error) *EC2_RunScheduledInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_RunScheduledInstances_Call) RunAndReturn(run func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error)) *EC2_RunScheduledInstances_Call {
	_c.Call.Return(run)
	return _c
}

// SearchLocalGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SearchLocalGatewayRoutes(ctx context.Context, params *ec2.SearchLocalGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchLocalGatewayRoutes")
	}

	var r0 *ec2.SearchLocalGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) *ec2.SearchLocalGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchLocalGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_SearchLocalGatewayRoutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchLocalGatewayRoutes'
type EC2_SearchLocalGatewayRoutes_Call struct {
	*mock.Call
}

// SearchLocalGatewayRoutes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.SearchLocalGatewayRoutesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) SearchLocalGatewayRoutes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_SearchLocalGatewayRoutes_Call {
	return &EC2_SearchLocalGatewayRoutes_Call{Call: _e.mock.On("SearchLocalGatewayRoutes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_SearchLocalGatewayRoutes_Call) Run(run func(ctx context.Context, params *ec2.SearchLocalGatewayRoutesInput, optFns ...func(*ec2.Options))) *EC2_SearchLocalGatewayRoutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.SearchLocalGatewayRoutesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_SearchLocalGatewayRoutes_Call) Return(_a0 *ec2.SearchLocalGatewayRoutesOutput, _a1 error) *EC2_SearchLocalGatewayRoutes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_SearchLocalGatewayRoutes_Call) RunAndReturn(run func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error)) *EC2_SearchLocalGatewayRoutes_Call {
	_c.Call.Return(run)
	return _c
}

// SearchTransitGatewayMulticastGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SearchTransitGatewayMulticastGroups(ctx context.Context, params *ec2.SearchTransitGatewayMulticastGroupsInput, optFns ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchTransitGatewayMulticastGroups")
	}

	var r0 *ec2.SearchTransitGatewayMulticastGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) *ec2.SearchTransitGatewayMulticastGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayMulticastGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_SearchTransitGatewayMulticastGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchTransitGatewayMulticastGroups'
type EC2_SearchTransitGatewayMulticastGroups_Call struct {
	*mock.Call
}

// SearchTransitGatewayMulticastGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.SearchTransitGatewayMulticastGroupsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) SearchTransitGatewayMulticastGroups(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_SearchTransitGatewayMulticastGroups_Call {
	return &EC2_SearchTransitGatewayMulticastGroups_Call{Call: _e.mock.On("SearchTransitGatewayMulticastGroups",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_SearchTransitGatewayMulticastGroups_Call) Run(run func(ctx context.Context, params *ec2.SearchTransitGatewayMulticastGroupsInput, optFns ...func(*ec2.Options))) *EC2_SearchTransitGatewayMulticastGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.SearchTransitGatewayMulticastGroupsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_SearchTransitGatewayMulticastGroups_Call) Return(_a0 *ec2.SearchTransitGatewayMulticastGroupsOutput, _a1 error) *EC2_SearchTransitGatewayMulticastGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_SearchTransitGatewayMulticastGroups_Call) RunAndReturn(run func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error)) *EC2_SearchTransitGatewayMulticastGroups_Call {
	_c.Call.Return(run)
	return _c
}

// SearchTransitGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SearchTransitGatewayRoutes(ctx context.Context, params *ec2.SearchTransitGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchTransitGatewayRoutes")
	}

	var r0 *ec2.SearchTransitGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) *ec2.SearchTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_SearchTransitGatewayRoutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchTransitGatewayRoutes'
type EC2_SearchTransitGatewayRoutes_Call struct {
	*mock.Call
}

// SearchTransitGatewayRoutes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.SearchTransitGatewayRoutesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) SearchTransitGatewayRoutes(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_SearchTransitGatewayRoutes_Call {
	return &EC2_SearchTransitGatewayRoutes_Call{Call: _e.mock.On("SearchTransitGatewayRoutes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_SearchTransitGatewayRoutes_Call) Run(run func(ctx context.Context, params *ec2.SearchTransitGatewayRoutesInput, optFns ...func(*ec2.Options))) *EC2_SearchTransitGatewayRoutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.SearchTransitGatewayRoutesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_SearchTransitGatewayRoutes_Call) Return(_a0 *ec2.SearchTransitGatewayRoutesOutput, _a1 error) *EC2_SearchTransitGatewayRoutes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_SearchTransitGatewayRoutes_Call) RunAndReturn(run func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error)) *EC2_SearchTransitGatewayRoutes_Call {
	_c.Call.Return(run)
	return _c
}

// SendDiagnosticInterrupt provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SendDiagnosticInterrupt(ctx context.Context, params *ec2.SendDiagnosticInterruptInput, optFns ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendDiagnosticInterrupt")
	}

	var r0 *ec2.SendDiagnosticInterruptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) *ec2.SendDiagnosticInterruptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SendDiagnosticInterruptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_SendDiagnosticInterrupt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendDiagnosticInterrupt'
type EC2_SendDiagnosticInterrupt_Call struct {
	*mock.Call
}

// SendDiagnosticInterrupt is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.SendDiagnosticInterruptInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) SendDiagnosticInterrupt(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_SendDiagnosticInterrupt_Call {
	return &EC2_SendDiagnosticInterrupt_Call{Call: _e.mock.On("SendDiagnosticInterrupt",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_SendDiagnosticInterrupt_Call) Run(run func(ctx context.Context, params *ec2.SendDiagnosticInterruptInput, optFns ...func(*ec2.Options))) *EC2_SendDiagnosticInterrupt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.SendDiagnosticInterruptInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_SendDiagnosticInterrupt_Call) Return(_a0 *ec2.SendDiagnosticInterruptOutput, _a1 error) *EC2_SendDiagnosticInterrupt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_SendDiagnosticInterrupt_Call) RunAndReturn(run func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error)) *EC2_SendDiagnosticInterrupt_Call {
	_c.Call.Return(run)
	return _c
}

// StartInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartInstances(ctx context.Context, params *ec2.StartInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartInstances")
	}

	var r0 *ec2.StartInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) *ec2.StartInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_StartInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartInstances'
type EC2_StartInstances_Call struct {
	*mock.Call
}

// StartInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.StartInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) StartInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_StartInstances_Call {
	return &EC2_StartInstances_Call{Call: _e.mock.On("StartInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_StartInstances_Call) Run(run func(ctx context.Context, params *ec2.StartInstancesInput, optFns ...func(*ec2.Options))) *EC2_StartInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.StartInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_StartInstances_Call) Return(_a0 *ec2.StartInstancesOutput, _a1 error) *EC2_StartInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_StartInstances_Call) RunAndReturn(run func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error)) *EC2_StartInstances_Call {
	_c.Call.Return(run)
	return _c
}

// StartNetworkInsightsAccessScopeAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartNetworkInsightsAccessScopeAnalysis(ctx context.Context, params *ec2.StartNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartNetworkInsightsAccessScopeAnalysis")
	}

	var r0 *ec2.StartNetworkInsightsAccessScopeAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) *ec2.StartNetworkInsightsAccessScopeAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartNetworkInsightsAccessScopeAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_StartNetworkInsightsAccessScopeAnalysis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartNetworkInsightsAccessScopeAnalysis'
type EC2_StartNetworkInsightsAccessScopeAnalysis_Call struct {
	*mock.Call
}

// StartNetworkInsightsAccessScopeAnalysis is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.StartNetworkInsightsAccessScopeAnalysisInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) StartNetworkInsightsAccessScopeAnalysis(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_StartNetworkInsightsAccessScopeAnalysis_Call {
	return &EC2_StartNetworkInsightsAccessScopeAnalysis_Call{Call: _e.mock.On("StartNetworkInsightsAccessScopeAnalysis",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_StartNetworkInsightsAccessScopeAnalysis_Call) Run(run func(ctx context.Context, params *ec2.StartNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options))) *EC2_StartNetworkInsightsAccessScopeAnalysis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.StartNetworkInsightsAccessScopeAnalysisInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_StartNetworkInsightsAccessScopeAnalysis_Call) Return(_a0 *ec2.StartNetworkInsightsAccessScopeAnalysisOutput, _a1 error) *EC2_StartNetworkInsightsAccessScopeAnalysis_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_StartNetworkInsightsAccessScopeAnalysis_Call) RunAndReturn(run func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error)) *EC2_StartNetworkInsightsAccessScopeAnalysis_Call {
	_c.Call.Return(run)
	return _c
}

// StartNetworkInsightsAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartNetworkInsightsAnalysis(ctx context.Context, params *ec2.StartNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartNetworkInsightsAnalysis")
	}

	var r0 *ec2.StartNetworkInsightsAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) *ec2.StartNetworkInsightsAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartNetworkInsightsAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_StartNetworkInsightsAnalysis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartNetworkInsightsAnalysis'
type EC2_StartNetworkInsightsAnalysis_Call struct {
	*mock.Call
}

// StartNetworkInsightsAnalysis is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.StartNetworkInsightsAnalysisInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) StartNetworkInsightsAnalysis(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_StartNetworkInsightsAnalysis_Call {
	return &EC2_StartNetworkInsightsAnalysis_Call{Call: _e.mock.On("StartNetworkInsightsAnalysis",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_StartNetworkInsightsAnalysis_Call) Run(run func(ctx context.Context, params *ec2.StartNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options))) *EC2_StartNetworkInsightsAnalysis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.StartNetworkInsightsAnalysisInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_StartNetworkInsightsAnalysis_Call) Return(_a0 *ec2.StartNetworkInsightsAnalysisOutput, _a1 error) *EC2_StartNetworkInsightsAnalysis_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_StartNetworkInsightsAnalysis_Call) RunAndReturn(run func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error)) *EC2_StartNetworkInsightsAnalysis_Call {
	_c.Call.Return(run)
	return _c
}

// StartVpcEndpointServicePrivateDnsVerification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartVpcEndpointServicePrivateDnsVerification(ctx context.Context, params *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, optFns ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartVpcEndpointServicePrivateDnsVerification")
	}

	var r0 *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_StartVpcEndpointServicePrivateDnsVerification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartVpcEndpointServicePrivateDnsVerification'
type EC2_StartVpcEndpointServicePrivateDnsVerification_Call struct {
	*mock.Call
}

// StartVpcEndpointServicePrivateDnsVerification is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.StartVpcEndpointServicePrivateDnsVerificationInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) StartVpcEndpointServicePrivateDnsVerification(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_StartVpcEndpointServicePrivateDnsVerification_Call {
	return &EC2_StartVpcEndpointServicePrivateDnsVerification_Call{Call: _e.mock.On("StartVpcEndpointServicePrivateDnsVerification",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_StartVpcEndpointServicePrivateDnsVerification_Call) Run(run func(ctx context.Context, params *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, optFns ...func(*ec2.Options))) *EC2_StartVpcEndpointServicePrivateDnsVerification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.StartVpcEndpointServicePrivateDnsVerificationInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_StartVpcEndpointServicePrivateDnsVerification_Call) Return(_a0 *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, _a1 error) *EC2_StartVpcEndpointServicePrivateDnsVerification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_StartVpcEndpointServicePrivateDnsVerification_Call) RunAndReturn(run func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error)) *EC2_StartVpcEndpointServicePrivateDnsVerification_Call {
	_c.Call.Return(run)
	return _c
}

// StopInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StopInstances(ctx context.Context, params *ec2.StopInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopInstances")
	}

	var r0 *ec2.StopInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) *ec2.StopInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StopInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_StopInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopInstances'
type EC2_StopInstances_Call struct {
	*mock.Call
}

// StopInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.StopInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) StopInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_StopInstances_Call {
	return &EC2_StopInstances_Call{Call: _e.mock.On("StopInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_StopInstances_Call) Run(run func(ctx context.Context, params *ec2.StopInstancesInput, optFns ...func(*ec2.Options))) *EC2_StopInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.StopInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_StopInstances_Call) Return(_a0 *ec2.StopInstancesOutput, _a1 error) *EC2_StopInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_StopInstances_Call) RunAndReturn(run func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error)) *EC2_StopInstances_Call {
	_c.Call.Return(run)
	return _c
}

// TerminateClientVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) TerminateClientVpnConnections(ctx context.Context, params *ec2.TerminateClientVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateClientVpnConnections")
	}

	var r0 *ec2.TerminateClientVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) *ec2.TerminateClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateClientVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_TerminateClientVpnConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminateClientVpnConnections'
type EC2_TerminateClientVpnConnections_Call struct {
	*mock.Call
}

// TerminateClientVpnConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.TerminateClientVpnConnectionsInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) TerminateClientVpnConnections(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_TerminateClientVpnConnections_Call {
	return &EC2_TerminateClientVpnConnections_Call{Call: _e.mock.On("TerminateClientVpnConnections",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_TerminateClientVpnConnections_Call) Run(run func(ctx context.Context, params *ec2.TerminateClientVpnConnectionsInput, optFns ...func(*ec2.Options))) *EC2_TerminateClientVpnConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.TerminateClientVpnConnectionsInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_TerminateClientVpnConnections_Call) Return(_a0 *ec2.TerminateClientVpnConnectionsOutput, _a1 error) *EC2_TerminateClientVpnConnections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_TerminateClientVpnConnections_Call) RunAndReturn(run func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error)) *EC2_TerminateClientVpnConnections_Call {
	_c.Call.Return(run)
	return _c
}

// TerminateInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) TerminateInstances(ctx context.Context, params *ec2.TerminateInstancesInput, optFns ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TerminateInstances")
	}

	var r0 *ec2.TerminateInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) *ec2.TerminateInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_TerminateInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminateInstances'
type EC2_TerminateInstances_Call struct {
	*mock.Call
}

// TerminateInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.TerminateInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) TerminateInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_TerminateInstances_Call {
	return &EC2_TerminateInstances_Call{Call: _e.mock.On("TerminateInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_TerminateInstances_Call) Run(run func(ctx context.Context, params *ec2.TerminateInstancesInput, optFns ...func(*ec2.Options))) *EC2_TerminateInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.TerminateInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_TerminateInstances_Call) Return(_a0 *ec2.TerminateInstancesOutput, _a1 error) *EC2_TerminateInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_TerminateInstances_Call) RunAndReturn(run func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error)) *EC2_TerminateInstances_Call {
	_c.Call.Return(run)
	return _c
}

// UnassignIpv6Addresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UnassignIpv6Addresses(ctx context.Context, params *ec2.UnassignIpv6AddressesInput, optFns ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnassignIpv6Addresses")
	}

	var r0 *ec2.UnassignIpv6AddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) *ec2.UnassignIpv6AddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignIpv6AddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_UnassignIpv6Addresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnassignIpv6Addresses'
type EC2_UnassignIpv6Addresses_Call struct {
	*mock.Call
}

// UnassignIpv6Addresses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.UnassignIpv6AddressesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) UnassignIpv6Addresses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_UnassignIpv6Addresses_Call {
	return &EC2_UnassignIpv6Addresses_Call{Call: _e.mock.On("UnassignIpv6Addresses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_UnassignIpv6Addresses_Call) Run(run func(ctx context.Context, params *ec2.UnassignIpv6AddressesInput, optFns ...func(*ec2.Options))) *EC2_UnassignIpv6Addresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.UnassignIpv6AddressesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_UnassignIpv6Addresses_Call) Return(_a0 *ec2.UnassignIpv6AddressesOutput, _a1 error) *EC2_UnassignIpv6Addresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_UnassignIpv6Addresses_Call) RunAndReturn(run func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error)) *EC2_UnassignIpv6Addresses_Call {
	_c.Call.Return(run)
	return _c
}

// UnassignPrivateIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UnassignPrivateIpAddresses(ctx context.Context, params *ec2.UnassignPrivateIpAddressesInput, optFns ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnassignPrivateIpAddresses")
	}

	var r0 *ec2.UnassignPrivateIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) *ec2.UnassignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignPrivateIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_UnassignPrivateIpAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnassignPrivateIpAddresses'
type EC2_UnassignPrivateIpAddresses_Call struct {
	*mock.Call
}

// UnassignPrivateIpAddresses is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.UnassignPrivateIpAddressesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) UnassignPrivateIpAddresses(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_UnassignPrivateIpAddresses_Call {
	return &EC2_UnassignPrivateIpAddresses_Call{Call: _e.mock.On("UnassignPrivateIpAddresses",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_UnassignPrivateIpAddresses_Call) Run(run func(ctx context.Context, params *ec2.UnassignPrivateIpAddressesInput, optFns ...func(*ec2.Options))) *EC2_UnassignPrivateIpAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.UnassignPrivateIpAddressesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_UnassignPrivateIpAddresses_Call) Return(_a0 *ec2.UnassignPrivateIpAddressesOutput, _a1 error) *EC2_UnassignPrivateIpAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_UnassignPrivateIpAddresses_Call) RunAndReturn(run func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error)) *EC2_UnassignPrivateIpAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// UnmonitorInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UnmonitorInstances(ctx context.Context, params *ec2.UnmonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnmonitorInstances")
	}

	var r0 *ec2.UnmonitorInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) *ec2.UnmonitorInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnmonitorInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_UnmonitorInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnmonitorInstances'
type EC2_UnmonitorInstances_Call struct {
	*mock.Call
}

// UnmonitorInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.UnmonitorInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) UnmonitorInstances(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_UnmonitorInstances_Call {
	return &EC2_UnmonitorInstances_Call{Call: _e.mock.On("UnmonitorInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_UnmonitorInstances_Call) Run(run func(ctx context.Context, params *ec2.UnmonitorInstancesInput, optFns ...func(*ec2.Options))) *EC2_UnmonitorInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.UnmonitorInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_UnmonitorInstances_Call) Return(_a0 *ec2.UnmonitorInstancesOutput, _a1 error) *EC2_UnmonitorInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_UnmonitorInstances_Call) RunAndReturn(run func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error)) *EC2_UnmonitorInstances_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSecurityGroupRuleDescriptionsEgress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UpdateSecurityGroupRuleDescriptionsEgress(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, optFns ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecurityGroupRuleDescriptionsEgress")
	}

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSecurityGroupRuleDescriptionsEgress'
type EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call struct {
	*mock.Call
}

// UpdateSecurityGroupRuleDescriptionsEgress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) UpdateSecurityGroupRuleDescriptionsEgress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call {
	return &EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call{Call: _e.mock.On("UpdateSecurityGroupRuleDescriptionsEgress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call) Run(run func(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, optFns ...func(*ec2.Options))) *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.UpdateSecurityGroupRuleDescriptionsEgressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call) Return(_a0 *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, _a1 error) *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call) RunAndReturn(run func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error)) *EC2_UpdateSecurityGroupRuleDescriptionsEgress_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSecurityGroupRuleDescriptionsIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UpdateSecurityGroupRuleDescriptionsIngress(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, optFns ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecurityGroupRuleDescriptionsIngress")
	}

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSecurityGroupRuleDescriptionsIngress'
type EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call struct {
	*mock.Call
}

// UpdateSecurityGroupRuleDescriptionsIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) UpdateSecurityGroupRuleDescriptionsIngress(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call {
	return &EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call{Call: _e.mock.On("UpdateSecurityGroupRuleDescriptionsIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call) Run(run func(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, optFns ...func(*ec2.Options))) *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.UpdateSecurityGroupRuleDescriptionsIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call) Return(_a0 *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, _a1 error) *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call) RunAndReturn(run func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error)) *EC2_UpdateSecurityGroupRuleDescriptionsIngress_Call {
	_c.Call.Return(run)
	return _c
}

// WithdrawByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) WithdrawByoipCidr(ctx context.Context, params *ec2.WithdrawByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawByoipCidr")
	}

	var r0 *ec2.WithdrawByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) *ec2.WithdrawByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.WithdrawByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EC2_WithdrawByoipCidr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithdrawByoipCidr'
type EC2_WithdrawByoipCidr_Call struct {
	*mock.Call
}

// WithdrawByoipCidr is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.WithdrawByoipCidrInput
//   - optFns ...func(*ec2.Options)
func (_e *EC2_Expecter) WithdrawByoipCidr(ctx interface{}, params interface{}, optFns ...interface{}) *EC2_WithdrawByoipCidr_Call {
	return &EC2_WithdrawByoipCidr_Call{Call: _e.mock.On("WithdrawByoipCidr",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *EC2_WithdrawByoipCidr_Call) Run(run func(ctx context.Context, params *ec2.WithdrawByoipCidrInput, optFns ...func(*ec2.Options))) *EC2_WithdrawByoipCidr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.WithdrawByoipCidrInput), variadicArgs...)
	})
	return _c
}

func (_c *EC2_WithdrawByoipCidr_Call) Return(_a0 *ec2.WithdrawByoipCidrOutput, _a1 error) *EC2_WithdrawByoipCidr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EC2_WithdrawByoipCidr_Call) RunAndReturn(run func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error)) *EC2_WithdrawByoipCidr_Call {
	_c.Call.Return(run)
	return _c
}

// NewEC2 creates a new instance of EC2. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEC2(t interface {
	mock.TestingT
	Cleanup(func())
}) *EC2 {
	mock := &EC2{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
