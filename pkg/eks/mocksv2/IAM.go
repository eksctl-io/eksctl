// Code generated by mockery v2.35.3. DO NOT EDIT.

package mocksv2

import (
	context "context"

	iam "github.com/aws/aws-sdk-go-v2/service/iam"
	mock "github.com/stretchr/testify/mock"
)

// IAM is an autogenerated mock type for the IAM type
type IAM struct {
	mock.Mock
}

// AddClientIDToOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) AddClientIDToOpenIDConnectProvider(ctx context.Context, params *iam.AddClientIDToOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.AddClientIDToOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.AddClientIDToOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AddClientIDToOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.AddClientIDToOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AddClientIDToOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.AddClientIDToOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.AddClientIDToOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.AddClientIDToOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddRoleToInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) AddRoleToInstanceProfile(ctx context.Context, params *iam.AddRoleToInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.AddRoleToInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.AddRoleToInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AddRoleToInstanceProfileInput, ...func(*iam.Options)) (*iam.AddRoleToInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AddRoleToInstanceProfileInput, ...func(*iam.Options)) *iam.AddRoleToInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.AddRoleToInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.AddRoleToInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddUserToGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) AddUserToGroup(ctx context.Context, params *iam.AddUserToGroupInput, optFns ...func(*iam.Options)) (*iam.AddUserToGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.AddUserToGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AddUserToGroupInput, ...func(*iam.Options)) (*iam.AddUserToGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AddUserToGroupInput, ...func(*iam.Options)) *iam.AddUserToGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.AddUserToGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.AddUserToGroupInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) AttachGroupPolicy(ctx context.Context, params *iam.AttachGroupPolicyInput, optFns ...func(*iam.Options)) (*iam.AttachGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.AttachGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AttachGroupPolicyInput, ...func(*iam.Options)) (*iam.AttachGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AttachGroupPolicyInput, ...func(*iam.Options)) *iam.AttachGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.AttachGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.AttachGroupPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachRolePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) AttachRolePolicy(ctx context.Context, params *iam.AttachRolePolicyInput, optFns ...func(*iam.Options)) (*iam.AttachRolePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.AttachRolePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AttachRolePolicyInput, ...func(*iam.Options)) (*iam.AttachRolePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AttachRolePolicyInput, ...func(*iam.Options)) *iam.AttachRolePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.AttachRolePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.AttachRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachUserPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) AttachUserPolicy(ctx context.Context, params *iam.AttachUserPolicyInput, optFns ...func(*iam.Options)) (*iam.AttachUserPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.AttachUserPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AttachUserPolicyInput, ...func(*iam.Options)) (*iam.AttachUserPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.AttachUserPolicyInput, ...func(*iam.Options)) *iam.AttachUserPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.AttachUserPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.AttachUserPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangePassword provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ChangePassword(ctx context.Context, params *iam.ChangePasswordInput, optFns ...func(*iam.Options)) (*iam.ChangePasswordOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ChangePasswordOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ChangePasswordInput, ...func(*iam.Options)) (*iam.ChangePasswordOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ChangePasswordInput, ...func(*iam.Options)) *iam.ChangePasswordOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ChangePasswordOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ChangePasswordInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccessKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateAccessKey(ctx context.Context, params *iam.CreateAccessKeyInput, optFns ...func(*iam.Options)) (*iam.CreateAccessKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateAccessKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateAccessKeyInput, ...func(*iam.Options)) (*iam.CreateAccessKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateAccessKeyInput, ...func(*iam.Options)) *iam.CreateAccessKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateAccessKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateAccessKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccountAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateAccountAlias(ctx context.Context, params *iam.CreateAccountAliasInput, optFns ...func(*iam.Options)) (*iam.CreateAccountAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateAccountAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateAccountAliasInput, ...func(*iam.Options)) (*iam.CreateAccountAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateAccountAliasInput, ...func(*iam.Options)) *iam.CreateAccountAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateAccountAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateAccountAliasInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateGroup(ctx context.Context, params *iam.CreateGroupInput, optFns ...func(*iam.Options)) (*iam.CreateGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateGroupInput, ...func(*iam.Options)) (*iam.CreateGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateGroupInput, ...func(*iam.Options)) *iam.CreateGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateGroupInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateInstanceProfile(ctx context.Context, params *iam.CreateInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.CreateInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateInstanceProfileInput, ...func(*iam.Options)) (*iam.CreateInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateInstanceProfileInput, ...func(*iam.Options)) *iam.CreateInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoginProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateLoginProfile(ctx context.Context, params *iam.CreateLoginProfileInput, optFns ...func(*iam.Options)) (*iam.CreateLoginProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateLoginProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateLoginProfileInput, ...func(*iam.Options)) (*iam.CreateLoginProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateLoginProfileInput, ...func(*iam.Options)) *iam.CreateLoginProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateLoginProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateLoginProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateOpenIDConnectProvider(ctx context.Context, params *iam.CreateOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.CreateOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.CreateOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.CreateOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreatePolicy(ctx context.Context, params *iam.CreatePolicyInput, optFns ...func(*iam.Options)) (*iam.CreatePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreatePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreatePolicyInput, ...func(*iam.Options)) (*iam.CreatePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreatePolicyInput, ...func(*iam.Options)) *iam.CreatePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreatePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreatePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePolicyVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreatePolicyVersion(ctx context.Context, params *iam.CreatePolicyVersionInput, optFns ...func(*iam.Options)) (*iam.CreatePolicyVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreatePolicyVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreatePolicyVersionInput, ...func(*iam.Options)) (*iam.CreatePolicyVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreatePolicyVersionInput, ...func(*iam.Options)) *iam.CreatePolicyVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreatePolicyVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreatePolicyVersionInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateRole(ctx context.Context, params *iam.CreateRoleInput, optFns ...func(*iam.Options)) (*iam.CreateRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateRoleInput, ...func(*iam.Options)) (*iam.CreateRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateRoleInput, ...func(*iam.Options)) *iam.CreateRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSAMLProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateSAMLProvider(ctx context.Context, params *iam.CreateSAMLProviderInput, optFns ...func(*iam.Options)) (*iam.CreateSAMLProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateSAMLProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateSAMLProviderInput, ...func(*iam.Options)) (*iam.CreateSAMLProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateSAMLProviderInput, ...func(*iam.Options)) *iam.CreateSAMLProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateSAMLProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateSAMLProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateServiceLinkedRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateServiceLinkedRole(ctx context.Context, params *iam.CreateServiceLinkedRoleInput, optFns ...func(*iam.Options)) (*iam.CreateServiceLinkedRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateServiceLinkedRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateServiceLinkedRoleInput, ...func(*iam.Options)) (*iam.CreateServiceLinkedRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateServiceLinkedRoleInput, ...func(*iam.Options)) *iam.CreateServiceLinkedRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateServiceLinkedRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateServiceLinkedRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateServiceSpecificCredential provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateServiceSpecificCredential(ctx context.Context, params *iam.CreateServiceSpecificCredentialInput, optFns ...func(*iam.Options)) (*iam.CreateServiceSpecificCredentialOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateServiceSpecificCredentialOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateServiceSpecificCredentialInput, ...func(*iam.Options)) (*iam.CreateServiceSpecificCredentialOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateServiceSpecificCredentialInput, ...func(*iam.Options)) *iam.CreateServiceSpecificCredentialOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateServiceSpecificCredentialOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateServiceSpecificCredentialInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateUser(ctx context.Context, params *iam.CreateUserInput, optFns ...func(*iam.Options)) (*iam.CreateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateUserInput, ...func(*iam.Options)) (*iam.CreateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateUserInput, ...func(*iam.Options)) *iam.CreateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVirtualMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) CreateVirtualMFADevice(ctx context.Context, params *iam.CreateVirtualMFADeviceInput, optFns ...func(*iam.Options)) (*iam.CreateVirtualMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.CreateVirtualMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateVirtualMFADeviceInput, ...func(*iam.Options)) (*iam.CreateVirtualMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.CreateVirtualMFADeviceInput, ...func(*iam.Options)) *iam.CreateVirtualMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.CreateVirtualMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.CreateVirtualMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeactivateMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeactivateMFADevice(ctx context.Context, params *iam.DeactivateMFADeviceInput, optFns ...func(*iam.Options)) (*iam.DeactivateMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeactivateMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeactivateMFADeviceInput, ...func(*iam.Options)) (*iam.DeactivateMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeactivateMFADeviceInput, ...func(*iam.Options)) *iam.DeactivateMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeactivateMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeactivateMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteAccessKey(ctx context.Context, params *iam.DeleteAccessKeyInput, optFns ...func(*iam.Options)) (*iam.DeleteAccessKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteAccessKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteAccessKeyInput, ...func(*iam.Options)) (*iam.DeleteAccessKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteAccessKeyInput, ...func(*iam.Options)) *iam.DeleteAccessKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteAccessKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteAccessKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccountAlias provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteAccountAlias(ctx context.Context, params *iam.DeleteAccountAliasInput, optFns ...func(*iam.Options)) (*iam.DeleteAccountAliasOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteAccountAliasOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteAccountAliasInput, ...func(*iam.Options)) (*iam.DeleteAccountAliasOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteAccountAliasInput, ...func(*iam.Options)) *iam.DeleteAccountAliasOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteAccountAliasOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteAccountAliasInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccountPasswordPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteAccountPasswordPolicy(ctx context.Context, params *iam.DeleteAccountPasswordPolicyInput, optFns ...func(*iam.Options)) (*iam.DeleteAccountPasswordPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteAccountPasswordPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteAccountPasswordPolicyInput, ...func(*iam.Options)) (*iam.DeleteAccountPasswordPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteAccountPasswordPolicyInput, ...func(*iam.Options)) *iam.DeleteAccountPasswordPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteAccountPasswordPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteAccountPasswordPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteGroup(ctx context.Context, params *iam.DeleteGroupInput, optFns ...func(*iam.Options)) (*iam.DeleteGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteGroupInput, ...func(*iam.Options)) (*iam.DeleteGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteGroupInput, ...func(*iam.Options)) *iam.DeleteGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteGroupInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteGroupPolicy(ctx context.Context, params *iam.DeleteGroupPolicyInput, optFns ...func(*iam.Options)) (*iam.DeleteGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteGroupPolicyInput, ...func(*iam.Options)) (*iam.DeleteGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteGroupPolicyInput, ...func(*iam.Options)) *iam.DeleteGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteGroupPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteInstanceProfile(ctx context.Context, params *iam.DeleteInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.DeleteInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteInstanceProfileInput, ...func(*iam.Options)) (*iam.DeleteInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteInstanceProfileInput, ...func(*iam.Options)) *iam.DeleteInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoginProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteLoginProfile(ctx context.Context, params *iam.DeleteLoginProfileInput, optFns ...func(*iam.Options)) (*iam.DeleteLoginProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteLoginProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteLoginProfileInput, ...func(*iam.Options)) (*iam.DeleteLoginProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteLoginProfileInput, ...func(*iam.Options)) *iam.DeleteLoginProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteLoginProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteLoginProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteOpenIDConnectProvider(ctx context.Context, params *iam.DeleteOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.DeleteOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.DeleteOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.DeleteOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeletePolicy(ctx context.Context, params *iam.DeletePolicyInput, optFns ...func(*iam.Options)) (*iam.DeletePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeletePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeletePolicyInput, ...func(*iam.Options)) (*iam.DeletePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeletePolicyInput, ...func(*iam.Options)) *iam.DeletePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeletePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeletePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePolicyVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeletePolicyVersion(ctx context.Context, params *iam.DeletePolicyVersionInput, optFns ...func(*iam.Options)) (*iam.DeletePolicyVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeletePolicyVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeletePolicyVersionInput, ...func(*iam.Options)) (*iam.DeletePolicyVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeletePolicyVersionInput, ...func(*iam.Options)) *iam.DeletePolicyVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeletePolicyVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeletePolicyVersionInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteRole(ctx context.Context, params *iam.DeleteRoleInput, optFns ...func(*iam.Options)) (*iam.DeleteRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteRoleInput, ...func(*iam.Options)) (*iam.DeleteRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteRoleInput, ...func(*iam.Options)) *iam.DeleteRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRolePermissionsBoundary provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteRolePermissionsBoundary(ctx context.Context, params *iam.DeleteRolePermissionsBoundaryInput, optFns ...func(*iam.Options)) (*iam.DeleteRolePermissionsBoundaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteRolePermissionsBoundaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteRolePermissionsBoundaryInput, ...func(*iam.Options)) (*iam.DeleteRolePermissionsBoundaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteRolePermissionsBoundaryInput, ...func(*iam.Options)) *iam.DeleteRolePermissionsBoundaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteRolePermissionsBoundaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteRolePermissionsBoundaryInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRolePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteRolePolicy(ctx context.Context, params *iam.DeleteRolePolicyInput, optFns ...func(*iam.Options)) (*iam.DeleteRolePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteRolePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteRolePolicyInput, ...func(*iam.Options)) (*iam.DeleteRolePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteRolePolicyInput, ...func(*iam.Options)) *iam.DeleteRolePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteRolePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSAMLProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteSAMLProvider(ctx context.Context, params *iam.DeleteSAMLProviderInput, optFns ...func(*iam.Options)) (*iam.DeleteSAMLProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteSAMLProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteSAMLProviderInput, ...func(*iam.Options)) (*iam.DeleteSAMLProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteSAMLProviderInput, ...func(*iam.Options)) *iam.DeleteSAMLProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteSAMLProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteSAMLProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSSHPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteSSHPublicKey(ctx context.Context, params *iam.DeleteSSHPublicKeyInput, optFns ...func(*iam.Options)) (*iam.DeleteSSHPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteSSHPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteSSHPublicKeyInput, ...func(*iam.Options)) (*iam.DeleteSSHPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteSSHPublicKeyInput, ...func(*iam.Options)) *iam.DeleteSSHPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteSSHPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteSSHPublicKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteServerCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteServerCertificate(ctx context.Context, params *iam.DeleteServerCertificateInput, optFns ...func(*iam.Options)) (*iam.DeleteServerCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteServerCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteServerCertificateInput, ...func(*iam.Options)) (*iam.DeleteServerCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteServerCertificateInput, ...func(*iam.Options)) *iam.DeleteServerCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteServerCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteServerCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteServiceLinkedRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteServiceLinkedRole(ctx context.Context, params *iam.DeleteServiceLinkedRoleInput, optFns ...func(*iam.Options)) (*iam.DeleteServiceLinkedRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteServiceLinkedRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteServiceLinkedRoleInput, ...func(*iam.Options)) (*iam.DeleteServiceLinkedRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteServiceLinkedRoleInput, ...func(*iam.Options)) *iam.DeleteServiceLinkedRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteServiceLinkedRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteServiceLinkedRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteServiceSpecificCredential provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteServiceSpecificCredential(ctx context.Context, params *iam.DeleteServiceSpecificCredentialInput, optFns ...func(*iam.Options)) (*iam.DeleteServiceSpecificCredentialOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteServiceSpecificCredentialOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteServiceSpecificCredentialInput, ...func(*iam.Options)) (*iam.DeleteServiceSpecificCredentialOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteServiceSpecificCredentialInput, ...func(*iam.Options)) *iam.DeleteServiceSpecificCredentialOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteServiceSpecificCredentialOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteServiceSpecificCredentialInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSigningCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteSigningCertificate(ctx context.Context, params *iam.DeleteSigningCertificateInput, optFns ...func(*iam.Options)) (*iam.DeleteSigningCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteSigningCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteSigningCertificateInput, ...func(*iam.Options)) (*iam.DeleteSigningCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteSigningCertificateInput, ...func(*iam.Options)) *iam.DeleteSigningCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteSigningCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteSigningCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteUser(ctx context.Context, params *iam.DeleteUserInput, optFns ...func(*iam.Options)) (*iam.DeleteUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteUserInput, ...func(*iam.Options)) (*iam.DeleteUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteUserInput, ...func(*iam.Options)) *iam.DeleteUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUserPermissionsBoundary provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteUserPermissionsBoundary(ctx context.Context, params *iam.DeleteUserPermissionsBoundaryInput, optFns ...func(*iam.Options)) (*iam.DeleteUserPermissionsBoundaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteUserPermissionsBoundaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteUserPermissionsBoundaryInput, ...func(*iam.Options)) (*iam.DeleteUserPermissionsBoundaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteUserPermissionsBoundaryInput, ...func(*iam.Options)) *iam.DeleteUserPermissionsBoundaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteUserPermissionsBoundaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteUserPermissionsBoundaryInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUserPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteUserPolicy(ctx context.Context, params *iam.DeleteUserPolicyInput, optFns ...func(*iam.Options)) (*iam.DeleteUserPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteUserPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteUserPolicyInput, ...func(*iam.Options)) (*iam.DeleteUserPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteUserPolicyInput, ...func(*iam.Options)) *iam.DeleteUserPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteUserPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteUserPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVirtualMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DeleteVirtualMFADevice(ctx context.Context, params *iam.DeleteVirtualMFADeviceInput, optFns ...func(*iam.Options)) (*iam.DeleteVirtualMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DeleteVirtualMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteVirtualMFADeviceInput, ...func(*iam.Options)) (*iam.DeleteVirtualMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DeleteVirtualMFADeviceInput, ...func(*iam.Options)) *iam.DeleteVirtualMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DeleteVirtualMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DeleteVirtualMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DetachGroupPolicy(ctx context.Context, params *iam.DetachGroupPolicyInput, optFns ...func(*iam.Options)) (*iam.DetachGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DetachGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DetachGroupPolicyInput, ...func(*iam.Options)) (*iam.DetachGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DetachGroupPolicyInput, ...func(*iam.Options)) *iam.DetachGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DetachGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DetachGroupPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachRolePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DetachRolePolicy(ctx context.Context, params *iam.DetachRolePolicyInput, optFns ...func(*iam.Options)) (*iam.DetachRolePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DetachRolePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DetachRolePolicyInput, ...func(*iam.Options)) (*iam.DetachRolePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DetachRolePolicyInput, ...func(*iam.Options)) *iam.DetachRolePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DetachRolePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DetachRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachUserPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) DetachUserPolicy(ctx context.Context, params *iam.DetachUserPolicyInput, optFns ...func(*iam.Options)) (*iam.DetachUserPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.DetachUserPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DetachUserPolicyInput, ...func(*iam.Options)) (*iam.DetachUserPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.DetachUserPolicyInput, ...func(*iam.Options)) *iam.DetachUserPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.DetachUserPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.DetachUserPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) EnableMFADevice(ctx context.Context, params *iam.EnableMFADeviceInput, optFns ...func(*iam.Options)) (*iam.EnableMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.EnableMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.EnableMFADeviceInput, ...func(*iam.Options)) (*iam.EnableMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.EnableMFADeviceInput, ...func(*iam.Options)) *iam.EnableMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.EnableMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.EnableMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateCredentialReport provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GenerateCredentialReport(ctx context.Context, params *iam.GenerateCredentialReportInput, optFns ...func(*iam.Options)) (*iam.GenerateCredentialReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GenerateCredentialReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GenerateCredentialReportInput, ...func(*iam.Options)) (*iam.GenerateCredentialReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GenerateCredentialReportInput, ...func(*iam.Options)) *iam.GenerateCredentialReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GenerateCredentialReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GenerateCredentialReportInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateOrganizationsAccessReport provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GenerateOrganizationsAccessReport(ctx context.Context, params *iam.GenerateOrganizationsAccessReportInput, optFns ...func(*iam.Options)) (*iam.GenerateOrganizationsAccessReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GenerateOrganizationsAccessReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GenerateOrganizationsAccessReportInput, ...func(*iam.Options)) (*iam.GenerateOrganizationsAccessReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GenerateOrganizationsAccessReportInput, ...func(*iam.Options)) *iam.GenerateOrganizationsAccessReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GenerateOrganizationsAccessReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GenerateOrganizationsAccessReportInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateServiceLastAccessedDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GenerateServiceLastAccessedDetails(ctx context.Context, params *iam.GenerateServiceLastAccessedDetailsInput, optFns ...func(*iam.Options)) (*iam.GenerateServiceLastAccessedDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GenerateServiceLastAccessedDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GenerateServiceLastAccessedDetailsInput, ...func(*iam.Options)) (*iam.GenerateServiceLastAccessedDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GenerateServiceLastAccessedDetailsInput, ...func(*iam.Options)) *iam.GenerateServiceLastAccessedDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GenerateServiceLastAccessedDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GenerateServiceLastAccessedDetailsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccessKeyLastUsed provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetAccessKeyLastUsed(ctx context.Context, params *iam.GetAccessKeyLastUsedInput, optFns ...func(*iam.Options)) (*iam.GetAccessKeyLastUsedOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetAccessKeyLastUsedOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccessKeyLastUsedInput, ...func(*iam.Options)) (*iam.GetAccessKeyLastUsedOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccessKeyLastUsedInput, ...func(*iam.Options)) *iam.GetAccessKeyLastUsedOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetAccessKeyLastUsedOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetAccessKeyLastUsedInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountAuthorizationDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetAccountAuthorizationDetails(ctx context.Context, params *iam.GetAccountAuthorizationDetailsInput, optFns ...func(*iam.Options)) (*iam.GetAccountAuthorizationDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetAccountAuthorizationDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccountAuthorizationDetailsInput, ...func(*iam.Options)) (*iam.GetAccountAuthorizationDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccountAuthorizationDetailsInput, ...func(*iam.Options)) *iam.GetAccountAuthorizationDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetAccountAuthorizationDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetAccountAuthorizationDetailsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountPasswordPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetAccountPasswordPolicy(ctx context.Context, params *iam.GetAccountPasswordPolicyInput, optFns ...func(*iam.Options)) (*iam.GetAccountPasswordPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetAccountPasswordPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccountPasswordPolicyInput, ...func(*iam.Options)) (*iam.GetAccountPasswordPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccountPasswordPolicyInput, ...func(*iam.Options)) *iam.GetAccountPasswordPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetAccountPasswordPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetAccountPasswordPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountSummary provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetAccountSummary(ctx context.Context, params *iam.GetAccountSummaryInput, optFns ...func(*iam.Options)) (*iam.GetAccountSummaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetAccountSummaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccountSummaryInput, ...func(*iam.Options)) (*iam.GetAccountSummaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetAccountSummaryInput, ...func(*iam.Options)) *iam.GetAccountSummaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetAccountSummaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetAccountSummaryInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContextKeysForCustomPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetContextKeysForCustomPolicy(ctx context.Context, params *iam.GetContextKeysForCustomPolicyInput, optFns ...func(*iam.Options)) (*iam.GetContextKeysForCustomPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetContextKeysForCustomPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetContextKeysForCustomPolicyInput, ...func(*iam.Options)) (*iam.GetContextKeysForCustomPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetContextKeysForCustomPolicyInput, ...func(*iam.Options)) *iam.GetContextKeysForCustomPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetContextKeysForCustomPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetContextKeysForCustomPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContextKeysForPrincipalPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetContextKeysForPrincipalPolicy(ctx context.Context, params *iam.GetContextKeysForPrincipalPolicyInput, optFns ...func(*iam.Options)) (*iam.GetContextKeysForPrincipalPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetContextKeysForPrincipalPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetContextKeysForPrincipalPolicyInput, ...func(*iam.Options)) (*iam.GetContextKeysForPrincipalPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetContextKeysForPrincipalPolicyInput, ...func(*iam.Options)) *iam.GetContextKeysForPrincipalPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetContextKeysForPrincipalPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetContextKeysForPrincipalPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCredentialReport provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetCredentialReport(ctx context.Context, params *iam.GetCredentialReportInput, optFns ...func(*iam.Options)) (*iam.GetCredentialReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetCredentialReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetCredentialReportInput, ...func(*iam.Options)) (*iam.GetCredentialReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetCredentialReportInput, ...func(*iam.Options)) *iam.GetCredentialReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetCredentialReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetCredentialReportInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetGroup(ctx context.Context, params *iam.GetGroupInput, optFns ...func(*iam.Options)) (*iam.GetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetGroupInput, ...func(*iam.Options)) (*iam.GetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetGroupInput, ...func(*iam.Options)) *iam.GetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetGroupInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetGroupPolicy(ctx context.Context, params *iam.GetGroupPolicyInput, optFns ...func(*iam.Options)) (*iam.GetGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetGroupPolicyInput, ...func(*iam.Options)) (*iam.GetGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetGroupPolicyInput, ...func(*iam.Options)) *iam.GetGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetGroupPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetInstanceProfile(ctx context.Context, params *iam.GetInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.GetInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetInstanceProfileInput, ...func(*iam.Options)) (*iam.GetInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetInstanceProfileInput, ...func(*iam.Options)) *iam.GetInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoginProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetLoginProfile(ctx context.Context, params *iam.GetLoginProfileInput, optFns ...func(*iam.Options)) (*iam.GetLoginProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetLoginProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetLoginProfileInput, ...func(*iam.Options)) (*iam.GetLoginProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetLoginProfileInput, ...func(*iam.Options)) *iam.GetLoginProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetLoginProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetLoginProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetMFADevice(ctx context.Context, params *iam.GetMFADeviceInput, optFns ...func(*iam.Options)) (*iam.GetMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetMFADeviceInput, ...func(*iam.Options)) (*iam.GetMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetMFADeviceInput, ...func(*iam.Options)) *iam.GetMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetOpenIDConnectProvider(ctx context.Context, params *iam.GetOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.GetOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.GetOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.GetOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOrganizationsAccessReport provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetOrganizationsAccessReport(ctx context.Context, params *iam.GetOrganizationsAccessReportInput, optFns ...func(*iam.Options)) (*iam.GetOrganizationsAccessReportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetOrganizationsAccessReportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetOrganizationsAccessReportInput, ...func(*iam.Options)) (*iam.GetOrganizationsAccessReportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetOrganizationsAccessReportInput, ...func(*iam.Options)) *iam.GetOrganizationsAccessReportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetOrganizationsAccessReportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetOrganizationsAccessReportInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetPolicy(ctx context.Context, params *iam.GetPolicyInput, optFns ...func(*iam.Options)) (*iam.GetPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyInput, ...func(*iam.Options)) (*iam.GetPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyInput, ...func(*iam.Options)) *iam.GetPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicyVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetPolicyVersion(ctx context.Context, params *iam.GetPolicyVersionInput, optFns ...func(*iam.Options)) (*iam.GetPolicyVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetPolicyVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyVersionInput, ...func(*iam.Options)) (*iam.GetPolicyVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyVersionInput, ...func(*iam.Options)) *iam.GetPolicyVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetPolicyVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetPolicyVersionInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetRole(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options)) (*iam.GetRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetRoleInput, ...func(*iam.Options)) (*iam.GetRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetRoleInput, ...func(*iam.Options)) *iam.GetRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRolePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetRolePolicy(ctx context.Context, params *iam.GetRolePolicyInput, optFns ...func(*iam.Options)) (*iam.GetRolePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetRolePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetRolePolicyInput, ...func(*iam.Options)) (*iam.GetRolePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetRolePolicyInput, ...func(*iam.Options)) *iam.GetRolePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetRolePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSAMLProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetSAMLProvider(ctx context.Context, params *iam.GetSAMLProviderInput, optFns ...func(*iam.Options)) (*iam.GetSAMLProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetSAMLProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetSAMLProviderInput, ...func(*iam.Options)) (*iam.GetSAMLProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetSAMLProviderInput, ...func(*iam.Options)) *iam.GetSAMLProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetSAMLProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetSAMLProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSSHPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetSSHPublicKey(ctx context.Context, params *iam.GetSSHPublicKeyInput, optFns ...func(*iam.Options)) (*iam.GetSSHPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetSSHPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetSSHPublicKeyInput, ...func(*iam.Options)) (*iam.GetSSHPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetSSHPublicKeyInput, ...func(*iam.Options)) *iam.GetSSHPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetSSHPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetSSHPublicKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServerCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetServerCertificate(ctx context.Context, params *iam.GetServerCertificateInput, optFns ...func(*iam.Options)) (*iam.GetServerCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetServerCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServerCertificateInput, ...func(*iam.Options)) (*iam.GetServerCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServerCertificateInput, ...func(*iam.Options)) *iam.GetServerCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetServerCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetServerCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServiceLastAccessedDetails provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetServiceLastAccessedDetails(ctx context.Context, params *iam.GetServiceLastAccessedDetailsInput, optFns ...func(*iam.Options)) (*iam.GetServiceLastAccessedDetailsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetServiceLastAccessedDetailsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServiceLastAccessedDetailsInput, ...func(*iam.Options)) (*iam.GetServiceLastAccessedDetailsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServiceLastAccessedDetailsInput, ...func(*iam.Options)) *iam.GetServiceLastAccessedDetailsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetServiceLastAccessedDetailsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetServiceLastAccessedDetailsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServiceLastAccessedDetailsWithEntities provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetServiceLastAccessedDetailsWithEntities(ctx context.Context, params *iam.GetServiceLastAccessedDetailsWithEntitiesInput, optFns ...func(*iam.Options)) (*iam.GetServiceLastAccessedDetailsWithEntitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetServiceLastAccessedDetailsWithEntitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServiceLastAccessedDetailsWithEntitiesInput, ...func(*iam.Options)) (*iam.GetServiceLastAccessedDetailsWithEntitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServiceLastAccessedDetailsWithEntitiesInput, ...func(*iam.Options)) *iam.GetServiceLastAccessedDetailsWithEntitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetServiceLastAccessedDetailsWithEntitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetServiceLastAccessedDetailsWithEntitiesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServiceLinkedRoleDeletionStatus provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetServiceLinkedRoleDeletionStatus(ctx context.Context, params *iam.GetServiceLinkedRoleDeletionStatusInput, optFns ...func(*iam.Options)) (*iam.GetServiceLinkedRoleDeletionStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetServiceLinkedRoleDeletionStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServiceLinkedRoleDeletionStatusInput, ...func(*iam.Options)) (*iam.GetServiceLinkedRoleDeletionStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetServiceLinkedRoleDeletionStatusInput, ...func(*iam.Options)) *iam.GetServiceLinkedRoleDeletionStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetServiceLinkedRoleDeletionStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetServiceLinkedRoleDeletionStatusInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetUser(ctx context.Context, params *iam.GetUserInput, optFns ...func(*iam.Options)) (*iam.GetUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetUserInput, ...func(*iam.Options)) (*iam.GetUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetUserInput, ...func(*iam.Options)) *iam.GetUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) GetUserPolicy(ctx context.Context, params *iam.GetUserPolicyInput, optFns ...func(*iam.Options)) (*iam.GetUserPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.GetUserPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetUserPolicyInput, ...func(*iam.Options)) (*iam.GetUserPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.GetUserPolicyInput, ...func(*iam.Options)) *iam.GetUserPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetUserPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.GetUserPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListAccessKeys(ctx context.Context, params *iam.ListAccessKeysInput, optFns ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListAccessKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAccessKeysInput, ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAccessKeysInput, ...func(*iam.Options)) *iam.ListAccessKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAccessKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListAccessKeysInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccountAliases provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListAccountAliases(ctx context.Context, params *iam.ListAccountAliasesInput, optFns ...func(*iam.Options)) (*iam.ListAccountAliasesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListAccountAliasesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAccountAliasesInput, ...func(*iam.Options)) (*iam.ListAccountAliasesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAccountAliasesInput, ...func(*iam.Options)) *iam.ListAccountAliasesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAccountAliasesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListAccountAliasesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAttachedGroupPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListAttachedGroupPolicies(ctx context.Context, params *iam.ListAttachedGroupPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedGroupPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListAttachedGroupPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedGroupPoliciesInput, ...func(*iam.Options)) (*iam.ListAttachedGroupPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedGroupPoliciesInput, ...func(*iam.Options)) *iam.ListAttachedGroupPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAttachedGroupPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListAttachedGroupPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAttachedRolePolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListAttachedRolePolicies(ctx context.Context, params *iam.ListAttachedRolePoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedRolePoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListAttachedRolePoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedRolePoliciesInput, ...func(*iam.Options)) (*iam.ListAttachedRolePoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedRolePoliciesInput, ...func(*iam.Options)) *iam.ListAttachedRolePoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAttachedRolePoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListAttachedRolePoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAttachedUserPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListAttachedUserPolicies(ctx context.Context, params *iam.ListAttachedUserPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedUserPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListAttachedUserPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedUserPoliciesInput, ...func(*iam.Options)) (*iam.ListAttachedUserPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedUserPoliciesInput, ...func(*iam.Options)) *iam.ListAttachedUserPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAttachedUserPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListAttachedUserPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEntitiesForPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListEntitiesForPolicy(ctx context.Context, params *iam.ListEntitiesForPolicyInput, optFns ...func(*iam.Options)) (*iam.ListEntitiesForPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListEntitiesForPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListEntitiesForPolicyInput, ...func(*iam.Options)) (*iam.ListEntitiesForPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListEntitiesForPolicyInput, ...func(*iam.Options)) *iam.ListEntitiesForPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListEntitiesForPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListEntitiesForPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGroupPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListGroupPolicies(ctx context.Context, params *iam.ListGroupPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListGroupPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListGroupPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListGroupPoliciesInput, ...func(*iam.Options)) (*iam.ListGroupPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListGroupPoliciesInput, ...func(*iam.Options)) *iam.ListGroupPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListGroupPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListGroupPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGroups provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListGroups(ctx context.Context, params *iam.ListGroupsInput, optFns ...func(*iam.Options)) (*iam.ListGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListGroupsInput, ...func(*iam.Options)) (*iam.ListGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListGroupsInput, ...func(*iam.Options)) *iam.ListGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListGroupsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGroupsForUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListGroupsForUser(ctx context.Context, params *iam.ListGroupsForUserInput, optFns ...func(*iam.Options)) (*iam.ListGroupsForUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListGroupsForUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListGroupsForUserInput, ...func(*iam.Options)) (*iam.ListGroupsForUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListGroupsForUserInput, ...func(*iam.Options)) *iam.ListGroupsForUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListGroupsForUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListGroupsForUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstanceProfileTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListInstanceProfileTags(ctx context.Context, params *iam.ListInstanceProfileTagsInput, optFns ...func(*iam.Options)) (*iam.ListInstanceProfileTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListInstanceProfileTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListInstanceProfileTagsInput, ...func(*iam.Options)) (*iam.ListInstanceProfileTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListInstanceProfileTagsInput, ...func(*iam.Options)) *iam.ListInstanceProfileTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListInstanceProfileTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListInstanceProfileTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstanceProfiles provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListInstanceProfiles(ctx context.Context, params *iam.ListInstanceProfilesInput, optFns ...func(*iam.Options)) (*iam.ListInstanceProfilesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListInstanceProfilesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListInstanceProfilesInput, ...func(*iam.Options)) (*iam.ListInstanceProfilesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListInstanceProfilesInput, ...func(*iam.Options)) *iam.ListInstanceProfilesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListInstanceProfilesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListInstanceProfilesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInstanceProfilesForRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListInstanceProfilesForRole(ctx context.Context, params *iam.ListInstanceProfilesForRoleInput, optFns ...func(*iam.Options)) (*iam.ListInstanceProfilesForRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListInstanceProfilesForRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListInstanceProfilesForRoleInput, ...func(*iam.Options)) (*iam.ListInstanceProfilesForRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListInstanceProfilesForRoleInput, ...func(*iam.Options)) *iam.ListInstanceProfilesForRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListInstanceProfilesForRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListInstanceProfilesForRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMFADeviceTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListMFADeviceTags(ctx context.Context, params *iam.ListMFADeviceTagsInput, optFns ...func(*iam.Options)) (*iam.ListMFADeviceTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListMFADeviceTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListMFADeviceTagsInput, ...func(*iam.Options)) (*iam.ListMFADeviceTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListMFADeviceTagsInput, ...func(*iam.Options)) *iam.ListMFADeviceTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListMFADeviceTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListMFADeviceTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMFADevices provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListMFADevices(ctx context.Context, params *iam.ListMFADevicesInput, optFns ...func(*iam.Options)) (*iam.ListMFADevicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListMFADevicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListMFADevicesInput, ...func(*iam.Options)) (*iam.ListMFADevicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListMFADevicesInput, ...func(*iam.Options)) *iam.ListMFADevicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListMFADevicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListMFADevicesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOpenIDConnectProviderTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListOpenIDConnectProviderTags(ctx context.Context, params *iam.ListOpenIDConnectProviderTagsInput, optFns ...func(*iam.Options)) (*iam.ListOpenIDConnectProviderTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListOpenIDConnectProviderTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListOpenIDConnectProviderTagsInput, ...func(*iam.Options)) (*iam.ListOpenIDConnectProviderTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListOpenIDConnectProviderTagsInput, ...func(*iam.Options)) *iam.ListOpenIDConnectProviderTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListOpenIDConnectProviderTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListOpenIDConnectProviderTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOpenIDConnectProviders provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListOpenIDConnectProviders(ctx context.Context, params *iam.ListOpenIDConnectProvidersInput, optFns ...func(*iam.Options)) (*iam.ListOpenIDConnectProvidersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListOpenIDConnectProvidersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListOpenIDConnectProvidersInput, ...func(*iam.Options)) (*iam.ListOpenIDConnectProvidersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListOpenIDConnectProvidersInput, ...func(*iam.Options)) *iam.ListOpenIDConnectProvidersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListOpenIDConnectProvidersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListOpenIDConnectProvidersInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListPolicies(ctx context.Context, params *iam.ListPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPoliciesInput, ...func(*iam.Options)) (*iam.ListPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPoliciesInput, ...func(*iam.Options)) *iam.ListPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPoliciesGrantingServiceAccess provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListPoliciesGrantingServiceAccess(ctx context.Context, params *iam.ListPoliciesGrantingServiceAccessInput, optFns ...func(*iam.Options)) (*iam.ListPoliciesGrantingServiceAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListPoliciesGrantingServiceAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPoliciesGrantingServiceAccessInput, ...func(*iam.Options)) (*iam.ListPoliciesGrantingServiceAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPoliciesGrantingServiceAccessInput, ...func(*iam.Options)) *iam.ListPoliciesGrantingServiceAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListPoliciesGrantingServiceAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListPoliciesGrantingServiceAccessInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPolicyTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListPolicyTags(ctx context.Context, params *iam.ListPolicyTagsInput, optFns ...func(*iam.Options)) (*iam.ListPolicyTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListPolicyTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPolicyTagsInput, ...func(*iam.Options)) (*iam.ListPolicyTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPolicyTagsInput, ...func(*iam.Options)) *iam.ListPolicyTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListPolicyTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListPolicyTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPolicyVersions provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListPolicyVersions(ctx context.Context, params *iam.ListPolicyVersionsInput, optFns ...func(*iam.Options)) (*iam.ListPolicyVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListPolicyVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPolicyVersionsInput, ...func(*iam.Options)) (*iam.ListPolicyVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListPolicyVersionsInput, ...func(*iam.Options)) *iam.ListPolicyVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListPolicyVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListPolicyVersionsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRolePolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListRolePolicies(ctx context.Context, params *iam.ListRolePoliciesInput, optFns ...func(*iam.Options)) (*iam.ListRolePoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListRolePoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListRolePoliciesInput, ...func(*iam.Options)) (*iam.ListRolePoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListRolePoliciesInput, ...func(*iam.Options)) *iam.ListRolePoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListRolePoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListRolePoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRoleTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListRoleTags(ctx context.Context, params *iam.ListRoleTagsInput, optFns ...func(*iam.Options)) (*iam.ListRoleTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListRoleTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListRoleTagsInput, ...func(*iam.Options)) (*iam.ListRoleTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListRoleTagsInput, ...func(*iam.Options)) *iam.ListRoleTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListRoleTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListRoleTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRoles provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListRoles(ctx context.Context, params *iam.ListRolesInput, optFns ...func(*iam.Options)) (*iam.ListRolesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListRolesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListRolesInput, ...func(*iam.Options)) (*iam.ListRolesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListRolesInput, ...func(*iam.Options)) *iam.ListRolesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListRolesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListRolesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSAMLProviderTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListSAMLProviderTags(ctx context.Context, params *iam.ListSAMLProviderTagsInput, optFns ...func(*iam.Options)) (*iam.ListSAMLProviderTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListSAMLProviderTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSAMLProviderTagsInput, ...func(*iam.Options)) (*iam.ListSAMLProviderTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSAMLProviderTagsInput, ...func(*iam.Options)) *iam.ListSAMLProviderTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListSAMLProviderTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListSAMLProviderTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSAMLProviders provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListSAMLProviders(ctx context.Context, params *iam.ListSAMLProvidersInput, optFns ...func(*iam.Options)) (*iam.ListSAMLProvidersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListSAMLProvidersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSAMLProvidersInput, ...func(*iam.Options)) (*iam.ListSAMLProvidersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSAMLProvidersInput, ...func(*iam.Options)) *iam.ListSAMLProvidersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListSAMLProvidersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListSAMLProvidersInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSSHPublicKeys provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListSSHPublicKeys(ctx context.Context, params *iam.ListSSHPublicKeysInput, optFns ...func(*iam.Options)) (*iam.ListSSHPublicKeysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListSSHPublicKeysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSSHPublicKeysInput, ...func(*iam.Options)) (*iam.ListSSHPublicKeysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSSHPublicKeysInput, ...func(*iam.Options)) *iam.ListSSHPublicKeysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListSSHPublicKeysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListSSHPublicKeysInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListServerCertificateTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListServerCertificateTags(ctx context.Context, params *iam.ListServerCertificateTagsInput, optFns ...func(*iam.Options)) (*iam.ListServerCertificateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListServerCertificateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListServerCertificateTagsInput, ...func(*iam.Options)) (*iam.ListServerCertificateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListServerCertificateTagsInput, ...func(*iam.Options)) *iam.ListServerCertificateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListServerCertificateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListServerCertificateTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListServerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListServerCertificates(ctx context.Context, params *iam.ListServerCertificatesInput, optFns ...func(*iam.Options)) (*iam.ListServerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListServerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListServerCertificatesInput, ...func(*iam.Options)) (*iam.ListServerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListServerCertificatesInput, ...func(*iam.Options)) *iam.ListServerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListServerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListServerCertificatesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListServiceSpecificCredentials provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListServiceSpecificCredentials(ctx context.Context, params *iam.ListServiceSpecificCredentialsInput, optFns ...func(*iam.Options)) (*iam.ListServiceSpecificCredentialsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListServiceSpecificCredentialsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListServiceSpecificCredentialsInput, ...func(*iam.Options)) (*iam.ListServiceSpecificCredentialsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListServiceSpecificCredentialsInput, ...func(*iam.Options)) *iam.ListServiceSpecificCredentialsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListServiceSpecificCredentialsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListServiceSpecificCredentialsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSigningCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListSigningCertificates(ctx context.Context, params *iam.ListSigningCertificatesInput, optFns ...func(*iam.Options)) (*iam.ListSigningCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListSigningCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSigningCertificatesInput, ...func(*iam.Options)) (*iam.ListSigningCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListSigningCertificatesInput, ...func(*iam.Options)) *iam.ListSigningCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListSigningCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListSigningCertificatesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUserPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListUserPolicies(ctx context.Context, params *iam.ListUserPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListUserPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListUserPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListUserPoliciesInput, ...func(*iam.Options)) (*iam.ListUserPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListUserPoliciesInput, ...func(*iam.Options)) *iam.ListUserPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListUserPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListUserPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUserTags provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListUserTags(ctx context.Context, params *iam.ListUserTagsInput, optFns ...func(*iam.Options)) (*iam.ListUserTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListUserTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListUserTagsInput, ...func(*iam.Options)) (*iam.ListUserTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListUserTagsInput, ...func(*iam.Options)) *iam.ListUserTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListUserTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListUserTagsInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListUsers(ctx context.Context, params *iam.ListUsersInput, optFns ...func(*iam.Options)) (*iam.ListUsersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListUsersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListUsersInput, ...func(*iam.Options)) (*iam.ListUsersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListUsersInput, ...func(*iam.Options)) *iam.ListUsersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListUsersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListUsersInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVirtualMFADevices provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ListVirtualMFADevices(ctx context.Context, params *iam.ListVirtualMFADevicesInput, optFns ...func(*iam.Options)) (*iam.ListVirtualMFADevicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ListVirtualMFADevicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListVirtualMFADevicesInput, ...func(*iam.Options)) (*iam.ListVirtualMFADevicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ListVirtualMFADevicesInput, ...func(*iam.Options)) *iam.ListVirtualMFADevicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListVirtualMFADevicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ListVirtualMFADevicesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutGroupPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) PutGroupPolicy(ctx context.Context, params *iam.PutGroupPolicyInput, optFns ...func(*iam.Options)) (*iam.PutGroupPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.PutGroupPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutGroupPolicyInput, ...func(*iam.Options)) (*iam.PutGroupPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutGroupPolicyInput, ...func(*iam.Options)) *iam.PutGroupPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.PutGroupPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.PutGroupPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRolePermissionsBoundary provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) PutRolePermissionsBoundary(ctx context.Context, params *iam.PutRolePermissionsBoundaryInput, optFns ...func(*iam.Options)) (*iam.PutRolePermissionsBoundaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.PutRolePermissionsBoundaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutRolePermissionsBoundaryInput, ...func(*iam.Options)) (*iam.PutRolePermissionsBoundaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutRolePermissionsBoundaryInput, ...func(*iam.Options)) *iam.PutRolePermissionsBoundaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.PutRolePermissionsBoundaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.PutRolePermissionsBoundaryInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutRolePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) PutRolePolicy(ctx context.Context, params *iam.PutRolePolicyInput, optFns ...func(*iam.Options)) (*iam.PutRolePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.PutRolePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutRolePolicyInput, ...func(*iam.Options)) (*iam.PutRolePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutRolePolicyInput, ...func(*iam.Options)) *iam.PutRolePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.PutRolePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.PutRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutUserPermissionsBoundary provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) PutUserPermissionsBoundary(ctx context.Context, params *iam.PutUserPermissionsBoundaryInput, optFns ...func(*iam.Options)) (*iam.PutUserPermissionsBoundaryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.PutUserPermissionsBoundaryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutUserPermissionsBoundaryInput, ...func(*iam.Options)) (*iam.PutUserPermissionsBoundaryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutUserPermissionsBoundaryInput, ...func(*iam.Options)) *iam.PutUserPermissionsBoundaryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.PutUserPermissionsBoundaryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.PutUserPermissionsBoundaryInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutUserPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) PutUserPolicy(ctx context.Context, params *iam.PutUserPolicyInput, optFns ...func(*iam.Options)) (*iam.PutUserPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.PutUserPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutUserPolicyInput, ...func(*iam.Options)) (*iam.PutUserPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.PutUserPolicyInput, ...func(*iam.Options)) *iam.PutUserPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.PutUserPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.PutUserPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveClientIDFromOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) RemoveClientIDFromOpenIDConnectProvider(ctx context.Context, params *iam.RemoveClientIDFromOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.RemoveClientIDFromOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.RemoveClientIDFromOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.RemoveClientIDFromOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.RemoveClientIDFromOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.RemoveClientIDFromOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.RemoveClientIDFromOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.RemoveClientIDFromOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.RemoveClientIDFromOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveRoleFromInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) RemoveRoleFromInstanceProfile(ctx context.Context, params *iam.RemoveRoleFromInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.RemoveRoleFromInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.RemoveRoleFromInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.RemoveRoleFromInstanceProfileInput, ...func(*iam.Options)) (*iam.RemoveRoleFromInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.RemoveRoleFromInstanceProfileInput, ...func(*iam.Options)) *iam.RemoveRoleFromInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.RemoveRoleFromInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.RemoveRoleFromInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveUserFromGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) RemoveUserFromGroup(ctx context.Context, params *iam.RemoveUserFromGroupInput, optFns ...func(*iam.Options)) (*iam.RemoveUserFromGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.RemoveUserFromGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.RemoveUserFromGroupInput, ...func(*iam.Options)) (*iam.RemoveUserFromGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.RemoveUserFromGroupInput, ...func(*iam.Options)) *iam.RemoveUserFromGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.RemoveUserFromGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.RemoveUserFromGroupInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetServiceSpecificCredential provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ResetServiceSpecificCredential(ctx context.Context, params *iam.ResetServiceSpecificCredentialInput, optFns ...func(*iam.Options)) (*iam.ResetServiceSpecificCredentialOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ResetServiceSpecificCredentialOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ResetServiceSpecificCredentialInput, ...func(*iam.Options)) (*iam.ResetServiceSpecificCredentialOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ResetServiceSpecificCredentialInput, ...func(*iam.Options)) *iam.ResetServiceSpecificCredentialOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ResetServiceSpecificCredentialOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ResetServiceSpecificCredentialInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResyncMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) ResyncMFADevice(ctx context.Context, params *iam.ResyncMFADeviceInput, optFns ...func(*iam.Options)) (*iam.ResyncMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.ResyncMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ResyncMFADeviceInput, ...func(*iam.Options)) (*iam.ResyncMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.ResyncMFADeviceInput, ...func(*iam.Options)) *iam.ResyncMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ResyncMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.ResyncMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetDefaultPolicyVersion provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) SetDefaultPolicyVersion(ctx context.Context, params *iam.SetDefaultPolicyVersionInput, optFns ...func(*iam.Options)) (*iam.SetDefaultPolicyVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.SetDefaultPolicyVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SetDefaultPolicyVersionInput, ...func(*iam.Options)) (*iam.SetDefaultPolicyVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SetDefaultPolicyVersionInput, ...func(*iam.Options)) *iam.SetDefaultPolicyVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.SetDefaultPolicyVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.SetDefaultPolicyVersionInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSecurityTokenServicePreferences provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) SetSecurityTokenServicePreferences(ctx context.Context, params *iam.SetSecurityTokenServicePreferencesInput, optFns ...func(*iam.Options)) (*iam.SetSecurityTokenServicePreferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.SetSecurityTokenServicePreferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SetSecurityTokenServicePreferencesInput, ...func(*iam.Options)) (*iam.SetSecurityTokenServicePreferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SetSecurityTokenServicePreferencesInput, ...func(*iam.Options)) *iam.SetSecurityTokenServicePreferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.SetSecurityTokenServicePreferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.SetSecurityTokenServicePreferencesInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SimulateCustomPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) SimulateCustomPolicy(ctx context.Context, params *iam.SimulateCustomPolicyInput, optFns ...func(*iam.Options)) (*iam.SimulateCustomPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.SimulateCustomPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SimulateCustomPolicyInput, ...func(*iam.Options)) (*iam.SimulateCustomPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SimulateCustomPolicyInput, ...func(*iam.Options)) *iam.SimulateCustomPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.SimulateCustomPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.SimulateCustomPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SimulatePrincipalPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) SimulatePrincipalPolicy(ctx context.Context, params *iam.SimulatePrincipalPolicyInput, optFns ...func(*iam.Options)) (*iam.SimulatePrincipalPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.SimulatePrincipalPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SimulatePrincipalPolicyInput, ...func(*iam.Options)) (*iam.SimulatePrincipalPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.SimulatePrincipalPolicyInput, ...func(*iam.Options)) *iam.SimulatePrincipalPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.SimulatePrincipalPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.SimulatePrincipalPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagInstanceProfile(ctx context.Context, params *iam.TagInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.TagInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagInstanceProfileInput, ...func(*iam.Options)) (*iam.TagInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagInstanceProfileInput, ...func(*iam.Options)) *iam.TagInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagMFADevice(ctx context.Context, params *iam.TagMFADeviceInput, optFns ...func(*iam.Options)) (*iam.TagMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagMFADeviceInput, ...func(*iam.Options)) (*iam.TagMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagMFADeviceInput, ...func(*iam.Options)) *iam.TagMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagOpenIDConnectProvider(ctx context.Context, params *iam.TagOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.TagOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.TagOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.TagOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagPolicy(ctx context.Context, params *iam.TagPolicyInput, optFns ...func(*iam.Options)) (*iam.TagPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagPolicyInput, ...func(*iam.Options)) (*iam.TagPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagPolicyInput, ...func(*iam.Options)) *iam.TagPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagRole(ctx context.Context, params *iam.TagRoleInput, optFns ...func(*iam.Options)) (*iam.TagRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagRoleInput, ...func(*iam.Options)) (*iam.TagRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagRoleInput, ...func(*iam.Options)) *iam.TagRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagSAMLProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagSAMLProvider(ctx context.Context, params *iam.TagSAMLProviderInput, optFns ...func(*iam.Options)) (*iam.TagSAMLProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagSAMLProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagSAMLProviderInput, ...func(*iam.Options)) (*iam.TagSAMLProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagSAMLProviderInput, ...func(*iam.Options)) *iam.TagSAMLProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagSAMLProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagSAMLProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagServerCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagServerCertificate(ctx context.Context, params *iam.TagServerCertificateInput, optFns ...func(*iam.Options)) (*iam.TagServerCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagServerCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagServerCertificateInput, ...func(*iam.Options)) (*iam.TagServerCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagServerCertificateInput, ...func(*iam.Options)) *iam.TagServerCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagServerCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagServerCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) TagUser(ctx context.Context, params *iam.TagUserInput, optFns ...func(*iam.Options)) (*iam.TagUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.TagUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagUserInput, ...func(*iam.Options)) (*iam.TagUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.TagUserInput, ...func(*iam.Options)) *iam.TagUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.TagUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.TagUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagInstanceProfile(ctx context.Context, params *iam.UntagInstanceProfileInput, optFns ...func(*iam.Options)) (*iam.UntagInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagInstanceProfileInput, ...func(*iam.Options)) (*iam.UntagInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagInstanceProfileInput, ...func(*iam.Options)) *iam.UntagInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagInstanceProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagMFADevice provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagMFADevice(ctx context.Context, params *iam.UntagMFADeviceInput, optFns ...func(*iam.Options)) (*iam.UntagMFADeviceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagMFADeviceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagMFADeviceInput, ...func(*iam.Options)) (*iam.UntagMFADeviceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagMFADeviceInput, ...func(*iam.Options)) *iam.UntagMFADeviceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagMFADeviceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagMFADeviceInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagOpenIDConnectProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagOpenIDConnectProvider(ctx context.Context, params *iam.UntagOpenIDConnectProviderInput, optFns ...func(*iam.Options)) (*iam.UntagOpenIDConnectProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagOpenIDConnectProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagOpenIDConnectProviderInput, ...func(*iam.Options)) (*iam.UntagOpenIDConnectProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagOpenIDConnectProviderInput, ...func(*iam.Options)) *iam.UntagOpenIDConnectProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagOpenIDConnectProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagOpenIDConnectProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagPolicy(ctx context.Context, params *iam.UntagPolicyInput, optFns ...func(*iam.Options)) (*iam.UntagPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagPolicyInput, ...func(*iam.Options)) (*iam.UntagPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagPolicyInput, ...func(*iam.Options)) *iam.UntagPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagRole(ctx context.Context, params *iam.UntagRoleInput, optFns ...func(*iam.Options)) (*iam.UntagRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagRoleInput, ...func(*iam.Options)) (*iam.UntagRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagRoleInput, ...func(*iam.Options)) *iam.UntagRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagSAMLProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagSAMLProvider(ctx context.Context, params *iam.UntagSAMLProviderInput, optFns ...func(*iam.Options)) (*iam.UntagSAMLProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagSAMLProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagSAMLProviderInput, ...func(*iam.Options)) (*iam.UntagSAMLProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagSAMLProviderInput, ...func(*iam.Options)) *iam.UntagSAMLProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagSAMLProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagSAMLProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagServerCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagServerCertificate(ctx context.Context, params *iam.UntagServerCertificateInput, optFns ...func(*iam.Options)) (*iam.UntagServerCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagServerCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagServerCertificateInput, ...func(*iam.Options)) (*iam.UntagServerCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagServerCertificateInput, ...func(*iam.Options)) *iam.UntagServerCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagServerCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagServerCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UntagUser(ctx context.Context, params *iam.UntagUserInput, optFns ...func(*iam.Options)) (*iam.UntagUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UntagUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagUserInput, ...func(*iam.Options)) (*iam.UntagUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UntagUserInput, ...func(*iam.Options)) *iam.UntagUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UntagUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UntagUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccessKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateAccessKey(ctx context.Context, params *iam.UpdateAccessKeyInput, optFns ...func(*iam.Options)) (*iam.UpdateAccessKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateAccessKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateAccessKeyInput, ...func(*iam.Options)) (*iam.UpdateAccessKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateAccessKeyInput, ...func(*iam.Options)) *iam.UpdateAccessKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateAccessKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateAccessKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccountPasswordPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateAccountPasswordPolicy(ctx context.Context, params *iam.UpdateAccountPasswordPolicyInput, optFns ...func(*iam.Options)) (*iam.UpdateAccountPasswordPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateAccountPasswordPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateAccountPasswordPolicyInput, ...func(*iam.Options)) (*iam.UpdateAccountPasswordPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateAccountPasswordPolicyInput, ...func(*iam.Options)) *iam.UpdateAccountPasswordPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateAccountPasswordPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateAccountPasswordPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAssumeRolePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateAssumeRolePolicy(ctx context.Context, params *iam.UpdateAssumeRolePolicyInput, optFns ...func(*iam.Options)) (*iam.UpdateAssumeRolePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateAssumeRolePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateAssumeRolePolicyInput, ...func(*iam.Options)) (*iam.UpdateAssumeRolePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateAssumeRolePolicyInput, ...func(*iam.Options)) *iam.UpdateAssumeRolePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateAssumeRolePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateAssumeRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateGroup provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateGroup(ctx context.Context, params *iam.UpdateGroupInput, optFns ...func(*iam.Options)) (*iam.UpdateGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateGroupInput, ...func(*iam.Options)) (*iam.UpdateGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateGroupInput, ...func(*iam.Options)) *iam.UpdateGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateGroupInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateLoginProfile provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateLoginProfile(ctx context.Context, params *iam.UpdateLoginProfileInput, optFns ...func(*iam.Options)) (*iam.UpdateLoginProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateLoginProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateLoginProfileInput, ...func(*iam.Options)) (*iam.UpdateLoginProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateLoginProfileInput, ...func(*iam.Options)) *iam.UpdateLoginProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateLoginProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateLoginProfileInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateOpenIDConnectProviderThumbprint provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateOpenIDConnectProviderThumbprint(ctx context.Context, params *iam.UpdateOpenIDConnectProviderThumbprintInput, optFns ...func(*iam.Options)) (*iam.UpdateOpenIDConnectProviderThumbprintOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateOpenIDConnectProviderThumbprintOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateOpenIDConnectProviderThumbprintInput, ...func(*iam.Options)) (*iam.UpdateOpenIDConnectProviderThumbprintOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateOpenIDConnectProviderThumbprintInput, ...func(*iam.Options)) *iam.UpdateOpenIDConnectProviderThumbprintOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateOpenIDConnectProviderThumbprintOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateOpenIDConnectProviderThumbprintInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRole provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateRole(ctx context.Context, params *iam.UpdateRoleInput, optFns ...func(*iam.Options)) (*iam.UpdateRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateRoleInput, ...func(*iam.Options)) (*iam.UpdateRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateRoleInput, ...func(*iam.Options)) *iam.UpdateRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateRoleInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRoleDescription provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateRoleDescription(ctx context.Context, params *iam.UpdateRoleDescriptionInput, optFns ...func(*iam.Options)) (*iam.UpdateRoleDescriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateRoleDescriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateRoleDescriptionInput, ...func(*iam.Options)) (*iam.UpdateRoleDescriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateRoleDescriptionInput, ...func(*iam.Options)) *iam.UpdateRoleDescriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateRoleDescriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateRoleDescriptionInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSAMLProvider provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateSAMLProvider(ctx context.Context, params *iam.UpdateSAMLProviderInput, optFns ...func(*iam.Options)) (*iam.UpdateSAMLProviderOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateSAMLProviderOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateSAMLProviderInput, ...func(*iam.Options)) (*iam.UpdateSAMLProviderOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateSAMLProviderInput, ...func(*iam.Options)) *iam.UpdateSAMLProviderOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateSAMLProviderOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateSAMLProviderInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSSHPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateSSHPublicKey(ctx context.Context, params *iam.UpdateSSHPublicKeyInput, optFns ...func(*iam.Options)) (*iam.UpdateSSHPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateSSHPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateSSHPublicKeyInput, ...func(*iam.Options)) (*iam.UpdateSSHPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateSSHPublicKeyInput, ...func(*iam.Options)) *iam.UpdateSSHPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateSSHPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateSSHPublicKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateServerCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateServerCertificate(ctx context.Context, params *iam.UpdateServerCertificateInput, optFns ...func(*iam.Options)) (*iam.UpdateServerCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateServerCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateServerCertificateInput, ...func(*iam.Options)) (*iam.UpdateServerCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateServerCertificateInput, ...func(*iam.Options)) *iam.UpdateServerCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateServerCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateServerCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateServiceSpecificCredential provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateServiceSpecificCredential(ctx context.Context, params *iam.UpdateServiceSpecificCredentialInput, optFns ...func(*iam.Options)) (*iam.UpdateServiceSpecificCredentialOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateServiceSpecificCredentialOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateServiceSpecificCredentialInput, ...func(*iam.Options)) (*iam.UpdateServiceSpecificCredentialOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateServiceSpecificCredentialInput, ...func(*iam.Options)) *iam.UpdateServiceSpecificCredentialOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateServiceSpecificCredentialOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateServiceSpecificCredentialInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSigningCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateSigningCertificate(ctx context.Context, params *iam.UpdateSigningCertificateInput, optFns ...func(*iam.Options)) (*iam.UpdateSigningCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateSigningCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateSigningCertificateInput, ...func(*iam.Options)) (*iam.UpdateSigningCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateSigningCertificateInput, ...func(*iam.Options)) *iam.UpdateSigningCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateSigningCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateSigningCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUser provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UpdateUser(ctx context.Context, params *iam.UpdateUserInput, optFns ...func(*iam.Options)) (*iam.UpdateUserOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UpdateUserOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateUserInput, ...func(*iam.Options)) (*iam.UpdateUserOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UpdateUserInput, ...func(*iam.Options)) *iam.UpdateUserOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UpdateUserOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UpdateUserInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadSSHPublicKey provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UploadSSHPublicKey(ctx context.Context, params *iam.UploadSSHPublicKeyInput, optFns ...func(*iam.Options)) (*iam.UploadSSHPublicKeyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UploadSSHPublicKeyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UploadSSHPublicKeyInput, ...func(*iam.Options)) (*iam.UploadSSHPublicKeyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UploadSSHPublicKeyInput, ...func(*iam.Options)) *iam.UploadSSHPublicKeyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UploadSSHPublicKeyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UploadSSHPublicKeyInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadServerCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UploadServerCertificate(ctx context.Context, params *iam.UploadServerCertificateInput, optFns ...func(*iam.Options)) (*iam.UploadServerCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UploadServerCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UploadServerCertificateInput, ...func(*iam.Options)) (*iam.UploadServerCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UploadServerCertificateInput, ...func(*iam.Options)) *iam.UploadServerCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UploadServerCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UploadServerCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadSigningCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *IAM) UploadSigningCertificate(ctx context.Context, params *iam.UploadSigningCertificateInput, optFns ...func(*iam.Options)) (*iam.UploadSigningCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *iam.UploadSigningCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UploadSigningCertificateInput, ...func(*iam.Options)) (*iam.UploadSigningCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *iam.UploadSigningCertificateInput, ...func(*iam.Options)) *iam.UploadSigningCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.UploadSigningCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *iam.UploadSigningCertificateInput, ...func(*iam.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIAM creates a new instance of IAM. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIAM(t interface {
	mock.TestingT
	Cleanup(func())
}) *IAM {
	mock := &IAM{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
