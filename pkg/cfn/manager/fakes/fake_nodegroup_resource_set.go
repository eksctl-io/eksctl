// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/aws/aws-sdk-go-v2/service/cloudformation/types"
	"github.com/weaveworks/eksctl/pkg/cfn/manager"
)

type FakeNodeGroupResourceSet struct {
	AddAllResourcesStub        func(context.Context) error
	addAllResourcesMutex       sync.RWMutex
	addAllResourcesArgsForCall []struct {
		arg1 context.Context
	}
	addAllResourcesReturns struct {
		result1 error
	}
	addAllResourcesReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllOutputsStub        func(types.Stack) error
	getAllOutputsMutex       sync.RWMutex
	getAllOutputsArgsForCall []struct {
		arg1 types.Stack
	}
	getAllOutputsReturns struct {
		result1 error
	}
	getAllOutputsReturnsOnCall map[int]struct {
		result1 error
	}
	RenderJSONStub        func() ([]byte, error)
	renderJSONMutex       sync.RWMutex
	renderJSONArgsForCall []struct {
	}
	renderJSONReturns struct {
		result1 []byte
		result2 error
	}
	renderJSONReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	WithIAMStub        func() bool
	withIAMMutex       sync.RWMutex
	withIAMArgsForCall []struct {
	}
	withIAMReturns struct {
		result1 bool
	}
	withIAMReturnsOnCall map[int]struct {
		result1 bool
	}
	WithNamedIAMStub        func() bool
	withNamedIAMMutex       sync.RWMutex
	withNamedIAMArgsForCall []struct {
	}
	withNamedIAMReturns struct {
		result1 bool
	}
	withNamedIAMReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeGroupResourceSet) AddAllResources(arg1 context.Context) error {
	fake.addAllResourcesMutex.Lock()
	ret, specificReturn := fake.addAllResourcesReturnsOnCall[len(fake.addAllResourcesArgsForCall)]
	fake.addAllResourcesArgsForCall = append(fake.addAllResourcesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.AddAllResourcesStub
	fakeReturns := fake.addAllResourcesReturns
	fake.recordInvocation("AddAllResources", []interface{}{arg1})
	fake.addAllResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeGroupResourceSet) AddAllResourcesCallCount() int {
	fake.addAllResourcesMutex.RLock()
	defer fake.addAllResourcesMutex.RUnlock()
	return len(fake.addAllResourcesArgsForCall)
}

func (fake *FakeNodeGroupResourceSet) AddAllResourcesCalls(stub func(context.Context) error) {
	fake.addAllResourcesMutex.Lock()
	defer fake.addAllResourcesMutex.Unlock()
	fake.AddAllResourcesStub = stub
}

func (fake *FakeNodeGroupResourceSet) AddAllResourcesArgsForCall(i int) context.Context {
	fake.addAllResourcesMutex.RLock()
	defer fake.addAllResourcesMutex.RUnlock()
	argsForCall := fake.addAllResourcesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeGroupResourceSet) AddAllResourcesReturns(result1 error) {
	fake.addAllResourcesMutex.Lock()
	defer fake.addAllResourcesMutex.Unlock()
	fake.AddAllResourcesStub = nil
	fake.addAllResourcesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) AddAllResourcesReturnsOnCall(i int, result1 error) {
	fake.addAllResourcesMutex.Lock()
	defer fake.addAllResourcesMutex.Unlock()
	fake.AddAllResourcesStub = nil
	if fake.addAllResourcesReturnsOnCall == nil {
		fake.addAllResourcesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addAllResourcesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) GetAllOutputs(arg1 types.Stack) error {
	fake.getAllOutputsMutex.Lock()
	ret, specificReturn := fake.getAllOutputsReturnsOnCall[len(fake.getAllOutputsArgsForCall)]
	fake.getAllOutputsArgsForCall = append(fake.getAllOutputsArgsForCall, struct {
		arg1 types.Stack
	}{arg1})
	stub := fake.GetAllOutputsStub
	fakeReturns := fake.getAllOutputsReturns
	fake.recordInvocation("GetAllOutputs", []interface{}{arg1})
	fake.getAllOutputsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeGroupResourceSet) GetAllOutputsCallCount() int {
	fake.getAllOutputsMutex.RLock()
	defer fake.getAllOutputsMutex.RUnlock()
	return len(fake.getAllOutputsArgsForCall)
}

func (fake *FakeNodeGroupResourceSet) GetAllOutputsCalls(stub func(types.Stack) error) {
	fake.getAllOutputsMutex.Lock()
	defer fake.getAllOutputsMutex.Unlock()
	fake.GetAllOutputsStub = stub
}

func (fake *FakeNodeGroupResourceSet) GetAllOutputsArgsForCall(i int) types.Stack {
	fake.getAllOutputsMutex.RLock()
	defer fake.getAllOutputsMutex.RUnlock()
	argsForCall := fake.getAllOutputsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeGroupResourceSet) GetAllOutputsReturns(result1 error) {
	fake.getAllOutputsMutex.Lock()
	defer fake.getAllOutputsMutex.Unlock()
	fake.GetAllOutputsStub = nil
	fake.getAllOutputsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) GetAllOutputsReturnsOnCall(i int, result1 error) {
	fake.getAllOutputsMutex.Lock()
	defer fake.getAllOutputsMutex.Unlock()
	fake.GetAllOutputsStub = nil
	if fake.getAllOutputsReturnsOnCall == nil {
		fake.getAllOutputsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getAllOutputsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) RenderJSON() ([]byte, error) {
	fake.renderJSONMutex.Lock()
	ret, specificReturn := fake.renderJSONReturnsOnCall[len(fake.renderJSONArgsForCall)]
	fake.renderJSONArgsForCall = append(fake.renderJSONArgsForCall, struct {
	}{})
	stub := fake.RenderJSONStub
	fakeReturns := fake.renderJSONReturns
	fake.recordInvocation("RenderJSON", []interface{}{})
	fake.renderJSONMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeGroupResourceSet) RenderJSONCallCount() int {
	fake.renderJSONMutex.RLock()
	defer fake.renderJSONMutex.RUnlock()
	return len(fake.renderJSONArgsForCall)
}

func (fake *FakeNodeGroupResourceSet) RenderJSONCalls(stub func() ([]byte, error)) {
	fake.renderJSONMutex.Lock()
	defer fake.renderJSONMutex.Unlock()
	fake.RenderJSONStub = stub
}

func (fake *FakeNodeGroupResourceSet) RenderJSONReturns(result1 []byte, result2 error) {
	fake.renderJSONMutex.Lock()
	defer fake.renderJSONMutex.Unlock()
	fake.RenderJSONStub = nil
	fake.renderJSONReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeGroupResourceSet) RenderJSONReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.renderJSONMutex.Lock()
	defer fake.renderJSONMutex.Unlock()
	fake.RenderJSONStub = nil
	if fake.renderJSONReturnsOnCall == nil {
		fake.renderJSONReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.renderJSONReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeGroupResourceSet) WithIAM() bool {
	fake.withIAMMutex.Lock()
	ret, specificReturn := fake.withIAMReturnsOnCall[len(fake.withIAMArgsForCall)]
	fake.withIAMArgsForCall = append(fake.withIAMArgsForCall, struct {
	}{})
	stub := fake.WithIAMStub
	fakeReturns := fake.withIAMReturns
	fake.recordInvocation("WithIAM", []interface{}{})
	fake.withIAMMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeGroupResourceSet) WithIAMCallCount() int {
	fake.withIAMMutex.RLock()
	defer fake.withIAMMutex.RUnlock()
	return len(fake.withIAMArgsForCall)
}

func (fake *FakeNodeGroupResourceSet) WithIAMCalls(stub func() bool) {
	fake.withIAMMutex.Lock()
	defer fake.withIAMMutex.Unlock()
	fake.WithIAMStub = stub
}

func (fake *FakeNodeGroupResourceSet) WithIAMReturns(result1 bool) {
	fake.withIAMMutex.Lock()
	defer fake.withIAMMutex.Unlock()
	fake.WithIAMStub = nil
	fake.withIAMReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) WithIAMReturnsOnCall(i int, result1 bool) {
	fake.withIAMMutex.Lock()
	defer fake.withIAMMutex.Unlock()
	fake.WithIAMStub = nil
	if fake.withIAMReturnsOnCall == nil {
		fake.withIAMReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.withIAMReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) WithNamedIAM() bool {
	fake.withNamedIAMMutex.Lock()
	ret, specificReturn := fake.withNamedIAMReturnsOnCall[len(fake.withNamedIAMArgsForCall)]
	fake.withNamedIAMArgsForCall = append(fake.withNamedIAMArgsForCall, struct {
	}{})
	stub := fake.WithNamedIAMStub
	fakeReturns := fake.withNamedIAMReturns
	fake.recordInvocation("WithNamedIAM", []interface{}{})
	fake.withNamedIAMMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeGroupResourceSet) WithNamedIAMCallCount() int {
	fake.withNamedIAMMutex.RLock()
	defer fake.withNamedIAMMutex.RUnlock()
	return len(fake.withNamedIAMArgsForCall)
}

func (fake *FakeNodeGroupResourceSet) WithNamedIAMCalls(stub func() bool) {
	fake.withNamedIAMMutex.Lock()
	defer fake.withNamedIAMMutex.Unlock()
	fake.WithNamedIAMStub = stub
}

func (fake *FakeNodeGroupResourceSet) WithNamedIAMReturns(result1 bool) {
	fake.withNamedIAMMutex.Lock()
	defer fake.withNamedIAMMutex.Unlock()
	fake.WithNamedIAMStub = nil
	fake.withNamedIAMReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) WithNamedIAMReturnsOnCall(i int, result1 bool) {
	fake.withNamedIAMMutex.Lock()
	defer fake.withNamedIAMMutex.Unlock()
	fake.WithNamedIAMStub = nil
	if fake.withNamedIAMReturnsOnCall == nil {
		fake.withNamedIAMReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.withNamedIAMReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeNodeGroupResourceSet) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addAllResourcesMutex.RLock()
	defer fake.addAllResourcesMutex.RUnlock()
	fake.getAllOutputsMutex.RLock()
	defer fake.getAllOutputsMutex.RUnlock()
	fake.renderJSONMutex.RLock()
	defer fake.renderJSONMutex.RUnlock()
	fake.withIAMMutex.RLock()
	defer fake.withIAMMutex.RUnlock()
	fake.withNamedIAMMutex.RLock()
	defer fake.withNamedIAMMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeGroupResourceSet) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ manager.NodeGroupResourceSet = new(FakeNodeGroupResourceSet)
