// Code generated by mockery v2.35.3. DO NOT EDIT.

package mocksv2

import (
	autoscaling "github.com/aws/aws-sdk-go-v2/service/autoscaling"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// ASG is an autogenerated mock type for the ASG type
type ASG struct {
	mock.Mock
}

// AttachInstances provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) AttachInstances(ctx context.Context, params *autoscaling.AttachInstancesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.AttachInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.AttachInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachInstancesInput, ...func(*autoscaling.Options)) (*autoscaling.AttachInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachInstancesInput, ...func(*autoscaling.Options)) *autoscaling.AttachInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.AttachInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.AttachInstancesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachLoadBalancerTargetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) AttachLoadBalancerTargetGroups(ctx context.Context, params *autoscaling.AttachLoadBalancerTargetGroupsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.AttachLoadBalancerTargetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.AttachLoadBalancerTargetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) (*autoscaling.AttachLoadBalancerTargetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) *autoscaling.AttachLoadBalancerTargetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.AttachLoadBalancerTargetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.AttachLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) AttachLoadBalancers(ctx context.Context, params *autoscaling.AttachLoadBalancersInput, optFns ...func(*autoscaling.Options)) (*autoscaling.AttachLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.AttachLoadBalancersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachLoadBalancersInput, ...func(*autoscaling.Options)) (*autoscaling.AttachLoadBalancersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachLoadBalancersInput, ...func(*autoscaling.Options)) *autoscaling.AttachLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.AttachLoadBalancersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.AttachLoadBalancersInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachTrafficSources provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) AttachTrafficSources(ctx context.Context, params *autoscaling.AttachTrafficSourcesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.AttachTrafficSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.AttachTrafficSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachTrafficSourcesInput, ...func(*autoscaling.Options)) (*autoscaling.AttachTrafficSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.AttachTrafficSourcesInput, ...func(*autoscaling.Options)) *autoscaling.AttachTrafficSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.AttachTrafficSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.AttachTrafficSourcesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteScheduledAction provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) BatchDeleteScheduledAction(ctx context.Context, params *autoscaling.BatchDeleteScheduledActionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.BatchDeleteScheduledActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.BatchDeleteScheduledActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.BatchDeleteScheduledActionInput, ...func(*autoscaling.Options)) (*autoscaling.BatchDeleteScheduledActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.BatchDeleteScheduledActionInput, ...func(*autoscaling.Options)) *autoscaling.BatchDeleteScheduledActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.BatchDeleteScheduledActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.BatchDeleteScheduledActionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchPutScheduledUpdateGroupAction provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) BatchPutScheduledUpdateGroupAction(ctx context.Context, params *autoscaling.BatchPutScheduledUpdateGroupActionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.BatchPutScheduledUpdateGroupActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.BatchPutScheduledUpdateGroupActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.BatchPutScheduledUpdateGroupActionInput, ...func(*autoscaling.Options)) (*autoscaling.BatchPutScheduledUpdateGroupActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.BatchPutScheduledUpdateGroupActionInput, ...func(*autoscaling.Options)) *autoscaling.BatchPutScheduledUpdateGroupActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.BatchPutScheduledUpdateGroupActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.BatchPutScheduledUpdateGroupActionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelInstanceRefresh provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) CancelInstanceRefresh(ctx context.Context, params *autoscaling.CancelInstanceRefreshInput, optFns ...func(*autoscaling.Options)) (*autoscaling.CancelInstanceRefreshOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.CancelInstanceRefreshOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CancelInstanceRefreshInput, ...func(*autoscaling.Options)) (*autoscaling.CancelInstanceRefreshOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CancelInstanceRefreshInput, ...func(*autoscaling.Options)) *autoscaling.CancelInstanceRefreshOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.CancelInstanceRefreshOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.CancelInstanceRefreshInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CompleteLifecycleAction provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) CompleteLifecycleAction(ctx context.Context, params *autoscaling.CompleteLifecycleActionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.CompleteLifecycleActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.CompleteLifecycleActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CompleteLifecycleActionInput, ...func(*autoscaling.Options)) (*autoscaling.CompleteLifecycleActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CompleteLifecycleActionInput, ...func(*autoscaling.Options)) *autoscaling.CompleteLifecycleActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.CompleteLifecycleActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.CompleteLifecycleActionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAutoScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) CreateAutoScalingGroup(ctx context.Context, params *autoscaling.CreateAutoScalingGroupInput, optFns ...func(*autoscaling.Options)) (*autoscaling.CreateAutoScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.CreateAutoScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CreateAutoScalingGroupInput, ...func(*autoscaling.Options)) (*autoscaling.CreateAutoScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CreateAutoScalingGroupInput, ...func(*autoscaling.Options)) *autoscaling.CreateAutoScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.CreateAutoScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.CreateAutoScalingGroupInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) CreateLaunchConfiguration(ctx context.Context, params *autoscaling.CreateLaunchConfigurationInput, optFns ...func(*autoscaling.Options)) (*autoscaling.CreateLaunchConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.CreateLaunchConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CreateLaunchConfigurationInput, ...func(*autoscaling.Options)) (*autoscaling.CreateLaunchConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CreateLaunchConfigurationInput, ...func(*autoscaling.Options)) *autoscaling.CreateLaunchConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.CreateLaunchConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.CreateLaunchConfigurationInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOrUpdateTags provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) CreateOrUpdateTags(ctx context.Context, params *autoscaling.CreateOrUpdateTagsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.CreateOrUpdateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.CreateOrUpdateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CreateOrUpdateTagsInput, ...func(*autoscaling.Options)) (*autoscaling.CreateOrUpdateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.CreateOrUpdateTagsInput, ...func(*autoscaling.Options)) *autoscaling.CreateOrUpdateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.CreateOrUpdateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.CreateOrUpdateTagsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAutoScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteAutoScalingGroup(ctx context.Context, params *autoscaling.DeleteAutoScalingGroupInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteAutoScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteAutoScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteAutoScalingGroupInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteAutoScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteAutoScalingGroupInput, ...func(*autoscaling.Options)) *autoscaling.DeleteAutoScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteAutoScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteAutoScalingGroupInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteLaunchConfiguration(ctx context.Context, params *autoscaling.DeleteLaunchConfigurationInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteLaunchConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteLaunchConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteLaunchConfigurationInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteLaunchConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteLaunchConfigurationInput, ...func(*autoscaling.Options)) *autoscaling.DeleteLaunchConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteLaunchConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteLaunchConfigurationInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLifecycleHook provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteLifecycleHook(ctx context.Context, params *autoscaling.DeleteLifecycleHookInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteLifecycleHookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteLifecycleHookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteLifecycleHookInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteLifecycleHookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteLifecycleHookInput, ...func(*autoscaling.Options)) *autoscaling.DeleteLifecycleHookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteLifecycleHookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteLifecycleHookInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNotificationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteNotificationConfiguration(ctx context.Context, params *autoscaling.DeleteNotificationConfigurationInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteNotificationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteNotificationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteNotificationConfigurationInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteNotificationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteNotificationConfigurationInput, ...func(*autoscaling.Options)) *autoscaling.DeleteNotificationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteNotificationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteNotificationConfigurationInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeletePolicy(ctx context.Context, params *autoscaling.DeletePolicyInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeletePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeletePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeletePolicyInput, ...func(*autoscaling.Options)) (*autoscaling.DeletePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeletePolicyInput, ...func(*autoscaling.Options)) *autoscaling.DeletePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeletePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeletePolicyInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteScheduledAction provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteScheduledAction(ctx context.Context, params *autoscaling.DeleteScheduledActionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteScheduledActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteScheduledActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteScheduledActionInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteScheduledActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteScheduledActionInput, ...func(*autoscaling.Options)) *autoscaling.DeleteScheduledActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteScheduledActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteScheduledActionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteTags(ctx context.Context, params *autoscaling.DeleteTagsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteTagsInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteTagsInput, ...func(*autoscaling.Options)) *autoscaling.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteTagsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWarmPool provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DeleteWarmPool(ctx context.Context, params *autoscaling.DeleteWarmPoolInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DeleteWarmPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DeleteWarmPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteWarmPoolInput, ...func(*autoscaling.Options)) (*autoscaling.DeleteWarmPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DeleteWarmPoolInput, ...func(*autoscaling.Options)) *autoscaling.DeleteWarmPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DeleteWarmPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DeleteWarmPoolInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountLimits provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeAccountLimits(ctx context.Context, params *autoscaling.DescribeAccountLimitsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeAccountLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeAccountLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAccountLimitsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeAccountLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAccountLimitsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeAccountLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeAccountLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeAccountLimitsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAdjustmentTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeAdjustmentTypes(ctx context.Context, params *autoscaling.DescribeAdjustmentTypesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeAdjustmentTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeAdjustmentTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAdjustmentTypesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeAdjustmentTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAdjustmentTypesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeAdjustmentTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeAdjustmentTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeAdjustmentTypesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAutoScalingGroups provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeAutoScalingGroups(ctx context.Context, params *autoscaling.DescribeAutoScalingGroupsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeAutoScalingGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeAutoScalingGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAutoScalingGroupsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeAutoScalingGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAutoScalingGroupsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeAutoScalingGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeAutoScalingGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeAutoScalingGroupsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAutoScalingInstances provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeAutoScalingInstances(ctx context.Context, params *autoscaling.DescribeAutoScalingInstancesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeAutoScalingInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeAutoScalingInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAutoScalingInstancesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeAutoScalingInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAutoScalingInstancesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeAutoScalingInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeAutoScalingInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeAutoScalingInstancesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAutoScalingNotificationTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeAutoScalingNotificationTypes(ctx context.Context, params *autoscaling.DescribeAutoScalingNotificationTypesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeAutoScalingNotificationTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeAutoScalingNotificationTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAutoScalingNotificationTypesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeAutoScalingNotificationTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeAutoScalingNotificationTypesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeAutoScalingNotificationTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeAutoScalingNotificationTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeAutoScalingNotificationTypesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceRefreshes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeInstanceRefreshes(ctx context.Context, params *autoscaling.DescribeInstanceRefreshesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeInstanceRefreshesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeInstanceRefreshesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeInstanceRefreshesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeInstanceRefreshesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeInstanceRefreshesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeInstanceRefreshesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeInstanceRefreshesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeInstanceRefreshesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeLaunchConfigurations(ctx context.Context, params *autoscaling.DescribeLaunchConfigurationsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeLaunchConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeLaunchConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLaunchConfigurationsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeLaunchConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLaunchConfigurationsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeLaunchConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeLaunchConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeLaunchConfigurationsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLifecycleHookTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeLifecycleHookTypes(ctx context.Context, params *autoscaling.DescribeLifecycleHookTypesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeLifecycleHookTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeLifecycleHookTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLifecycleHookTypesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeLifecycleHookTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLifecycleHookTypesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeLifecycleHookTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeLifecycleHookTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeLifecycleHookTypesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLifecycleHooks provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeLifecycleHooks(ctx context.Context, params *autoscaling.DescribeLifecycleHooksInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeLifecycleHooksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeLifecycleHooksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLifecycleHooksInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeLifecycleHooksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLifecycleHooksInput, ...func(*autoscaling.Options)) *autoscaling.DescribeLifecycleHooksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeLifecycleHooksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeLifecycleHooksInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancerTargetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeLoadBalancerTargetGroups(ctx context.Context, params *autoscaling.DescribeLoadBalancerTargetGroupsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeLoadBalancerTargetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeLoadBalancerTargetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeLoadBalancerTargetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeLoadBalancerTargetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeLoadBalancerTargetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeLoadBalancers(ctx context.Context, params *autoscaling.DescribeLoadBalancersInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeLoadBalancersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLoadBalancersInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeLoadBalancersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeLoadBalancersInput, ...func(*autoscaling.Options)) *autoscaling.DescribeLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeLoadBalancersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeLoadBalancersInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMetricCollectionTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeMetricCollectionTypes(ctx context.Context, params *autoscaling.DescribeMetricCollectionTypesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeMetricCollectionTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeMetricCollectionTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeMetricCollectionTypesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeMetricCollectionTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeMetricCollectionTypesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeMetricCollectionTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeMetricCollectionTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeMetricCollectionTypesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNotificationConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeNotificationConfigurations(ctx context.Context, params *autoscaling.DescribeNotificationConfigurationsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeNotificationConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeNotificationConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeNotificationConfigurationsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeNotificationConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeNotificationConfigurationsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeNotificationConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeNotificationConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeNotificationConfigurationsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePolicies provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribePolicies(ctx context.Context, params *autoscaling.DescribePoliciesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribePoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribePoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribePoliciesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribePoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribePoliciesInput, ...func(*autoscaling.Options)) *autoscaling.DescribePoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribePoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribePoliciesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScalingActivities provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeScalingActivities(ctx context.Context, params *autoscaling.DescribeScalingActivitiesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeScalingActivitiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeScalingActivitiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeScalingActivitiesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeScalingActivitiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeScalingActivitiesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeScalingActivitiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeScalingActivitiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeScalingActivitiesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScalingProcessTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeScalingProcessTypes(ctx context.Context, params *autoscaling.DescribeScalingProcessTypesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeScalingProcessTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeScalingProcessTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeScalingProcessTypesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeScalingProcessTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeScalingProcessTypesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeScalingProcessTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeScalingProcessTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeScalingProcessTypesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledActions provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeScheduledActions(ctx context.Context, params *autoscaling.DescribeScheduledActionsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeScheduledActionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeScheduledActionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeScheduledActionsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeScheduledActionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeScheduledActionsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeScheduledActionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeScheduledActionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeScheduledActionsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeTags(ctx context.Context, params *autoscaling.DescribeTagsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeTagsInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeTagsInput, ...func(*autoscaling.Options)) *autoscaling.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeTagsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTerminationPolicyTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeTerminationPolicyTypes(ctx context.Context, params *autoscaling.DescribeTerminationPolicyTypesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeTerminationPolicyTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeTerminationPolicyTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeTerminationPolicyTypesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeTerminationPolicyTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeTerminationPolicyTypesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeTerminationPolicyTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeTerminationPolicyTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeTerminationPolicyTypesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficSources provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeTrafficSources(ctx context.Context, params *autoscaling.DescribeTrafficSourcesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeTrafficSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeTrafficSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeTrafficSourcesInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeTrafficSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeTrafficSourcesInput, ...func(*autoscaling.Options)) *autoscaling.DescribeTrafficSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeTrafficSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeTrafficSourcesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWarmPool provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DescribeWarmPool(ctx context.Context, params *autoscaling.DescribeWarmPoolInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DescribeWarmPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DescribeWarmPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeWarmPoolInput, ...func(*autoscaling.Options)) (*autoscaling.DescribeWarmPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DescribeWarmPoolInput, ...func(*autoscaling.Options)) *autoscaling.DescribeWarmPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DescribeWarmPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DescribeWarmPoolInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachInstances provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DetachInstances(ctx context.Context, params *autoscaling.DetachInstancesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DetachInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DetachInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachInstancesInput, ...func(*autoscaling.Options)) (*autoscaling.DetachInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachInstancesInput, ...func(*autoscaling.Options)) *autoscaling.DetachInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DetachInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DetachInstancesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachLoadBalancerTargetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DetachLoadBalancerTargetGroups(ctx context.Context, params *autoscaling.DetachLoadBalancerTargetGroupsInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DetachLoadBalancerTargetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DetachLoadBalancerTargetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) (*autoscaling.DetachLoadBalancerTargetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) *autoscaling.DetachLoadBalancerTargetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DetachLoadBalancerTargetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DetachLoadBalancerTargetGroupsInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DetachLoadBalancers(ctx context.Context, params *autoscaling.DetachLoadBalancersInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DetachLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DetachLoadBalancersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachLoadBalancersInput, ...func(*autoscaling.Options)) (*autoscaling.DetachLoadBalancersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachLoadBalancersInput, ...func(*autoscaling.Options)) *autoscaling.DetachLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DetachLoadBalancersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DetachLoadBalancersInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachTrafficSources provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DetachTrafficSources(ctx context.Context, params *autoscaling.DetachTrafficSourcesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DetachTrafficSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DetachTrafficSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachTrafficSourcesInput, ...func(*autoscaling.Options)) (*autoscaling.DetachTrafficSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DetachTrafficSourcesInput, ...func(*autoscaling.Options)) *autoscaling.DetachTrafficSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DetachTrafficSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DetachTrafficSourcesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableMetricsCollection provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) DisableMetricsCollection(ctx context.Context, params *autoscaling.DisableMetricsCollectionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.DisableMetricsCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.DisableMetricsCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DisableMetricsCollectionInput, ...func(*autoscaling.Options)) (*autoscaling.DisableMetricsCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.DisableMetricsCollectionInput, ...func(*autoscaling.Options)) *autoscaling.DisableMetricsCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.DisableMetricsCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.DisableMetricsCollectionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableMetricsCollection provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) EnableMetricsCollection(ctx context.Context, params *autoscaling.EnableMetricsCollectionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.EnableMetricsCollectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.EnableMetricsCollectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.EnableMetricsCollectionInput, ...func(*autoscaling.Options)) (*autoscaling.EnableMetricsCollectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.EnableMetricsCollectionInput, ...func(*autoscaling.Options)) *autoscaling.EnableMetricsCollectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.EnableMetricsCollectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.EnableMetricsCollectionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnterStandby provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) EnterStandby(ctx context.Context, params *autoscaling.EnterStandbyInput, optFns ...func(*autoscaling.Options)) (*autoscaling.EnterStandbyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.EnterStandbyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.EnterStandbyInput, ...func(*autoscaling.Options)) (*autoscaling.EnterStandbyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.EnterStandbyInput, ...func(*autoscaling.Options)) *autoscaling.EnterStandbyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.EnterStandbyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.EnterStandbyInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutePolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) ExecutePolicy(ctx context.Context, params *autoscaling.ExecutePolicyInput, optFns ...func(*autoscaling.Options)) (*autoscaling.ExecutePolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.ExecutePolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.ExecutePolicyInput, ...func(*autoscaling.Options)) (*autoscaling.ExecutePolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.ExecutePolicyInput, ...func(*autoscaling.Options)) *autoscaling.ExecutePolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.ExecutePolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.ExecutePolicyInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExitStandby provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) ExitStandby(ctx context.Context, params *autoscaling.ExitStandbyInput, optFns ...func(*autoscaling.Options)) (*autoscaling.ExitStandbyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.ExitStandbyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.ExitStandbyInput, ...func(*autoscaling.Options)) (*autoscaling.ExitStandbyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.ExitStandbyInput, ...func(*autoscaling.Options)) *autoscaling.ExitStandbyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.ExitStandbyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.ExitStandbyInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPredictiveScalingForecast provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) GetPredictiveScalingForecast(ctx context.Context, params *autoscaling.GetPredictiveScalingForecastInput, optFns ...func(*autoscaling.Options)) (*autoscaling.GetPredictiveScalingForecastOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.GetPredictiveScalingForecastOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.GetPredictiveScalingForecastInput, ...func(*autoscaling.Options)) (*autoscaling.GetPredictiveScalingForecastOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.GetPredictiveScalingForecastInput, ...func(*autoscaling.Options)) *autoscaling.GetPredictiveScalingForecastOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.GetPredictiveScalingForecastOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.GetPredictiveScalingForecastInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutLifecycleHook provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) PutLifecycleHook(ctx context.Context, params *autoscaling.PutLifecycleHookInput, optFns ...func(*autoscaling.Options)) (*autoscaling.PutLifecycleHookOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.PutLifecycleHookOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutLifecycleHookInput, ...func(*autoscaling.Options)) (*autoscaling.PutLifecycleHookOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutLifecycleHookInput, ...func(*autoscaling.Options)) *autoscaling.PutLifecycleHookOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.PutLifecycleHookOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.PutLifecycleHookInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutNotificationConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) PutNotificationConfiguration(ctx context.Context, params *autoscaling.PutNotificationConfigurationInput, optFns ...func(*autoscaling.Options)) (*autoscaling.PutNotificationConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.PutNotificationConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutNotificationConfigurationInput, ...func(*autoscaling.Options)) (*autoscaling.PutNotificationConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutNotificationConfigurationInput, ...func(*autoscaling.Options)) *autoscaling.PutNotificationConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.PutNotificationConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.PutNotificationConfigurationInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutScalingPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) PutScalingPolicy(ctx context.Context, params *autoscaling.PutScalingPolicyInput, optFns ...func(*autoscaling.Options)) (*autoscaling.PutScalingPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.PutScalingPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutScalingPolicyInput, ...func(*autoscaling.Options)) (*autoscaling.PutScalingPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutScalingPolicyInput, ...func(*autoscaling.Options)) *autoscaling.PutScalingPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.PutScalingPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.PutScalingPolicyInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutScheduledUpdateGroupAction provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) PutScheduledUpdateGroupAction(ctx context.Context, params *autoscaling.PutScheduledUpdateGroupActionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.PutScheduledUpdateGroupActionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.PutScheduledUpdateGroupActionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutScheduledUpdateGroupActionInput, ...func(*autoscaling.Options)) (*autoscaling.PutScheduledUpdateGroupActionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutScheduledUpdateGroupActionInput, ...func(*autoscaling.Options)) *autoscaling.PutScheduledUpdateGroupActionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.PutScheduledUpdateGroupActionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.PutScheduledUpdateGroupActionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutWarmPool provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) PutWarmPool(ctx context.Context, params *autoscaling.PutWarmPoolInput, optFns ...func(*autoscaling.Options)) (*autoscaling.PutWarmPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.PutWarmPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutWarmPoolInput, ...func(*autoscaling.Options)) (*autoscaling.PutWarmPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.PutWarmPoolInput, ...func(*autoscaling.Options)) *autoscaling.PutWarmPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.PutWarmPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.PutWarmPoolInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecordLifecycleActionHeartbeat provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) RecordLifecycleActionHeartbeat(ctx context.Context, params *autoscaling.RecordLifecycleActionHeartbeatInput, optFns ...func(*autoscaling.Options)) (*autoscaling.RecordLifecycleActionHeartbeatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.RecordLifecycleActionHeartbeatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.RecordLifecycleActionHeartbeatInput, ...func(*autoscaling.Options)) (*autoscaling.RecordLifecycleActionHeartbeatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.RecordLifecycleActionHeartbeatInput, ...func(*autoscaling.Options)) *autoscaling.RecordLifecycleActionHeartbeatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.RecordLifecycleActionHeartbeatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.RecordLifecycleActionHeartbeatInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResumeProcesses provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) ResumeProcesses(ctx context.Context, params *autoscaling.ResumeProcessesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.ResumeProcessesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.ResumeProcessesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.ResumeProcessesInput, ...func(*autoscaling.Options)) (*autoscaling.ResumeProcessesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.ResumeProcessesInput, ...func(*autoscaling.Options)) *autoscaling.ResumeProcessesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.ResumeProcessesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.ResumeProcessesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RollbackInstanceRefresh provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) RollbackInstanceRefresh(ctx context.Context, params *autoscaling.RollbackInstanceRefreshInput, optFns ...func(*autoscaling.Options)) (*autoscaling.RollbackInstanceRefreshOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.RollbackInstanceRefreshOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.RollbackInstanceRefreshInput, ...func(*autoscaling.Options)) (*autoscaling.RollbackInstanceRefreshOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.RollbackInstanceRefreshInput, ...func(*autoscaling.Options)) *autoscaling.RollbackInstanceRefreshOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.RollbackInstanceRefreshOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.RollbackInstanceRefreshInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetDesiredCapacity provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) SetDesiredCapacity(ctx context.Context, params *autoscaling.SetDesiredCapacityInput, optFns ...func(*autoscaling.Options)) (*autoscaling.SetDesiredCapacityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.SetDesiredCapacityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SetDesiredCapacityInput, ...func(*autoscaling.Options)) (*autoscaling.SetDesiredCapacityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SetDesiredCapacityInput, ...func(*autoscaling.Options)) *autoscaling.SetDesiredCapacityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.SetDesiredCapacityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.SetDesiredCapacityInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetInstanceHealth provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) SetInstanceHealth(ctx context.Context, params *autoscaling.SetInstanceHealthInput, optFns ...func(*autoscaling.Options)) (*autoscaling.SetInstanceHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.SetInstanceHealthOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SetInstanceHealthInput, ...func(*autoscaling.Options)) (*autoscaling.SetInstanceHealthOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SetInstanceHealthInput, ...func(*autoscaling.Options)) *autoscaling.SetInstanceHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.SetInstanceHealthOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.SetInstanceHealthInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetInstanceProtection provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) SetInstanceProtection(ctx context.Context, params *autoscaling.SetInstanceProtectionInput, optFns ...func(*autoscaling.Options)) (*autoscaling.SetInstanceProtectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.SetInstanceProtectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SetInstanceProtectionInput, ...func(*autoscaling.Options)) (*autoscaling.SetInstanceProtectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SetInstanceProtectionInput, ...func(*autoscaling.Options)) *autoscaling.SetInstanceProtectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.SetInstanceProtectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.SetInstanceProtectionInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartInstanceRefresh provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) StartInstanceRefresh(ctx context.Context, params *autoscaling.StartInstanceRefreshInput, optFns ...func(*autoscaling.Options)) (*autoscaling.StartInstanceRefreshOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.StartInstanceRefreshOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.StartInstanceRefreshInput, ...func(*autoscaling.Options)) (*autoscaling.StartInstanceRefreshOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.StartInstanceRefreshInput, ...func(*autoscaling.Options)) *autoscaling.StartInstanceRefreshOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.StartInstanceRefreshOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.StartInstanceRefreshInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuspendProcesses provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) SuspendProcesses(ctx context.Context, params *autoscaling.SuspendProcessesInput, optFns ...func(*autoscaling.Options)) (*autoscaling.SuspendProcessesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.SuspendProcessesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SuspendProcessesInput, ...func(*autoscaling.Options)) (*autoscaling.SuspendProcessesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.SuspendProcessesInput, ...func(*autoscaling.Options)) *autoscaling.SuspendProcessesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.SuspendProcessesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.SuspendProcessesInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateInstanceInAutoScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) TerminateInstanceInAutoScalingGroup(ctx context.Context, params *autoscaling.TerminateInstanceInAutoScalingGroupInput, optFns ...func(*autoscaling.Options)) (*autoscaling.TerminateInstanceInAutoScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.TerminateInstanceInAutoScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.TerminateInstanceInAutoScalingGroupInput, ...func(*autoscaling.Options)) (*autoscaling.TerminateInstanceInAutoScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.TerminateInstanceInAutoScalingGroupInput, ...func(*autoscaling.Options)) *autoscaling.TerminateInstanceInAutoScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.TerminateInstanceInAutoScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.TerminateInstanceInAutoScalingGroupInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAutoScalingGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ASG) UpdateAutoScalingGroup(ctx context.Context, params *autoscaling.UpdateAutoScalingGroupInput, optFns ...func(*autoscaling.Options)) (*autoscaling.UpdateAutoScalingGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *autoscaling.UpdateAutoScalingGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.UpdateAutoScalingGroupInput, ...func(*autoscaling.Options)) (*autoscaling.UpdateAutoScalingGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *autoscaling.UpdateAutoScalingGroupInput, ...func(*autoscaling.Options)) *autoscaling.UpdateAutoScalingGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*autoscaling.UpdateAutoScalingGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *autoscaling.UpdateAutoScalingGroupInput, ...func(*autoscaling.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewASG creates a new instance of ASG. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewASG(t interface {
	mock.TestingT
	Cleanup(func())
}) *ASG {
	mock := &ASG{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
