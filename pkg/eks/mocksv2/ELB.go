// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocksv2

import (
	context "context"

	elasticloadbalancing "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancing"
	mock "github.com/stretchr/testify/mock"
)

// ELB is an autogenerated mock type for the ELB type
type ELB struct {
	mock.Mock
}

type ELB_Expecter struct {
	mock *mock.Mock
}

func (_m *ELB) EXPECT() *ELB_Expecter {
	return &ELB_Expecter{mock: &_m.Mock}
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) AddTags(ctx context.Context, params *elasticloadbalancing.AddTagsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddTags")
	}

	var r0 *elasticloadbalancing.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.AddTagsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.AddTagsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.AddTagsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_AddTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTags'
type ELB_AddTags_Call struct {
	*mock.Call
}

// AddTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.AddTagsInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) AddTags(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_AddTags_Call {
	return &ELB_AddTags_Call{Call: _e.mock.On("AddTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_AddTags_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.AddTagsInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_AddTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.AddTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_AddTags_Call) Return(_a0 *elasticloadbalancing.AddTagsOutput, _a1 error) *ELB_AddTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_AddTags_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.AddTagsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AddTagsOutput, error)) *ELB_AddTags_Call {
	_c.Call.Return(run)
	return _c
}

// ApplySecurityGroupsToLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) ApplySecurityGroupsToLoadBalancer(ctx context.Context, params *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApplySecurityGroupsToLoadBalancer")
	}

	var r0 *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_ApplySecurityGroupsToLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplySecurityGroupsToLoadBalancer'
type ELB_ApplySecurityGroupsToLoadBalancer_Call struct {
	*mock.Call
}

// ApplySecurityGroupsToLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) ApplySecurityGroupsToLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_ApplySecurityGroupsToLoadBalancer_Call {
	return &ELB_ApplySecurityGroupsToLoadBalancer_Call{Call: _e.mock.On("ApplySecurityGroupsToLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_ApplySecurityGroupsToLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_ApplySecurityGroupsToLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_ApplySecurityGroupsToLoadBalancer_Call) Return(_a0 *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput, _a1 error) *ELB_ApplySecurityGroupsToLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_ApplySecurityGroupsToLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput, error)) *ELB_ApplySecurityGroupsToLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// AttachLoadBalancerToSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) AttachLoadBalancerToSubnets(ctx context.Context, params *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AttachLoadBalancerToSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachLoadBalancerToSubnets")
	}

	var r0 *elasticloadbalancing.AttachLoadBalancerToSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AttachLoadBalancerToSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.AttachLoadBalancerToSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.AttachLoadBalancerToSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_AttachLoadBalancerToSubnets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachLoadBalancerToSubnets'
type ELB_AttachLoadBalancerToSubnets_Call struct {
	*mock.Call
}

// AttachLoadBalancerToSubnets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.AttachLoadBalancerToSubnetsInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) AttachLoadBalancerToSubnets(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_AttachLoadBalancerToSubnets_Call {
	return &ELB_AttachLoadBalancerToSubnets_Call{Call: _e.mock.On("AttachLoadBalancerToSubnets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_AttachLoadBalancerToSubnets_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_AttachLoadBalancerToSubnets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.AttachLoadBalancerToSubnetsInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_AttachLoadBalancerToSubnets_Call) Return(_a0 *elasticloadbalancing.AttachLoadBalancerToSubnetsOutput, _a1 error) *ELB_AttachLoadBalancerToSubnets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_AttachLoadBalancerToSubnets_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AttachLoadBalancerToSubnetsOutput, error)) *ELB_AttachLoadBalancerToSubnets_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigureHealthCheck provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) ConfigureHealthCheck(ctx context.Context, params *elasticloadbalancing.ConfigureHealthCheckInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ConfigureHealthCheckOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfigureHealthCheck")
	}

	var r0 *elasticloadbalancing.ConfigureHealthCheckOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ConfigureHealthCheckInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ConfigureHealthCheckOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ConfigureHealthCheckInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.ConfigureHealthCheckOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.ConfigureHealthCheckOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.ConfigureHealthCheckInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_ConfigureHealthCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigureHealthCheck'
type ELB_ConfigureHealthCheck_Call struct {
	*mock.Call
}

// ConfigureHealthCheck is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.ConfigureHealthCheckInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) ConfigureHealthCheck(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_ConfigureHealthCheck_Call {
	return &ELB_ConfigureHealthCheck_Call{Call: _e.mock.On("ConfigureHealthCheck",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_ConfigureHealthCheck_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.ConfigureHealthCheckInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_ConfigureHealthCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.ConfigureHealthCheckInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_ConfigureHealthCheck_Call) Return(_a0 *elasticloadbalancing.ConfigureHealthCheckOutput, _a1 error) *ELB_ConfigureHealthCheck_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_ConfigureHealthCheck_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.ConfigureHealthCheckInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ConfigureHealthCheckOutput, error)) *ELB_ConfigureHealthCheck_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAppCookieStickinessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateAppCookieStickinessPolicy(ctx context.Context, params *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateAppCookieStickinessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAppCookieStickinessPolicy")
	}

	var r0 *elasticloadbalancing.CreateAppCookieStickinessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateAppCookieStickinessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateAppCookieStickinessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateAppCookieStickinessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_CreateAppCookieStickinessPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAppCookieStickinessPolicy'
type ELB_CreateAppCookieStickinessPolicy_Call struct {
	*mock.Call
}

// CreateAppCookieStickinessPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.CreateAppCookieStickinessPolicyInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) CreateAppCookieStickinessPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_CreateAppCookieStickinessPolicy_Call {
	return &ELB_CreateAppCookieStickinessPolicy_Call{Call: _e.mock.On("CreateAppCookieStickinessPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_CreateAppCookieStickinessPolicy_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_CreateAppCookieStickinessPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.CreateAppCookieStickinessPolicyInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_CreateAppCookieStickinessPolicy_Call) Return(_a0 *elasticloadbalancing.CreateAppCookieStickinessPolicyOutput, _a1 error) *ELB_CreateAppCookieStickinessPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_CreateAppCookieStickinessPolicy_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateAppCookieStickinessPolicyOutput, error)) *ELB_CreateAppCookieStickinessPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLBCookieStickinessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLBCookieStickinessPolicy(ctx context.Context, params *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLBCookieStickinessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLBCookieStickinessPolicy")
	}

	var r0 *elasticloadbalancing.CreateLBCookieStickinessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLBCookieStickinessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLBCookieStickinessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLBCookieStickinessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_CreateLBCookieStickinessPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLBCookieStickinessPolicy'
type ELB_CreateLBCookieStickinessPolicy_Call struct {
	*mock.Call
}

// CreateLBCookieStickinessPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.CreateLBCookieStickinessPolicyInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) CreateLBCookieStickinessPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_CreateLBCookieStickinessPolicy_Call {
	return &ELB_CreateLBCookieStickinessPolicy_Call{Call: _e.mock.On("CreateLBCookieStickinessPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_CreateLBCookieStickinessPolicy_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_CreateLBCookieStickinessPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.CreateLBCookieStickinessPolicyInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_CreateLBCookieStickinessPolicy_Call) Return(_a0 *elasticloadbalancing.CreateLBCookieStickinessPolicyOutput, _a1 error) *ELB_CreateLBCookieStickinessPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_CreateLBCookieStickinessPolicy_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLBCookieStickinessPolicyOutput, error)) *ELB_CreateLBCookieStickinessPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLoadBalancer(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLoadBalancer")
	}

	var r0 *elasticloadbalancing.CreateLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_CreateLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLoadBalancer'
type ELB_CreateLoadBalancer_Call struct {
	*mock.Call
}

// CreateLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.CreateLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) CreateLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_CreateLoadBalancer_Call {
	return &ELB_CreateLoadBalancer_Call{Call: _e.mock.On("CreateLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_CreateLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_CreateLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.CreateLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_CreateLoadBalancer_Call) Return(_a0 *elasticloadbalancing.CreateLoadBalancerOutput, _a1 error) *ELB_CreateLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_CreateLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.CreateLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerOutput, error)) *ELB_CreateLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLoadBalancerListeners provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLoadBalancerListeners(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerListenersInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLoadBalancerListeners")
	}

	var r0 *elasticloadbalancing.CreateLoadBalancerListenersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerListenersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLoadBalancerListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLoadBalancerListenersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_CreateLoadBalancerListeners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLoadBalancerListeners'
type ELB_CreateLoadBalancerListeners_Call struct {
	*mock.Call
}

// CreateLoadBalancerListeners is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.CreateLoadBalancerListenersInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) CreateLoadBalancerListeners(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_CreateLoadBalancerListeners_Call {
	return &ELB_CreateLoadBalancerListeners_Call{Call: _e.mock.On("CreateLoadBalancerListeners",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_CreateLoadBalancerListeners_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerListenersInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_CreateLoadBalancerListeners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.CreateLoadBalancerListenersInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_CreateLoadBalancerListeners_Call) Return(_a0 *elasticloadbalancing.CreateLoadBalancerListenersOutput, _a1 error) *ELB_CreateLoadBalancerListeners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_CreateLoadBalancerListeners_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.CreateLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerListenersOutput, error)) *ELB_CreateLoadBalancerListeners_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLoadBalancerPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLoadBalancerPolicy(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateLoadBalancerPolicy")
	}

	var r0 *elasticloadbalancing.CreateLoadBalancerPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLoadBalancerPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLoadBalancerPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_CreateLoadBalancerPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLoadBalancerPolicy'
type ELB_CreateLoadBalancerPolicy_Call struct {
	*mock.Call
}

// CreateLoadBalancerPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.CreateLoadBalancerPolicyInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) CreateLoadBalancerPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_CreateLoadBalancerPolicy_Call {
	return &ELB_CreateLoadBalancerPolicy_Call{Call: _e.mock.On("CreateLoadBalancerPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_CreateLoadBalancerPolicy_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerPolicyInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_CreateLoadBalancerPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.CreateLoadBalancerPolicyInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_CreateLoadBalancerPolicy_Call) Return(_a0 *elasticloadbalancing.CreateLoadBalancerPolicyOutput, _a1 error) *ELB_CreateLoadBalancerPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_CreateLoadBalancerPolicy_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.CreateLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerPolicyOutput, error)) *ELB_CreateLoadBalancerPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeleteLoadBalancer(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoadBalancer")
	}

	var r0 *elasticloadbalancing.DeleteLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeleteLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeleteLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DeleteLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLoadBalancer'
type ELB_DeleteLoadBalancer_Call struct {
	*mock.Call
}

// DeleteLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DeleteLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DeleteLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DeleteLoadBalancer_Call {
	return &ELB_DeleteLoadBalancer_Call{Call: _e.mock.On("DeleteLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DeleteLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DeleteLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DeleteLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DeleteLoadBalancer_Call) Return(_a0 *elasticloadbalancing.DeleteLoadBalancerOutput, _a1 error) *ELB_DeleteLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DeleteLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DeleteLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerOutput, error)) *ELB_DeleteLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLoadBalancerListeners provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeleteLoadBalancerListeners(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerListenersInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoadBalancerListeners")
	}

	var r0 *elasticloadbalancing.DeleteLoadBalancerListenersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerListenersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeleteLoadBalancerListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeleteLoadBalancerListenersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DeleteLoadBalancerListeners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLoadBalancerListeners'
type ELB_DeleteLoadBalancerListeners_Call struct {
	*mock.Call
}

// DeleteLoadBalancerListeners is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DeleteLoadBalancerListenersInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DeleteLoadBalancerListeners(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DeleteLoadBalancerListeners_Call {
	return &ELB_DeleteLoadBalancerListeners_Call{Call: _e.mock.On("DeleteLoadBalancerListeners",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DeleteLoadBalancerListeners_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerListenersInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DeleteLoadBalancerListeners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DeleteLoadBalancerListenersInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DeleteLoadBalancerListeners_Call) Return(_a0 *elasticloadbalancing.DeleteLoadBalancerListenersOutput, _a1 error) *ELB_DeleteLoadBalancerListeners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DeleteLoadBalancerListeners_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DeleteLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerListenersOutput, error)) *ELB_DeleteLoadBalancerListeners_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLoadBalancerPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeleteLoadBalancerPolicy(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLoadBalancerPolicy")
	}

	var r0 *elasticloadbalancing.DeleteLoadBalancerPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeleteLoadBalancerPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeleteLoadBalancerPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DeleteLoadBalancerPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLoadBalancerPolicy'
type ELB_DeleteLoadBalancerPolicy_Call struct {
	*mock.Call
}

// DeleteLoadBalancerPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DeleteLoadBalancerPolicyInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DeleteLoadBalancerPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DeleteLoadBalancerPolicy_Call {
	return &ELB_DeleteLoadBalancerPolicy_Call{Call: _e.mock.On("DeleteLoadBalancerPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DeleteLoadBalancerPolicy_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerPolicyInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DeleteLoadBalancerPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DeleteLoadBalancerPolicyInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DeleteLoadBalancerPolicy_Call) Return(_a0 *elasticloadbalancing.DeleteLoadBalancerPolicyOutput, _a1 error) *ELB_DeleteLoadBalancerPolicy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DeleteLoadBalancerPolicy_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DeleteLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerPolicyOutput, error)) *ELB_DeleteLoadBalancerPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// DeregisterInstancesFromLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeregisterInstancesFromLoadBalancer(ctx context.Context, params *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterInstancesFromLoadBalancer")
	}

	var r0 *elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DeregisterInstancesFromLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeregisterInstancesFromLoadBalancer'
type ELB_DeregisterInstancesFromLoadBalancer_Call struct {
	*mock.Call
}

// DeregisterInstancesFromLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DeregisterInstancesFromLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DeregisterInstancesFromLoadBalancer_Call {
	return &ELB_DeregisterInstancesFromLoadBalancer_Call{Call: _e.mock.On("DeregisterInstancesFromLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DeregisterInstancesFromLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DeregisterInstancesFromLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DeregisterInstancesFromLoadBalancer_Call) Return(_a0 *elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput, _a1 error) *ELB_DeregisterInstancesFromLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DeregisterInstancesFromLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput, error)) *ELB_DeregisterInstancesFromLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAccountLimits provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeAccountLimits(ctx context.Context, params *elasticloadbalancing.DescribeAccountLimitsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeAccountLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccountLimits")
	}

	var r0 *elasticloadbalancing.DescribeAccountLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeAccountLimitsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeAccountLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeAccountLimitsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeAccountLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeAccountLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeAccountLimitsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeAccountLimits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAccountLimits'
type ELB_DescribeAccountLimits_Call struct {
	*mock.Call
}

// DescribeAccountLimits is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeAccountLimitsInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeAccountLimits(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeAccountLimits_Call {
	return &ELB_DescribeAccountLimits_Call{Call: _e.mock.On("DescribeAccountLimits",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeAccountLimits_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeAccountLimitsInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeAccountLimits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeAccountLimitsInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeAccountLimits_Call) Return(_a0 *elasticloadbalancing.DescribeAccountLimitsOutput, _a1 error) *ELB_DescribeAccountLimits_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeAccountLimits_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeAccountLimitsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeAccountLimitsOutput, error)) *ELB_DescribeAccountLimits_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceHealth provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeInstanceHealth(ctx context.Context, params *elasticloadbalancing.DescribeInstanceHealthInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeInstanceHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceHealth")
	}

	var r0 *elasticloadbalancing.DescribeInstanceHealthOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeInstanceHealthInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeInstanceHealthOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeInstanceHealthInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeInstanceHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeInstanceHealthOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeInstanceHealthInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeInstanceHealth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceHealth'
type ELB_DescribeInstanceHealth_Call struct {
	*mock.Call
}

// DescribeInstanceHealth is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeInstanceHealthInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeInstanceHealth(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeInstanceHealth_Call {
	return &ELB_DescribeInstanceHealth_Call{Call: _e.mock.On("DescribeInstanceHealth",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeInstanceHealth_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeInstanceHealthInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeInstanceHealth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeInstanceHealthInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeInstanceHealth_Call) Return(_a0 *elasticloadbalancing.DescribeInstanceHealthOutput, _a1 error) *ELB_DescribeInstanceHealth_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeInstanceHealth_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeInstanceHealthInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeInstanceHealthOutput, error)) *ELB_DescribeInstanceHealth_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoadBalancerAttributes")
	}

	var r0 *elasticloadbalancing.DescribeLoadBalancerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeLoadBalancerAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLoadBalancerAttributes'
type ELB_DescribeLoadBalancerAttributes_Call struct {
	*mock.Call
}

// DescribeLoadBalancerAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeLoadBalancerAttributesInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeLoadBalancerAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeLoadBalancerAttributes_Call {
	return &ELB_DescribeLoadBalancerAttributes_Call{Call: _e.mock.On("DescribeLoadBalancerAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeLoadBalancerAttributes_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeLoadBalancerAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeLoadBalancerAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeLoadBalancerAttributes_Call) Return(_a0 *elasticloadbalancing.DescribeLoadBalancerAttributesOutput, _a1 error) *ELB_DescribeLoadBalancerAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeLoadBalancerAttributes_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerAttributesOutput, error)) *ELB_DescribeLoadBalancerAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLoadBalancerPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancerPolicies(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoadBalancerPolicies")
	}

	var r0 *elasticloadbalancing.DescribeLoadBalancerPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancerPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancerPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeLoadBalancerPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLoadBalancerPolicies'
type ELB_DescribeLoadBalancerPolicies_Call struct {
	*mock.Call
}

// DescribeLoadBalancerPolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeLoadBalancerPoliciesInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeLoadBalancerPolicies(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeLoadBalancerPolicies_Call {
	return &ELB_DescribeLoadBalancerPolicies_Call{Call: _e.mock.On("DescribeLoadBalancerPolicies",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeLoadBalancerPolicies_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeLoadBalancerPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeLoadBalancerPoliciesInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeLoadBalancerPolicies_Call) Return(_a0 *elasticloadbalancing.DescribeLoadBalancerPoliciesOutput, _a1 error) *ELB_DescribeLoadBalancerPolicies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeLoadBalancerPolicies_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPoliciesOutput, error)) *ELB_DescribeLoadBalancerPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLoadBalancerPolicyTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancerPolicyTypes(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoadBalancerPolicyTypes")
	}

	var r0 *elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeLoadBalancerPolicyTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLoadBalancerPolicyTypes'
type ELB_DescribeLoadBalancerPolicyTypes_Call struct {
	*mock.Call
}

// DescribeLoadBalancerPolicyTypes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeLoadBalancerPolicyTypes(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeLoadBalancerPolicyTypes_Call {
	return &ELB_DescribeLoadBalancerPolicyTypes_Call{Call: _e.mock.On("DescribeLoadBalancerPolicyTypes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeLoadBalancerPolicyTypes_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeLoadBalancerPolicyTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeLoadBalancerPolicyTypes_Call) Return(_a0 *elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput, _a1 error) *ELB_DescribeLoadBalancerPolicyTypes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeLoadBalancerPolicyTypes_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput, error)) *ELB_DescribeLoadBalancerPolicyTypes_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancers(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancersInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLoadBalancers")
	}

	var r0 *elasticloadbalancing.DescribeLoadBalancersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancersInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancersInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancersInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeLoadBalancers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeLoadBalancers'
type ELB_DescribeLoadBalancers_Call struct {
	*mock.Call
}

// DescribeLoadBalancers is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeLoadBalancersInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeLoadBalancers(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeLoadBalancers_Call {
	return &ELB_DescribeLoadBalancers_Call{Call: _e.mock.On("DescribeLoadBalancers",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeLoadBalancers_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancersInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeLoadBalancers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeLoadBalancersInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeLoadBalancers_Call) Return(_a0 *elasticloadbalancing.DescribeLoadBalancersOutput, _a1 error) *ELB_DescribeLoadBalancers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeLoadBalancers_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeLoadBalancersInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancersOutput, error)) *ELB_DescribeLoadBalancers_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeTags(ctx context.Context, params *elasticloadbalancing.DescribeTagsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeTags")
	}

	var r0 *elasticloadbalancing.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeTagsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeTagsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeTagsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DescribeTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeTags'
type ELB_DescribeTags_Call struct {
	*mock.Call
}

// DescribeTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DescribeTagsInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DescribeTags(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DescribeTags_Call {
	return &ELB_DescribeTags_Call{Call: _e.mock.On("DescribeTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DescribeTags_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DescribeTagsInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DescribeTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DescribeTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DescribeTags_Call) Return(_a0 *elasticloadbalancing.DescribeTagsOutput, _a1 error) *ELB_DescribeTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DescribeTags_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DescribeTagsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeTagsOutput, error)) *ELB_DescribeTags_Call {
	_c.Call.Return(run)
	return _c
}

// DetachLoadBalancerFromSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DetachLoadBalancerFromSubnets(ctx context.Context, params *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachLoadBalancerFromSubnets")
	}

	var r0 *elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DetachLoadBalancerFromSubnets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachLoadBalancerFromSubnets'
type ELB_DetachLoadBalancerFromSubnets_Call struct {
	*mock.Call
}

// DetachLoadBalancerFromSubnets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DetachLoadBalancerFromSubnets(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DetachLoadBalancerFromSubnets_Call {
	return &ELB_DetachLoadBalancerFromSubnets_Call{Call: _e.mock.On("DetachLoadBalancerFromSubnets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DetachLoadBalancerFromSubnets_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DetachLoadBalancerFromSubnets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DetachLoadBalancerFromSubnetsInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DetachLoadBalancerFromSubnets_Call) Return(_a0 *elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput, _a1 error) *ELB_DetachLoadBalancerFromSubnets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DetachLoadBalancerFromSubnets_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput, error)) *ELB_DetachLoadBalancerFromSubnets_Call {
	_c.Call.Return(run)
	return _c
}

// DisableAvailabilityZonesForLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DisableAvailabilityZonesForLoadBalancer(ctx context.Context, params *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableAvailabilityZonesForLoadBalancer")
	}

	var r0 *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_DisableAvailabilityZonesForLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableAvailabilityZonesForLoadBalancer'
type ELB_DisableAvailabilityZonesForLoadBalancer_Call struct {
	*mock.Call
}

// DisableAvailabilityZonesForLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) DisableAvailabilityZonesForLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_DisableAvailabilityZonesForLoadBalancer_Call {
	return &ELB_DisableAvailabilityZonesForLoadBalancer_Call{Call: _e.mock.On("DisableAvailabilityZonesForLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_DisableAvailabilityZonesForLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_DisableAvailabilityZonesForLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_DisableAvailabilityZonesForLoadBalancer_Call) Return(_a0 *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput, _a1 error) *ELB_DisableAvailabilityZonesForLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_DisableAvailabilityZonesForLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput, error)) *ELB_DisableAvailabilityZonesForLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// EnableAvailabilityZonesForLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) EnableAvailabilityZonesForLoadBalancer(ctx context.Context, params *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableAvailabilityZonesForLoadBalancer")
	}

	var r0 *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_EnableAvailabilityZonesForLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableAvailabilityZonesForLoadBalancer'
type ELB_EnableAvailabilityZonesForLoadBalancer_Call struct {
	*mock.Call
}

// EnableAvailabilityZonesForLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) EnableAvailabilityZonesForLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_EnableAvailabilityZonesForLoadBalancer_Call {
	return &ELB_EnableAvailabilityZonesForLoadBalancer_Call{Call: _e.mock.On("EnableAvailabilityZonesForLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_EnableAvailabilityZonesForLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_EnableAvailabilityZonesForLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_EnableAvailabilityZonesForLoadBalancer_Call) Return(_a0 *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput, _a1 error) *ELB_EnableAvailabilityZonesForLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_EnableAvailabilityZonesForLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput, error)) *ELB_EnableAvailabilityZonesForLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) ModifyLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancing.ModifyLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ModifyLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyLoadBalancerAttributes")
	}

	var r0 *elasticloadbalancing.ModifyLoadBalancerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ModifyLoadBalancerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.ModifyLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.ModifyLoadBalancerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_ModifyLoadBalancerAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyLoadBalancerAttributes'
type ELB_ModifyLoadBalancerAttributes_Call struct {
	*mock.Call
}

// ModifyLoadBalancerAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.ModifyLoadBalancerAttributesInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) ModifyLoadBalancerAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_ModifyLoadBalancerAttributes_Call {
	return &ELB_ModifyLoadBalancerAttributes_Call{Call: _e.mock.On("ModifyLoadBalancerAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_ModifyLoadBalancerAttributes_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.ModifyLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_ModifyLoadBalancerAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.ModifyLoadBalancerAttributesInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_ModifyLoadBalancerAttributes_Call) Return(_a0 *elasticloadbalancing.ModifyLoadBalancerAttributesOutput, _a1 error) *ELB_ModifyLoadBalancerAttributes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_ModifyLoadBalancerAttributes_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ModifyLoadBalancerAttributesOutput, error)) *ELB_ModifyLoadBalancerAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// Options provides a mock function with no fields
func (_m *ELB) Options() elasticloadbalancing.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 elasticloadbalancing.Options
	if rf, ok := ret.Get(0).(func() elasticloadbalancing.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(elasticloadbalancing.Options)
	}

	return r0
}

// ELB_Options_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Options'
type ELB_Options_Call struct {
	*mock.Call
}

// Options is a helper method to define mock.On call
func (_e *ELB_Expecter) Options() *ELB_Options_Call {
	return &ELB_Options_Call{Call: _e.mock.On("Options")}
}

func (_c *ELB_Options_Call) Run(run func()) *ELB_Options_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ELB_Options_Call) Return(_a0 elasticloadbalancing.Options) *ELB_Options_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ELB_Options_Call) RunAndReturn(run func() elasticloadbalancing.Options) *ELB_Options_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterInstancesWithLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) RegisterInstancesWithLoadBalancer(ctx context.Context, params *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterInstancesWithLoadBalancer")
	}

	var r0 *elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_RegisterInstancesWithLoadBalancer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterInstancesWithLoadBalancer'
type ELB_RegisterInstancesWithLoadBalancer_Call struct {
	*mock.Call
}

// RegisterInstancesWithLoadBalancer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) RegisterInstancesWithLoadBalancer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_RegisterInstancesWithLoadBalancer_Call {
	return &ELB_RegisterInstancesWithLoadBalancer_Call{Call: _e.mock.On("RegisterInstancesWithLoadBalancer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_RegisterInstancesWithLoadBalancer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_RegisterInstancesWithLoadBalancer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.RegisterInstancesWithLoadBalancerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_RegisterInstancesWithLoadBalancer_Call) Return(_a0 *elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput, _a1 error) *ELB_RegisterInstancesWithLoadBalancer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_RegisterInstancesWithLoadBalancer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput, error)) *ELB_RegisterInstancesWithLoadBalancer_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) RemoveTags(ctx context.Context, params *elasticloadbalancing.RemoveTagsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTags")
	}

	var r0 *elasticloadbalancing.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.RemoveTagsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.RemoveTagsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.RemoveTagsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_RemoveTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveTags'
type ELB_RemoveTags_Call struct {
	*mock.Call
}

// RemoveTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.RemoveTagsInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) RemoveTags(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_RemoveTags_Call {
	return &ELB_RemoveTags_Call{Call: _e.mock.On("RemoveTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_RemoveTags_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.RemoveTagsInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_RemoveTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.RemoveTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_RemoveTags_Call) Return(_a0 *elasticloadbalancing.RemoveTagsOutput, _a1 error) *ELB_RemoveTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_RemoveTags_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.RemoveTagsInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RemoveTagsOutput, error)) *ELB_RemoveTags_Call {
	_c.Call.Return(run)
	return _c
}

// SetLoadBalancerListenerSSLCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) SetLoadBalancerListenerSSLCertificate(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetLoadBalancerListenerSSLCertificate")
	}

	var r0 *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_SetLoadBalancerListenerSSLCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLoadBalancerListenerSSLCertificate'
type ELB_SetLoadBalancerListenerSSLCertificate_Call struct {
	*mock.Call
}

// SetLoadBalancerListenerSSLCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) SetLoadBalancerListenerSSLCertificate(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_SetLoadBalancerListenerSSLCertificate_Call {
	return &ELB_SetLoadBalancerListenerSSLCertificate_Call{Call: _e.mock.On("SetLoadBalancerListenerSSLCertificate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_SetLoadBalancerListenerSSLCertificate_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_SetLoadBalancerListenerSSLCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_SetLoadBalancerListenerSSLCertificate_Call) Return(_a0 *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput, _a1 error) *ELB_SetLoadBalancerListenerSSLCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_SetLoadBalancerListenerSSLCertificate_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput, error)) *ELB_SetLoadBalancerListenerSSLCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// SetLoadBalancerPoliciesForBackendServer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) SetLoadBalancerPoliciesForBackendServer(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetLoadBalancerPoliciesForBackendServer")
	}

	var r0 *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_SetLoadBalancerPoliciesForBackendServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLoadBalancerPoliciesForBackendServer'
type ELB_SetLoadBalancerPoliciesForBackendServer_Call struct {
	*mock.Call
}

// SetLoadBalancerPoliciesForBackendServer is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) SetLoadBalancerPoliciesForBackendServer(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_SetLoadBalancerPoliciesForBackendServer_Call {
	return &ELB_SetLoadBalancerPoliciesForBackendServer_Call{Call: _e.mock.On("SetLoadBalancerPoliciesForBackendServer",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_SetLoadBalancerPoliciesForBackendServer_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_SetLoadBalancerPoliciesForBackendServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_SetLoadBalancerPoliciesForBackendServer_Call) Return(_a0 *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput, _a1 error) *ELB_SetLoadBalancerPoliciesForBackendServer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_SetLoadBalancerPoliciesForBackendServer_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput, error)) *ELB_SetLoadBalancerPoliciesForBackendServer_Call {
	_c.Call.Return(run)
	return _c
}

// SetLoadBalancerPoliciesOfListener provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) SetLoadBalancerPoliciesOfListener(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetLoadBalancerPoliciesOfListener")
	}

	var r0 *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ELB_SetLoadBalancerPoliciesOfListener_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLoadBalancerPoliciesOfListener'
type ELB_SetLoadBalancerPoliciesOfListener_Call struct {
	*mock.Call
}

// SetLoadBalancerPoliciesOfListener is a helper method to define mock.On call
//   - ctx context.Context
//   - params *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput
//   - optFns ...func(*elasticloadbalancing.Options)
func (_e *ELB_Expecter) SetLoadBalancerPoliciesOfListener(ctx interface{}, params interface{}, optFns ...interface{}) *ELB_SetLoadBalancerPoliciesOfListener_Call {
	return &ELB_SetLoadBalancerPoliciesOfListener_Call{Call: _e.mock.On("SetLoadBalancerPoliciesOfListener",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *ELB_SetLoadBalancerPoliciesOfListener_Call) Run(run func(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, optFns ...func(*elasticloadbalancing.Options))) *ELB_SetLoadBalancerPoliciesOfListener_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*elasticloadbalancing.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*elasticloadbalancing.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput), variadicArgs...)
	})
	return _c
}

func (_c *ELB_SetLoadBalancerPoliciesOfListener_Call) Return(_a0 *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput, _a1 error) *ELB_SetLoadBalancerPoliciesOfListener_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ELB_SetLoadBalancerPoliciesOfListener_Call) RunAndReturn(run func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput, error)) *ELB_SetLoadBalancerPoliciesOfListener_Call {
	_c.Call.Return(run)
	return _c
}

// NewELB creates a new instance of ELB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewELB(t interface {
	mock.TestingT
	Cleanup(func())
}) *ELB {
	mock := &ELB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
