// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocksv2

import (
	context "context"

	eks "github.com/aws/aws-sdk-go-v2/service/eks"
	mock "github.com/stretchr/testify/mock"
)

// EKS is an autogenerated mock type for the EKS type
type EKS struct {
	mock.Mock
}

// AssociateAccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) AssociateAccessPolicy(ctx context.Context, params *eks.AssociateAccessPolicyInput, optFns ...func(*eks.Options)) (*eks.AssociateAccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateAccessPolicy")
	}

	var r0 *eks.AssociateAccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateAccessPolicyInput, ...func(*eks.Options)) (*eks.AssociateAccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateAccessPolicyInput, ...func(*eks.Options)) *eks.AssociateAccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.AssociateAccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.AssociateAccessPolicyInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateEncryptionConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) AssociateEncryptionConfig(ctx context.Context, params *eks.AssociateEncryptionConfigInput, optFns ...func(*eks.Options)) (*eks.AssociateEncryptionConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateEncryptionConfig")
	}

	var r0 *eks.AssociateEncryptionConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateEncryptionConfigInput, ...func(*eks.Options)) (*eks.AssociateEncryptionConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateEncryptionConfigInput, ...func(*eks.Options)) *eks.AssociateEncryptionConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.AssociateEncryptionConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.AssociateEncryptionConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIdentityProviderConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) AssociateIdentityProviderConfig(ctx context.Context, params *eks.AssociateIdentityProviderConfigInput, optFns ...func(*eks.Options)) (*eks.AssociateIdentityProviderConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssociateIdentityProviderConfig")
	}

	var r0 *eks.AssociateIdentityProviderConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateIdentityProviderConfigInput, ...func(*eks.Options)) (*eks.AssociateIdentityProviderConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateIdentityProviderConfigInput, ...func(*eks.Options)) *eks.AssociateIdentityProviderConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.AssociateIdentityProviderConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.AssociateIdentityProviderConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccessEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateAccessEntry(ctx context.Context, params *eks.CreateAccessEntryInput, optFns ...func(*eks.Options)) (*eks.CreateAccessEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessEntry")
	}

	var r0 *eks.CreateAccessEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateAccessEntryInput, ...func(*eks.Options)) (*eks.CreateAccessEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateAccessEntryInput, ...func(*eks.Options)) *eks.CreateAccessEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateAccessEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateAccessEntryInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateAddon(ctx context.Context, params *eks.CreateAddonInput, optFns ...func(*eks.Options)) (*eks.CreateAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAddon")
	}

	var r0 *eks.CreateAddonOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateAddonInput, ...func(*eks.Options)) (*eks.CreateAddonOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateAddonInput, ...func(*eks.Options)) *eks.CreateAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateAddonOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateCluster(ctx context.Context, params *eks.CreateClusterInput, optFns ...func(*eks.Options)) (*eks.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 *eks.CreateClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateClusterInput, ...func(*eks.Options)) (*eks.CreateClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateClusterInput, ...func(*eks.Options)) *eks.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEksAnywhereSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateEksAnywhereSubscription(ctx context.Context, params *eks.CreateEksAnywhereSubscriptionInput, optFns ...func(*eks.Options)) (*eks.CreateEksAnywhereSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEksAnywhereSubscription")
	}

	var r0 *eks.CreateEksAnywhereSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateEksAnywhereSubscriptionInput, ...func(*eks.Options)) (*eks.CreateEksAnywhereSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateEksAnywhereSubscriptionInput, ...func(*eks.Options)) *eks.CreateEksAnywhereSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateEksAnywhereSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateEksAnywhereSubscriptionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFargateProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateFargateProfile(ctx context.Context, params *eks.CreateFargateProfileInput, optFns ...func(*eks.Options)) (*eks.CreateFargateProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateFargateProfile")
	}

	var r0 *eks.CreateFargateProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateFargateProfileInput, ...func(*eks.Options)) (*eks.CreateFargateProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateFargateProfileInput, ...func(*eks.Options)) *eks.CreateFargateProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateFargateProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateFargateProfileInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNodegroup provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateNodegroup(ctx context.Context, params *eks.CreateNodegroupInput, optFns ...func(*eks.Options)) (*eks.CreateNodegroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNodegroup")
	}

	var r0 *eks.CreateNodegroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateNodegroupInput, ...func(*eks.Options)) (*eks.CreateNodegroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateNodegroupInput, ...func(*eks.Options)) *eks.CreateNodegroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateNodegroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateNodegroupInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePodIdentityAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreatePodIdentityAssociation(ctx context.Context, params *eks.CreatePodIdentityAssociationInput, optFns ...func(*eks.Options)) (*eks.CreatePodIdentityAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePodIdentityAssociation")
	}

	var r0 *eks.CreatePodIdentityAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreatePodIdentityAssociationInput, ...func(*eks.Options)) (*eks.CreatePodIdentityAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreatePodIdentityAssociationInput, ...func(*eks.Options)) *eks.CreatePodIdentityAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreatePodIdentityAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreatePodIdentityAssociationInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccessEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteAccessEntry(ctx context.Context, params *eks.DeleteAccessEntryInput, optFns ...func(*eks.Options)) (*eks.DeleteAccessEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAccessEntry")
	}

	var r0 *eks.DeleteAccessEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteAccessEntryInput, ...func(*eks.Options)) (*eks.DeleteAccessEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteAccessEntryInput, ...func(*eks.Options)) *eks.DeleteAccessEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteAccessEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteAccessEntryInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteAddon(ctx context.Context, params *eks.DeleteAddonInput, optFns ...func(*eks.Options)) (*eks.DeleteAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAddon")
	}

	var r0 *eks.DeleteAddonOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteAddonInput, ...func(*eks.Options)) (*eks.DeleteAddonOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteAddonInput, ...func(*eks.Options)) *eks.DeleteAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteAddonOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteCluster(ctx context.Context, params *eks.DeleteClusterInput, optFns ...func(*eks.Options)) (*eks.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCluster")
	}

	var r0 *eks.DeleteClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteClusterInput, ...func(*eks.Options)) (*eks.DeleteClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteClusterInput, ...func(*eks.Options)) *eks.DeleteClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEksAnywhereSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteEksAnywhereSubscription(ctx context.Context, params *eks.DeleteEksAnywhereSubscriptionInput, optFns ...func(*eks.Options)) (*eks.DeleteEksAnywhereSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEksAnywhereSubscription")
	}

	var r0 *eks.DeleteEksAnywhereSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteEksAnywhereSubscriptionInput, ...func(*eks.Options)) (*eks.DeleteEksAnywhereSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteEksAnywhereSubscriptionInput, ...func(*eks.Options)) *eks.DeleteEksAnywhereSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteEksAnywhereSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteEksAnywhereSubscriptionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFargateProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteFargateProfile(ctx context.Context, params *eks.DeleteFargateProfileInput, optFns ...func(*eks.Options)) (*eks.DeleteFargateProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFargateProfile")
	}

	var r0 *eks.DeleteFargateProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteFargateProfileInput, ...func(*eks.Options)) (*eks.DeleteFargateProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteFargateProfileInput, ...func(*eks.Options)) *eks.DeleteFargateProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteFargateProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteFargateProfileInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNodegroup provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteNodegroup(ctx context.Context, params *eks.DeleteNodegroupInput, optFns ...func(*eks.Options)) (*eks.DeleteNodegroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNodegroup")
	}

	var r0 *eks.DeleteNodegroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteNodegroupInput, ...func(*eks.Options)) (*eks.DeleteNodegroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteNodegroupInput, ...func(*eks.Options)) *eks.DeleteNodegroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteNodegroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteNodegroupInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePodIdentityAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeletePodIdentityAssociation(ctx context.Context, params *eks.DeletePodIdentityAssociationInput, optFns ...func(*eks.Options)) (*eks.DeletePodIdentityAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePodIdentityAssociation")
	}

	var r0 *eks.DeletePodIdentityAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeletePodIdentityAssociationInput, ...func(*eks.Options)) (*eks.DeletePodIdentityAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeletePodIdentityAssociationInput, ...func(*eks.Options)) *eks.DeletePodIdentityAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeletePodIdentityAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeletePodIdentityAssociationInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeregisterCluster(ctx context.Context, params *eks.DeregisterClusterInput, optFns ...func(*eks.Options)) (*eks.DeregisterClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeregisterCluster")
	}

	var r0 *eks.DeregisterClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeregisterClusterInput, ...func(*eks.Options)) (*eks.DeregisterClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeregisterClusterInput, ...func(*eks.Options)) *eks.DeregisterClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeregisterClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeregisterClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccessEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAccessEntry(ctx context.Context, params *eks.DescribeAccessEntryInput, optFns ...func(*eks.Options)) (*eks.DescribeAccessEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAccessEntry")
	}

	var r0 *eks.DescribeAccessEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAccessEntryInput, ...func(*eks.Options)) (*eks.DescribeAccessEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAccessEntryInput, ...func(*eks.Options)) *eks.DescribeAccessEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAccessEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAccessEntryInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAddon(ctx context.Context, params *eks.DescribeAddonInput, optFns ...func(*eks.Options)) (*eks.DescribeAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddon")
	}

	var r0 *eks.DescribeAddonOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonInput, ...func(*eks.Options)) (*eks.DescribeAddonOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonInput, ...func(*eks.Options)) *eks.DescribeAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAddonOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddonConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAddonConfiguration(ctx context.Context, params *eks.DescribeAddonConfigurationInput, optFns ...func(*eks.Options)) (*eks.DescribeAddonConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddonConfiguration")
	}

	var r0 *eks.DescribeAddonConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonConfigurationInput, ...func(*eks.Options)) (*eks.DescribeAddonConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonConfigurationInput, ...func(*eks.Options)) *eks.DescribeAddonConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAddonConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAddonConfigurationInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddonVersions provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAddonVersions(ctx context.Context, params *eks.DescribeAddonVersionsInput, optFns ...func(*eks.Options)) (*eks.DescribeAddonVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAddonVersions")
	}

	var r0 *eks.DescribeAddonVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonVersionsInput, ...func(*eks.Options)) (*eks.DescribeAddonVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonVersionsInput, ...func(*eks.Options)) *eks.DescribeAddonVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAddonVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAddonVersionsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeCluster(ctx context.Context, params *eks.DescribeClusterInput, optFns ...func(*eks.Options)) (*eks.DescribeClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCluster")
	}

	var r0 *eks.DescribeClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeClusterInput, ...func(*eks.Options)) (*eks.DescribeClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeClusterInput, ...func(*eks.Options)) *eks.DescribeClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEksAnywhereSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeEksAnywhereSubscription(ctx context.Context, params *eks.DescribeEksAnywhereSubscriptionInput, optFns ...func(*eks.Options)) (*eks.DescribeEksAnywhereSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEksAnywhereSubscription")
	}

	var r0 *eks.DescribeEksAnywhereSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeEksAnywhereSubscriptionInput, ...func(*eks.Options)) (*eks.DescribeEksAnywhereSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeEksAnywhereSubscriptionInput, ...func(*eks.Options)) *eks.DescribeEksAnywhereSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeEksAnywhereSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeEksAnywhereSubscriptionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFargateProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeFargateProfile(ctx context.Context, params *eks.DescribeFargateProfileInput, optFns ...func(*eks.Options)) (*eks.DescribeFargateProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeFargateProfile")
	}

	var r0 *eks.DescribeFargateProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeFargateProfileInput, ...func(*eks.Options)) (*eks.DescribeFargateProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeFargateProfileInput, ...func(*eks.Options)) *eks.DescribeFargateProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeFargateProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeFargateProfileInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdentityProviderConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeIdentityProviderConfig(ctx context.Context, params *eks.DescribeIdentityProviderConfigInput, optFns ...func(*eks.Options)) (*eks.DescribeIdentityProviderConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIdentityProviderConfig")
	}

	var r0 *eks.DescribeIdentityProviderConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeIdentityProviderConfigInput, ...func(*eks.Options)) (*eks.DescribeIdentityProviderConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeIdentityProviderConfigInput, ...func(*eks.Options)) *eks.DescribeIdentityProviderConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeIdentityProviderConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeIdentityProviderConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNodegroup provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeNodegroup(ctx context.Context, params *eks.DescribeNodegroupInput, optFns ...func(*eks.Options)) (*eks.DescribeNodegroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeNodegroup")
	}

	var r0 *eks.DescribeNodegroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeNodegroupInput, ...func(*eks.Options)) (*eks.DescribeNodegroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeNodegroupInput, ...func(*eks.Options)) *eks.DescribeNodegroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeNodegroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeNodegroupInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePodIdentityAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribePodIdentityAssociation(ctx context.Context, params *eks.DescribePodIdentityAssociationInput, optFns ...func(*eks.Options)) (*eks.DescribePodIdentityAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePodIdentityAssociation")
	}

	var r0 *eks.DescribePodIdentityAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribePodIdentityAssociationInput, ...func(*eks.Options)) (*eks.DescribePodIdentityAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribePodIdentityAssociationInput, ...func(*eks.Options)) *eks.DescribePodIdentityAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribePodIdentityAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribePodIdentityAssociationInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUpdate provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeUpdate(ctx context.Context, params *eks.DescribeUpdateInput, optFns ...func(*eks.Options)) (*eks.DescribeUpdateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUpdate")
	}

	var r0 *eks.DescribeUpdateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeUpdateInput, ...func(*eks.Options)) (*eks.DescribeUpdateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeUpdateInput, ...func(*eks.Options)) *eks.DescribeUpdateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeUpdateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeUpdateInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAccessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DisassociateAccessPolicy(ctx context.Context, params *eks.DisassociateAccessPolicyInput, optFns ...func(*eks.Options)) (*eks.DisassociateAccessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateAccessPolicy")
	}

	var r0 *eks.DisassociateAccessPolicyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DisassociateAccessPolicyInput, ...func(*eks.Options)) (*eks.DisassociateAccessPolicyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DisassociateAccessPolicyInput, ...func(*eks.Options)) *eks.DisassociateAccessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DisassociateAccessPolicyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DisassociateAccessPolicyInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIdentityProviderConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DisassociateIdentityProviderConfig(ctx context.Context, params *eks.DisassociateIdentityProviderConfigInput, optFns ...func(*eks.Options)) (*eks.DisassociateIdentityProviderConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisassociateIdentityProviderConfig")
	}

	var r0 *eks.DisassociateIdentityProviderConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DisassociateIdentityProviderConfigInput, ...func(*eks.Options)) (*eks.DisassociateIdentityProviderConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DisassociateIdentityProviderConfigInput, ...func(*eks.Options)) *eks.DisassociateIdentityProviderConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DisassociateIdentityProviderConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.DisassociateIdentityProviderConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessEntries provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListAccessEntries(ctx context.Context, params *eks.ListAccessEntriesInput, optFns ...func(*eks.Options)) (*eks.ListAccessEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessEntries")
	}

	var r0 *eks.ListAccessEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAccessEntriesInput, ...func(*eks.Options)) (*eks.ListAccessEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAccessEntriesInput, ...func(*eks.Options)) *eks.ListAccessEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListAccessEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListAccessEntriesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAccessPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListAccessPolicies(ctx context.Context, params *eks.ListAccessPoliciesInput, optFns ...func(*eks.Options)) (*eks.ListAccessPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAccessPolicies")
	}

	var r0 *eks.ListAccessPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAccessPoliciesInput, ...func(*eks.Options)) (*eks.ListAccessPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAccessPoliciesInput, ...func(*eks.Options)) *eks.ListAccessPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListAccessPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListAccessPoliciesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAddons provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListAddons(ctx context.Context, params *eks.ListAddonsInput, optFns ...func(*eks.Options)) (*eks.ListAddonsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAddons")
	}

	var r0 *eks.ListAddonsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAddonsInput, ...func(*eks.Options)) (*eks.ListAddonsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAddonsInput, ...func(*eks.Options)) *eks.ListAddonsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListAddonsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListAddonsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAssociatedAccessPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListAssociatedAccessPolicies(ctx context.Context, params *eks.ListAssociatedAccessPoliciesInput, optFns ...func(*eks.Options)) (*eks.ListAssociatedAccessPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAssociatedAccessPolicies")
	}

	var r0 *eks.ListAssociatedAccessPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAssociatedAccessPoliciesInput, ...func(*eks.Options)) (*eks.ListAssociatedAccessPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAssociatedAccessPoliciesInput, ...func(*eks.Options)) *eks.ListAssociatedAccessPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListAssociatedAccessPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListAssociatedAccessPoliciesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusters provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListClusters(ctx context.Context, params *eks.ListClustersInput, optFns ...func(*eks.Options)) (*eks.ListClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListClusters")
	}

	var r0 *eks.ListClustersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListClustersInput, ...func(*eks.Options)) (*eks.ListClustersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListClustersInput, ...func(*eks.Options)) *eks.ListClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListClustersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListClustersInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListEksAnywhereSubscriptions provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListEksAnywhereSubscriptions(ctx context.Context, params *eks.ListEksAnywhereSubscriptionsInput, optFns ...func(*eks.Options)) (*eks.ListEksAnywhereSubscriptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEksAnywhereSubscriptions")
	}

	var r0 *eks.ListEksAnywhereSubscriptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListEksAnywhereSubscriptionsInput, ...func(*eks.Options)) (*eks.ListEksAnywhereSubscriptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListEksAnywhereSubscriptionsInput, ...func(*eks.Options)) *eks.ListEksAnywhereSubscriptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListEksAnywhereSubscriptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListEksAnywhereSubscriptionsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFargateProfiles provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListFargateProfiles(ctx context.Context, params *eks.ListFargateProfilesInput, optFns ...func(*eks.Options)) (*eks.ListFargateProfilesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListFargateProfiles")
	}

	var r0 *eks.ListFargateProfilesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListFargateProfilesInput, ...func(*eks.Options)) (*eks.ListFargateProfilesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListFargateProfilesInput, ...func(*eks.Options)) *eks.ListFargateProfilesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListFargateProfilesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListFargateProfilesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIdentityProviderConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListIdentityProviderConfigs(ctx context.Context, params *eks.ListIdentityProviderConfigsInput, optFns ...func(*eks.Options)) (*eks.ListIdentityProviderConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIdentityProviderConfigs")
	}

	var r0 *eks.ListIdentityProviderConfigsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListIdentityProviderConfigsInput, ...func(*eks.Options)) (*eks.ListIdentityProviderConfigsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListIdentityProviderConfigsInput, ...func(*eks.Options)) *eks.ListIdentityProviderConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListIdentityProviderConfigsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListIdentityProviderConfigsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodegroups provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListNodegroups(ctx context.Context, params *eks.ListNodegroupsInput, optFns ...func(*eks.Options)) (*eks.ListNodegroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListNodegroups")
	}

	var r0 *eks.ListNodegroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListNodegroupsInput, ...func(*eks.Options)) (*eks.ListNodegroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListNodegroupsInput, ...func(*eks.Options)) *eks.ListNodegroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListNodegroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListNodegroupsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPodIdentityAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListPodIdentityAssociations(ctx context.Context, params *eks.ListPodIdentityAssociationsInput, optFns ...func(*eks.Options)) (*eks.ListPodIdentityAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPodIdentityAssociations")
	}

	var r0 *eks.ListPodIdentityAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListPodIdentityAssociationsInput, ...func(*eks.Options)) (*eks.ListPodIdentityAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListPodIdentityAssociationsInput, ...func(*eks.Options)) *eks.ListPodIdentityAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListPodIdentityAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListPodIdentityAssociationsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListTagsForResource(ctx context.Context, params *eks.ListTagsForResourceInput, optFns ...func(*eks.Options)) (*eks.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForResource")
	}

	var r0 *eks.ListTagsForResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListTagsForResourceInput, ...func(*eks.Options)) (*eks.ListTagsForResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListTagsForResourceInput, ...func(*eks.Options)) *eks.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListTagsForResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListTagsForResourceInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUpdates provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListUpdates(ctx context.Context, params *eks.ListUpdatesInput, optFns ...func(*eks.Options)) (*eks.ListUpdatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUpdates")
	}

	var r0 *eks.ListUpdatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListUpdatesInput, ...func(*eks.Options)) (*eks.ListUpdatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListUpdatesInput, ...func(*eks.Options)) *eks.ListUpdatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListUpdatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListUpdatesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Options provides a mock function with given fields:
func (_m *EKS) Options() eks.Options {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 eks.Options
	if rf, ok := ret.Get(0).(func() eks.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(eks.Options)
	}

	return r0
}

// RegisterCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) RegisterCluster(ctx context.Context, params *eks.RegisterClusterInput, optFns ...func(*eks.Options)) (*eks.RegisterClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterCluster")
	}

	var r0 *eks.RegisterClusterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.RegisterClusterInput, ...func(*eks.Options)) (*eks.RegisterClusterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.RegisterClusterInput, ...func(*eks.Options)) *eks.RegisterClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.RegisterClusterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.RegisterClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) TagResource(ctx context.Context, params *eks.TagResourceInput, optFns ...func(*eks.Options)) (*eks.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TagResource")
	}

	var r0 *eks.TagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.TagResourceInput, ...func(*eks.Options)) (*eks.TagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.TagResourceInput, ...func(*eks.Options)) *eks.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.TagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.TagResourceInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UntagResource(ctx context.Context, params *eks.UntagResourceInput, optFns ...func(*eks.Options)) (*eks.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UntagResource")
	}

	var r0 *eks.UntagResourceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UntagResourceInput, ...func(*eks.Options)) (*eks.UntagResourceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UntagResourceInput, ...func(*eks.Options)) *eks.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UntagResourceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UntagResourceInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAccessEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateAccessEntry(ctx context.Context, params *eks.UpdateAccessEntryInput, optFns ...func(*eks.Options)) (*eks.UpdateAccessEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccessEntry")
	}

	var r0 *eks.UpdateAccessEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateAccessEntryInput, ...func(*eks.Options)) (*eks.UpdateAccessEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateAccessEntryInput, ...func(*eks.Options)) *eks.UpdateAccessEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateAccessEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateAccessEntryInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateAddon(ctx context.Context, params *eks.UpdateAddonInput, optFns ...func(*eks.Options)) (*eks.UpdateAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAddon")
	}

	var r0 *eks.UpdateAddonOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateAddonInput, ...func(*eks.Options)) (*eks.UpdateAddonOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateAddonInput, ...func(*eks.Options)) *eks.UpdateAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateAddonOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateClusterConfig(ctx context.Context, params *eks.UpdateClusterConfigInput, optFns ...func(*eks.Options)) (*eks.UpdateClusterConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClusterConfig")
	}

	var r0 *eks.UpdateClusterConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateClusterConfigInput, ...func(*eks.Options)) (*eks.UpdateClusterConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateClusterConfigInput, ...func(*eks.Options)) *eks.UpdateClusterConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateClusterConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateClusterConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateClusterVersion(ctx context.Context, params *eks.UpdateClusterVersionInput, optFns ...func(*eks.Options)) (*eks.UpdateClusterVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateClusterVersion")
	}

	var r0 *eks.UpdateClusterVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateClusterVersionInput, ...func(*eks.Options)) (*eks.UpdateClusterVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateClusterVersionInput, ...func(*eks.Options)) *eks.UpdateClusterVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateClusterVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateClusterVersionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateEksAnywhereSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateEksAnywhereSubscription(ctx context.Context, params *eks.UpdateEksAnywhereSubscriptionInput, optFns ...func(*eks.Options)) (*eks.UpdateEksAnywhereSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEksAnywhereSubscription")
	}

	var r0 *eks.UpdateEksAnywhereSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateEksAnywhereSubscriptionInput, ...func(*eks.Options)) (*eks.UpdateEksAnywhereSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateEksAnywhereSubscriptionInput, ...func(*eks.Options)) *eks.UpdateEksAnywhereSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateEksAnywhereSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateEksAnywhereSubscriptionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNodegroupConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateNodegroupConfig(ctx context.Context, params *eks.UpdateNodegroupConfigInput, optFns ...func(*eks.Options)) (*eks.UpdateNodegroupConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNodegroupConfig")
	}

	var r0 *eks.UpdateNodegroupConfigOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateNodegroupConfigInput, ...func(*eks.Options)) (*eks.UpdateNodegroupConfigOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateNodegroupConfigInput, ...func(*eks.Options)) *eks.UpdateNodegroupConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateNodegroupConfigOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateNodegroupConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNodegroupVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateNodegroupVersion(ctx context.Context, params *eks.UpdateNodegroupVersionInput, optFns ...func(*eks.Options)) (*eks.UpdateNodegroupVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNodegroupVersion")
	}

	var r0 *eks.UpdateNodegroupVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateNodegroupVersionInput, ...func(*eks.Options)) (*eks.UpdateNodegroupVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateNodegroupVersionInput, ...func(*eks.Options)) *eks.UpdateNodegroupVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateNodegroupVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateNodegroupVersionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePodIdentityAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdatePodIdentityAssociation(ctx context.Context, params *eks.UpdatePodIdentityAssociationInput, optFns ...func(*eks.Options)) (*eks.UpdatePodIdentityAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePodIdentityAssociation")
	}

	var r0 *eks.UpdatePodIdentityAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdatePodIdentityAssociationInput, ...func(*eks.Options)) (*eks.UpdatePodIdentityAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdatePodIdentityAssociationInput, ...func(*eks.Options)) *eks.UpdatePodIdentityAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdatePodIdentityAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdatePodIdentityAssociationInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewEKS creates a new instance of EKS. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEKS(t interface {
	mock.TestingT
	Cleanup(func())
}) *EKS {
	mock := &EKS{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
