// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocksv2

import (
	context "context"

	eks "github.com/aws/aws-sdk-go-v2/service/eks"
	mock "github.com/stretchr/testify/mock"
)

// EKS is an autogenerated mock type for the EKS type
type EKS struct {
	mock.Mock
}

// AssociateEncryptionConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) AssociateEncryptionConfig(ctx context.Context, params *eks.AssociateEncryptionConfigInput, optFns ...func(*eks.Options)) (*eks.AssociateEncryptionConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.AssociateEncryptionConfigOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateEncryptionConfigInput, ...func(*eks.Options)) *eks.AssociateEncryptionConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.AssociateEncryptionConfigOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.AssociateEncryptionConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIdentityProviderConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) AssociateIdentityProviderConfig(ctx context.Context, params *eks.AssociateIdentityProviderConfigInput, optFns ...func(*eks.Options)) (*eks.AssociateIdentityProviderConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.AssociateIdentityProviderConfigOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.AssociateIdentityProviderConfigInput, ...func(*eks.Options)) *eks.AssociateIdentityProviderConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.AssociateIdentityProviderConfigOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.AssociateIdentityProviderConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateAddon(ctx context.Context, params *eks.CreateAddonInput, optFns ...func(*eks.Options)) (*eks.CreateAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.CreateAddonOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateAddonInput, ...func(*eks.Options)) *eks.CreateAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateAddonOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateCluster(ctx context.Context, params *eks.CreateClusterInput, optFns ...func(*eks.Options)) (*eks.CreateClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.CreateClusterOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateClusterInput, ...func(*eks.Options)) *eks.CreateClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateClusterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFargateProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateFargateProfile(ctx context.Context, params *eks.CreateFargateProfileInput, optFns ...func(*eks.Options)) (*eks.CreateFargateProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.CreateFargateProfileOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateFargateProfileInput, ...func(*eks.Options)) *eks.CreateFargateProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateFargateProfileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateFargateProfileInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNodegroup provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) CreateNodegroup(ctx context.Context, params *eks.CreateNodegroupInput, optFns ...func(*eks.Options)) (*eks.CreateNodegroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.CreateNodegroupOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.CreateNodegroupInput, ...func(*eks.Options)) *eks.CreateNodegroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.CreateNodegroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.CreateNodegroupInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteAddon(ctx context.Context, params *eks.DeleteAddonInput, optFns ...func(*eks.Options)) (*eks.DeleteAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DeleteAddonOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteAddonInput, ...func(*eks.Options)) *eks.DeleteAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteAddonOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteCluster(ctx context.Context, params *eks.DeleteClusterInput, optFns ...func(*eks.Options)) (*eks.DeleteClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DeleteClusterOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteClusterInput, ...func(*eks.Options)) *eks.DeleteClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteClusterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFargateProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteFargateProfile(ctx context.Context, params *eks.DeleteFargateProfileInput, optFns ...func(*eks.Options)) (*eks.DeleteFargateProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DeleteFargateProfileOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteFargateProfileInput, ...func(*eks.Options)) *eks.DeleteFargateProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteFargateProfileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteFargateProfileInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNodegroup provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeleteNodegroup(ctx context.Context, params *eks.DeleteNodegroupInput, optFns ...func(*eks.Options)) (*eks.DeleteNodegroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DeleteNodegroupOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeleteNodegroupInput, ...func(*eks.Options)) *eks.DeleteNodegroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeleteNodegroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeleteNodegroupInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DeregisterCluster(ctx context.Context, params *eks.DeregisterClusterInput, optFns ...func(*eks.Options)) (*eks.DeregisterClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DeregisterClusterOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DeregisterClusterInput, ...func(*eks.Options)) *eks.DeregisterClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DeregisterClusterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DeregisterClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAddon(ctx context.Context, params *eks.DescribeAddonInput, optFns ...func(*eks.Options)) (*eks.DescribeAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeAddonOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonInput, ...func(*eks.Options)) *eks.DescribeAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAddonOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddonConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAddonConfiguration(ctx context.Context, params *eks.DescribeAddonConfigurationInput, optFns ...func(*eks.Options)) (*eks.DescribeAddonConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeAddonConfigurationOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonConfigurationInput, ...func(*eks.Options)) *eks.DescribeAddonConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAddonConfigurationOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAddonConfigurationInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddonVersions provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeAddonVersions(ctx context.Context, params *eks.DescribeAddonVersionsInput, optFns ...func(*eks.Options)) (*eks.DescribeAddonVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeAddonVersionsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeAddonVersionsInput, ...func(*eks.Options)) *eks.DescribeAddonVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeAddonVersionsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeAddonVersionsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeCluster(ctx context.Context, params *eks.DescribeClusterInput, optFns ...func(*eks.Options)) (*eks.DescribeClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeClusterOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeClusterInput, ...func(*eks.Options)) *eks.DescribeClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeClusterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFargateProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeFargateProfile(ctx context.Context, params *eks.DescribeFargateProfileInput, optFns ...func(*eks.Options)) (*eks.DescribeFargateProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeFargateProfileOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeFargateProfileInput, ...func(*eks.Options)) *eks.DescribeFargateProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeFargateProfileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeFargateProfileInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdentityProviderConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeIdentityProviderConfig(ctx context.Context, params *eks.DescribeIdentityProviderConfigInput, optFns ...func(*eks.Options)) (*eks.DescribeIdentityProviderConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeIdentityProviderConfigOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeIdentityProviderConfigInput, ...func(*eks.Options)) *eks.DescribeIdentityProviderConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeIdentityProviderConfigOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeIdentityProviderConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNodegroup provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeNodegroup(ctx context.Context, params *eks.DescribeNodegroupInput, optFns ...func(*eks.Options)) (*eks.DescribeNodegroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeNodegroupOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeNodegroupInput, ...func(*eks.Options)) *eks.DescribeNodegroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeNodegroupOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeNodegroupInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUpdate provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DescribeUpdate(ctx context.Context, params *eks.DescribeUpdateInput, optFns ...func(*eks.Options)) (*eks.DescribeUpdateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DescribeUpdateOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DescribeUpdateInput, ...func(*eks.Options)) *eks.DescribeUpdateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DescribeUpdateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DescribeUpdateInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIdentityProviderConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) DisassociateIdentityProviderConfig(ctx context.Context, params *eks.DisassociateIdentityProviderConfigInput, optFns ...func(*eks.Options)) (*eks.DisassociateIdentityProviderConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.DisassociateIdentityProviderConfigOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.DisassociateIdentityProviderConfigInput, ...func(*eks.Options)) *eks.DisassociateIdentityProviderConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.DisassociateIdentityProviderConfigOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.DisassociateIdentityProviderConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAddons provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListAddons(ctx context.Context, params *eks.ListAddonsInput, optFns ...func(*eks.Options)) (*eks.ListAddonsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListAddonsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListAddonsInput, ...func(*eks.Options)) *eks.ListAddonsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListAddonsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListAddonsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClusters provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListClusters(ctx context.Context, params *eks.ListClustersInput, optFns ...func(*eks.Options)) (*eks.ListClustersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListClustersOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListClustersInput, ...func(*eks.Options)) *eks.ListClustersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListClustersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListClustersInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFargateProfiles provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListFargateProfiles(ctx context.Context, params *eks.ListFargateProfilesInput, optFns ...func(*eks.Options)) (*eks.ListFargateProfilesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListFargateProfilesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListFargateProfilesInput, ...func(*eks.Options)) *eks.ListFargateProfilesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListFargateProfilesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListFargateProfilesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIdentityProviderConfigs provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListIdentityProviderConfigs(ctx context.Context, params *eks.ListIdentityProviderConfigsInput, optFns ...func(*eks.Options)) (*eks.ListIdentityProviderConfigsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListIdentityProviderConfigsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListIdentityProviderConfigsInput, ...func(*eks.Options)) *eks.ListIdentityProviderConfigsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListIdentityProviderConfigsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListIdentityProviderConfigsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodegroups provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListNodegroups(ctx context.Context, params *eks.ListNodegroupsInput, optFns ...func(*eks.Options)) (*eks.ListNodegroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListNodegroupsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListNodegroupsInput, ...func(*eks.Options)) *eks.ListNodegroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListNodegroupsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListNodegroupsInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTagsForResource provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListTagsForResource(ctx context.Context, params *eks.ListTagsForResourceInput, optFns ...func(*eks.Options)) (*eks.ListTagsForResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListTagsForResourceOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListTagsForResourceInput, ...func(*eks.Options)) *eks.ListTagsForResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListTagsForResourceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListTagsForResourceInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUpdates provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) ListUpdates(ctx context.Context, params *eks.ListUpdatesInput, optFns ...func(*eks.Options)) (*eks.ListUpdatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.ListUpdatesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ListUpdatesInput, ...func(*eks.Options)) *eks.ListUpdatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ListUpdatesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.ListUpdatesInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterCluster provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) RegisterCluster(ctx context.Context, params *eks.RegisterClusterInput, optFns ...func(*eks.Options)) (*eks.RegisterClusterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.RegisterClusterOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.RegisterClusterInput, ...func(*eks.Options)) *eks.RegisterClusterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.RegisterClusterOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.RegisterClusterInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TagResource provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) TagResource(ctx context.Context, params *eks.TagResourceInput, optFns ...func(*eks.Options)) (*eks.TagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.TagResourceOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.TagResourceInput, ...func(*eks.Options)) *eks.TagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.TagResourceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.TagResourceInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntagResource provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UntagResource(ctx context.Context, params *eks.UntagResourceInput, optFns ...func(*eks.Options)) (*eks.UntagResourceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.UntagResourceOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UntagResourceInput, ...func(*eks.Options)) *eks.UntagResourceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UntagResourceOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.UntagResourceInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAddon provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateAddon(ctx context.Context, params *eks.UpdateAddonInput, optFns ...func(*eks.Options)) (*eks.UpdateAddonOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.UpdateAddonOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateAddonInput, ...func(*eks.Options)) *eks.UpdateAddonOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateAddonOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateAddonInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateClusterConfig(ctx context.Context, params *eks.UpdateClusterConfigInput, optFns ...func(*eks.Options)) (*eks.UpdateClusterConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.UpdateClusterConfigOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateClusterConfigInput, ...func(*eks.Options)) *eks.UpdateClusterConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateClusterConfigOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateClusterConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateClusterVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateClusterVersion(ctx context.Context, params *eks.UpdateClusterVersionInput, optFns ...func(*eks.Options)) (*eks.UpdateClusterVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.UpdateClusterVersionOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateClusterVersionInput, ...func(*eks.Options)) *eks.UpdateClusterVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateClusterVersionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateClusterVersionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNodegroupConfig provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateNodegroupConfig(ctx context.Context, params *eks.UpdateNodegroupConfigInput, optFns ...func(*eks.Options)) (*eks.UpdateNodegroupConfigOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.UpdateNodegroupConfigOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateNodegroupConfigInput, ...func(*eks.Options)) *eks.UpdateNodegroupConfigOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateNodegroupConfigOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateNodegroupConfigInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNodegroupVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EKS) UpdateNodegroupVersion(ctx context.Context, params *eks.UpdateNodegroupVersionInput, optFns ...func(*eks.Options)) (*eks.UpdateNodegroupVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *eks.UpdateNodegroupVersionOutput
	if rf, ok := ret.Get(0).(func(context.Context, *eks.UpdateNodegroupVersionInput, ...func(*eks.Options)) *eks.UpdateNodegroupVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.UpdateNodegroupVersionOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *eks.UpdateNodegroupVersionInput, ...func(*eks.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
