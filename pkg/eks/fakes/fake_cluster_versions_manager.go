// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/weaveworks/eksctl/pkg/eks"
)

type FakeClusterVersionsManagerInterface struct {
	DefaultVersionStub        func() string
	defaultVersionMutex       sync.RWMutex
	defaultVersionArgsForCall []struct {
	}
	defaultVersionReturns struct {
		result1 string
	}
	defaultVersionReturnsOnCall map[int]struct {
		result1 string
	}
	IsDeprecatedVersionStub        func(string) bool
	isDeprecatedVersionMutex       sync.RWMutex
	isDeprecatedVersionArgsForCall []struct {
		arg1 string
	}
	isDeprecatedVersionReturns struct {
		result1 bool
	}
	isDeprecatedVersionReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSupportedVersionStub        func(string) bool
	isSupportedVersionMutex       sync.RWMutex
	isSupportedVersionArgsForCall []struct {
		arg1 string
	}
	isSupportedVersionReturns struct {
		result1 bool
	}
	isSupportedVersionReturnsOnCall map[int]struct {
		result1 bool
	}
	LatestVersionStub        func() string
	latestVersionMutex       sync.RWMutex
	latestVersionArgsForCall []struct {
	}
	latestVersionReturns struct {
		result1 string
	}
	latestVersionReturnsOnCall map[int]struct {
		result1 string
	}
	ResolveClusterVersionStub        func(string) (string, error)
	resolveClusterVersionMutex       sync.RWMutex
	resolveClusterVersionArgsForCall []struct {
		arg1 string
	}
	resolveClusterVersionReturns struct {
		result1 string
		result2 error
	}
	resolveClusterVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ResolveUpgradeVersionStub        func(string, string) (string, error)
	resolveUpgradeVersionMutex       sync.RWMutex
	resolveUpgradeVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	resolveUpgradeVersionReturns struct {
		result1 string
		result2 error
	}
	resolveUpgradeVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SupportedVersionsStub        func() []string
	supportedVersionsMutex       sync.RWMutex
	supportedVersionsArgsForCall []struct {
	}
	supportedVersionsReturns struct {
		result1 []string
	}
	supportedVersionsReturnsOnCall map[int]struct {
		result1 []string
	}
	ValidateVersionStub        func(string) error
	validateVersionMutex       sync.RWMutex
	validateVersionArgsForCall []struct {
		arg1 string
	}
	validateVersionReturns struct {
		result1 error
	}
	validateVersionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClusterVersionsManagerInterface) DefaultVersion() string {
	fake.defaultVersionMutex.Lock()
	ret, specificReturn := fake.defaultVersionReturnsOnCall[len(fake.defaultVersionArgsForCall)]
	fake.defaultVersionArgsForCall = append(fake.defaultVersionArgsForCall, struct {
	}{})
	stub := fake.DefaultVersionStub
	fakeReturns := fake.defaultVersionReturns
	fake.recordInvocation("DefaultVersion", []interface{}{})
	fake.defaultVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterVersionsManagerInterface) DefaultVersionCallCount() int {
	fake.defaultVersionMutex.RLock()
	defer fake.defaultVersionMutex.RUnlock()
	return len(fake.defaultVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) DefaultVersionCalls(stub func() string) {
	fake.defaultVersionMutex.Lock()
	defer fake.defaultVersionMutex.Unlock()
	fake.DefaultVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) DefaultVersionReturns(result1 string) {
	fake.defaultVersionMutex.Lock()
	defer fake.defaultVersionMutex.Unlock()
	fake.DefaultVersionStub = nil
	fake.defaultVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) DefaultVersionReturnsOnCall(i int, result1 string) {
	fake.defaultVersionMutex.Lock()
	defer fake.defaultVersionMutex.Unlock()
	fake.DefaultVersionStub = nil
	if fake.defaultVersionReturnsOnCall == nil {
		fake.defaultVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.defaultVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) IsDeprecatedVersion(arg1 string) bool {
	fake.isDeprecatedVersionMutex.Lock()
	ret, specificReturn := fake.isDeprecatedVersionReturnsOnCall[len(fake.isDeprecatedVersionArgsForCall)]
	fake.isDeprecatedVersionArgsForCall = append(fake.isDeprecatedVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsDeprecatedVersionStub
	fakeReturns := fake.isDeprecatedVersionReturns
	fake.recordInvocation("IsDeprecatedVersion", []interface{}{arg1})
	fake.isDeprecatedVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterVersionsManagerInterface) IsDeprecatedVersionCallCount() int {
	fake.isDeprecatedVersionMutex.RLock()
	defer fake.isDeprecatedVersionMutex.RUnlock()
	return len(fake.isDeprecatedVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) IsDeprecatedVersionCalls(stub func(string) bool) {
	fake.isDeprecatedVersionMutex.Lock()
	defer fake.isDeprecatedVersionMutex.Unlock()
	fake.IsDeprecatedVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) IsDeprecatedVersionArgsForCall(i int) string {
	fake.isDeprecatedVersionMutex.RLock()
	defer fake.isDeprecatedVersionMutex.RUnlock()
	argsForCall := fake.isDeprecatedVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterVersionsManagerInterface) IsDeprecatedVersionReturns(result1 bool) {
	fake.isDeprecatedVersionMutex.Lock()
	defer fake.isDeprecatedVersionMutex.Unlock()
	fake.IsDeprecatedVersionStub = nil
	fake.isDeprecatedVersionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) IsDeprecatedVersionReturnsOnCall(i int, result1 bool) {
	fake.isDeprecatedVersionMutex.Lock()
	defer fake.isDeprecatedVersionMutex.Unlock()
	fake.IsDeprecatedVersionStub = nil
	if fake.isDeprecatedVersionReturnsOnCall == nil {
		fake.isDeprecatedVersionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDeprecatedVersionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) IsSupportedVersion(arg1 string) bool {
	fake.isSupportedVersionMutex.Lock()
	ret, specificReturn := fake.isSupportedVersionReturnsOnCall[len(fake.isSupportedVersionArgsForCall)]
	fake.isSupportedVersionArgsForCall = append(fake.isSupportedVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsSupportedVersionStub
	fakeReturns := fake.isSupportedVersionReturns
	fake.recordInvocation("IsSupportedVersion", []interface{}{arg1})
	fake.isSupportedVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterVersionsManagerInterface) IsSupportedVersionCallCount() int {
	fake.isSupportedVersionMutex.RLock()
	defer fake.isSupportedVersionMutex.RUnlock()
	return len(fake.isSupportedVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) IsSupportedVersionCalls(stub func(string) bool) {
	fake.isSupportedVersionMutex.Lock()
	defer fake.isSupportedVersionMutex.Unlock()
	fake.IsSupportedVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) IsSupportedVersionArgsForCall(i int) string {
	fake.isSupportedVersionMutex.RLock()
	defer fake.isSupportedVersionMutex.RUnlock()
	argsForCall := fake.isSupportedVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterVersionsManagerInterface) IsSupportedVersionReturns(result1 bool) {
	fake.isSupportedVersionMutex.Lock()
	defer fake.isSupportedVersionMutex.Unlock()
	fake.IsSupportedVersionStub = nil
	fake.isSupportedVersionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) IsSupportedVersionReturnsOnCall(i int, result1 bool) {
	fake.isSupportedVersionMutex.Lock()
	defer fake.isSupportedVersionMutex.Unlock()
	fake.IsSupportedVersionStub = nil
	if fake.isSupportedVersionReturnsOnCall == nil {
		fake.isSupportedVersionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSupportedVersionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) LatestVersion() string {
	fake.latestVersionMutex.Lock()
	ret, specificReturn := fake.latestVersionReturnsOnCall[len(fake.latestVersionArgsForCall)]
	fake.latestVersionArgsForCall = append(fake.latestVersionArgsForCall, struct {
	}{})
	stub := fake.LatestVersionStub
	fakeReturns := fake.latestVersionReturns
	fake.recordInvocation("LatestVersion", []interface{}{})
	fake.latestVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterVersionsManagerInterface) LatestVersionCallCount() int {
	fake.latestVersionMutex.RLock()
	defer fake.latestVersionMutex.RUnlock()
	return len(fake.latestVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) LatestVersionCalls(stub func() string) {
	fake.latestVersionMutex.Lock()
	defer fake.latestVersionMutex.Unlock()
	fake.LatestVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) LatestVersionReturns(result1 string) {
	fake.latestVersionMutex.Lock()
	defer fake.latestVersionMutex.Unlock()
	fake.LatestVersionStub = nil
	fake.latestVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) LatestVersionReturnsOnCall(i int, result1 string) {
	fake.latestVersionMutex.Lock()
	defer fake.latestVersionMutex.Unlock()
	fake.LatestVersionStub = nil
	if fake.latestVersionReturnsOnCall == nil {
		fake.latestVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.latestVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) ResolveClusterVersion(arg1 string) (string, error) {
	fake.resolveClusterVersionMutex.Lock()
	ret, specificReturn := fake.resolveClusterVersionReturnsOnCall[len(fake.resolveClusterVersionArgsForCall)]
	fake.resolveClusterVersionArgsForCall = append(fake.resolveClusterVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResolveClusterVersionStub
	fakeReturns := fake.resolveClusterVersionReturns
	fake.recordInvocation("ResolveClusterVersion", []interface{}{arg1})
	fake.resolveClusterVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterVersionsManagerInterface) ResolveClusterVersionCallCount() int {
	fake.resolveClusterVersionMutex.RLock()
	defer fake.resolveClusterVersionMutex.RUnlock()
	return len(fake.resolveClusterVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) ResolveClusterVersionCalls(stub func(string) (string, error)) {
	fake.resolveClusterVersionMutex.Lock()
	defer fake.resolveClusterVersionMutex.Unlock()
	fake.ResolveClusterVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) ResolveClusterVersionArgsForCall(i int) string {
	fake.resolveClusterVersionMutex.RLock()
	defer fake.resolveClusterVersionMutex.RUnlock()
	argsForCall := fake.resolveClusterVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterVersionsManagerInterface) ResolveClusterVersionReturns(result1 string, result2 error) {
	fake.resolveClusterVersionMutex.Lock()
	defer fake.resolveClusterVersionMutex.Unlock()
	fake.ResolveClusterVersionStub = nil
	fake.resolveClusterVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterVersionsManagerInterface) ResolveClusterVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.resolveClusterVersionMutex.Lock()
	defer fake.resolveClusterVersionMutex.Unlock()
	fake.ResolveClusterVersionStub = nil
	if fake.resolveClusterVersionReturnsOnCall == nil {
		fake.resolveClusterVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.resolveClusterVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterVersionsManagerInterface) ResolveUpgradeVersion(arg1 string, arg2 string) (string, error) {
	fake.resolveUpgradeVersionMutex.Lock()
	ret, specificReturn := fake.resolveUpgradeVersionReturnsOnCall[len(fake.resolveUpgradeVersionArgsForCall)]
	fake.resolveUpgradeVersionArgsForCall = append(fake.resolveUpgradeVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ResolveUpgradeVersionStub
	fakeReturns := fake.resolveUpgradeVersionReturns
	fake.recordInvocation("ResolveUpgradeVersion", []interface{}{arg1, arg2})
	fake.resolveUpgradeVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterVersionsManagerInterface) ResolveUpgradeVersionCallCount() int {
	fake.resolveUpgradeVersionMutex.RLock()
	defer fake.resolveUpgradeVersionMutex.RUnlock()
	return len(fake.resolveUpgradeVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) ResolveUpgradeVersionCalls(stub func(string, string) (string, error)) {
	fake.resolveUpgradeVersionMutex.Lock()
	defer fake.resolveUpgradeVersionMutex.Unlock()
	fake.ResolveUpgradeVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) ResolveUpgradeVersionArgsForCall(i int) (string, string) {
	fake.resolveUpgradeVersionMutex.RLock()
	defer fake.resolveUpgradeVersionMutex.RUnlock()
	argsForCall := fake.resolveUpgradeVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterVersionsManagerInterface) ResolveUpgradeVersionReturns(result1 string, result2 error) {
	fake.resolveUpgradeVersionMutex.Lock()
	defer fake.resolveUpgradeVersionMutex.Unlock()
	fake.ResolveUpgradeVersionStub = nil
	fake.resolveUpgradeVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterVersionsManagerInterface) ResolveUpgradeVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.resolveUpgradeVersionMutex.Lock()
	defer fake.resolveUpgradeVersionMutex.Unlock()
	fake.ResolveUpgradeVersionStub = nil
	if fake.resolveUpgradeVersionReturnsOnCall == nil {
		fake.resolveUpgradeVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.resolveUpgradeVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterVersionsManagerInterface) SupportedVersions() []string {
	fake.supportedVersionsMutex.Lock()
	ret, specificReturn := fake.supportedVersionsReturnsOnCall[len(fake.supportedVersionsArgsForCall)]
	fake.supportedVersionsArgsForCall = append(fake.supportedVersionsArgsForCall, struct {
	}{})
	stub := fake.SupportedVersionsStub
	fakeReturns := fake.supportedVersionsReturns
	fake.recordInvocation("SupportedVersions", []interface{}{})
	fake.supportedVersionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterVersionsManagerInterface) SupportedVersionsCallCount() int {
	fake.supportedVersionsMutex.RLock()
	defer fake.supportedVersionsMutex.RUnlock()
	return len(fake.supportedVersionsArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) SupportedVersionsCalls(stub func() []string) {
	fake.supportedVersionsMutex.Lock()
	defer fake.supportedVersionsMutex.Unlock()
	fake.SupportedVersionsStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) SupportedVersionsReturns(result1 []string) {
	fake.supportedVersionsMutex.Lock()
	defer fake.supportedVersionsMutex.Unlock()
	fake.SupportedVersionsStub = nil
	fake.supportedVersionsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) SupportedVersionsReturnsOnCall(i int, result1 []string) {
	fake.supportedVersionsMutex.Lock()
	defer fake.supportedVersionsMutex.Unlock()
	fake.SupportedVersionsStub = nil
	if fake.supportedVersionsReturnsOnCall == nil {
		fake.supportedVersionsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.supportedVersionsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) ValidateVersion(arg1 string) error {
	fake.validateVersionMutex.Lock()
	ret, specificReturn := fake.validateVersionReturnsOnCall[len(fake.validateVersionArgsForCall)]
	fake.validateVersionArgsForCall = append(fake.validateVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ValidateVersionStub
	fakeReturns := fake.validateVersionReturns
	fake.recordInvocation("ValidateVersion", []interface{}{arg1})
	fake.validateVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterVersionsManagerInterface) ValidateVersionCallCount() int {
	fake.validateVersionMutex.RLock()
	defer fake.validateVersionMutex.RUnlock()
	return len(fake.validateVersionArgsForCall)
}

func (fake *FakeClusterVersionsManagerInterface) ValidateVersionCalls(stub func(string) error) {
	fake.validateVersionMutex.Lock()
	defer fake.validateVersionMutex.Unlock()
	fake.ValidateVersionStub = stub
}

func (fake *FakeClusterVersionsManagerInterface) ValidateVersionArgsForCall(i int) string {
	fake.validateVersionMutex.RLock()
	defer fake.validateVersionMutex.RUnlock()
	argsForCall := fake.validateVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterVersionsManagerInterface) ValidateVersionReturns(result1 error) {
	fake.validateVersionMutex.Lock()
	defer fake.validateVersionMutex.Unlock()
	fake.ValidateVersionStub = nil
	fake.validateVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) ValidateVersionReturnsOnCall(i int, result1 error) {
	fake.validateVersionMutex.Lock()
	defer fake.validateVersionMutex.Unlock()
	fake.ValidateVersionStub = nil
	if fake.validateVersionReturnsOnCall == nil {
		fake.validateVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterVersionsManagerInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.defaultVersionMutex.RLock()
	defer fake.defaultVersionMutex.RUnlock()
	fake.isDeprecatedVersionMutex.RLock()
	defer fake.isDeprecatedVersionMutex.RUnlock()
	fake.isSupportedVersionMutex.RLock()
	defer fake.isSupportedVersionMutex.RUnlock()
	fake.latestVersionMutex.RLock()
	defer fake.latestVersionMutex.RUnlock()
	fake.resolveClusterVersionMutex.RLock()
	defer fake.resolveClusterVersionMutex.RUnlock()
	fake.resolveUpgradeVersionMutex.RLock()
	defer fake.resolveUpgradeVersionMutex.RUnlock()
	fake.supportedVersionsMutex.RLock()
	defer fake.supportedVersionsMutex.RUnlock()
	fake.validateVersionMutex.RLock()
	defer fake.validateVersionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClusterVersionsManagerInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ eks.ClusterVersionsManagerInterface = new(FakeClusterVersionsManagerInterface)
