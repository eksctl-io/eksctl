// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocksv2

import (
	context "context"

	elasticloadbalancing "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancing"
	mock "github.com/stretchr/testify/mock"
)

// ELB is an autogenerated mock type for the ELB type
type ELB struct {
	mock.Mock
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) AddTags(ctx context.Context, params *elasticloadbalancing.AddTagsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.AddTagsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.AddTagsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.AddTagsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.AddTagsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplySecurityGroupsToLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) ApplySecurityGroupsToLoadBalancer(ctx context.Context, params *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.ApplySecurityGroupsToLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.ApplySecurityGroupsToLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachLoadBalancerToSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) AttachLoadBalancerToSubnets(ctx context.Context, params *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.AttachLoadBalancerToSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.AttachLoadBalancerToSubnetsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.AttachLoadBalancerToSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.AttachLoadBalancerToSubnetsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.AttachLoadBalancerToSubnetsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfigureHealthCheck provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) ConfigureHealthCheck(ctx context.Context, params *elasticloadbalancing.ConfigureHealthCheckInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ConfigureHealthCheckOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.ConfigureHealthCheckOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ConfigureHealthCheckInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.ConfigureHealthCheckOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.ConfigureHealthCheckOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.ConfigureHealthCheckInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAppCookieStickinessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateAppCookieStickinessPolicy(ctx context.Context, params *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateAppCookieStickinessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.CreateAppCookieStickinessPolicyOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateAppCookieStickinessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateAppCookieStickinessPolicyOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateAppCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLBCookieStickinessPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLBCookieStickinessPolicy(ctx context.Context, params *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLBCookieStickinessPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.CreateLBCookieStickinessPolicyOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLBCookieStickinessPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLBCookieStickinessPolicyOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLBCookieStickinessPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLoadBalancer(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.CreateLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoadBalancerListeners provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLoadBalancerListeners(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerListenersInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.CreateLoadBalancerListenersOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLoadBalancerListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLoadBalancerListenersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoadBalancerPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) CreateLoadBalancerPolicy(ctx context.Context, params *elasticloadbalancing.CreateLoadBalancerPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.CreateLoadBalancerPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.CreateLoadBalancerPolicyOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.CreateLoadBalancerPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.CreateLoadBalancerPolicyOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.CreateLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeleteLoadBalancer(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DeleteLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeleteLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeleteLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoadBalancerListeners provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeleteLoadBalancerListeners(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerListenersInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DeleteLoadBalancerListenersOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeleteLoadBalancerListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeleteLoadBalancerListenersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerListenersInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoadBalancerPolicy provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeleteLoadBalancerPolicy(ctx context.Context, params *elasticloadbalancing.DeleteLoadBalancerPolicyInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeleteLoadBalancerPolicyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DeleteLoadBalancerPolicyOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeleteLoadBalancerPolicyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeleteLoadBalancerPolicyOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeleteLoadBalancerPolicyInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterInstancesFromLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DeregisterInstancesFromLoadBalancer(ctx context.Context, params *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DeregisterInstancesFromLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DeregisterInstancesFromLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountLimits provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeAccountLimits(ctx context.Context, params *elasticloadbalancing.DescribeAccountLimitsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeAccountLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeAccountLimitsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeAccountLimitsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeAccountLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeAccountLimitsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeAccountLimitsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceHealth provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeInstanceHealth(ctx context.Context, params *elasticloadbalancing.DescribeInstanceHealthInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeInstanceHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeInstanceHealthOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeInstanceHealthInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeInstanceHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeInstanceHealthOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeInstanceHealthInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeLoadBalancerAttributesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancerAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancerPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancerPolicies(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeLoadBalancerPoliciesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancerPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancerPoliciesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPoliciesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancerPolicyTypes provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancerPolicyTypes(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancerPolicyTypesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancerPolicyTypesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeLoadBalancers(ctx context.Context, params *elasticloadbalancing.DescribeLoadBalancersInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeLoadBalancersOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancersInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeLoadBalancersOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeLoadBalancersInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DescribeTags(ctx context.Context, params *elasticloadbalancing.DescribeTagsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DescribeTagsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DescribeTagsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DescribeTagsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DescribeTagsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachLoadBalancerFromSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DetachLoadBalancerFromSubnets(ctx context.Context, params *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DetachLoadBalancerFromSubnetsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DetachLoadBalancerFromSubnetsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableAvailabilityZonesForLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) DisableAvailabilityZonesForLoadBalancer(ctx context.Context, params *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.DisableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableAvailabilityZonesForLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) EnableAvailabilityZonesForLoadBalancer(ctx context.Context, params *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.EnableAvailabilityZonesForLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) ModifyLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancing.ModifyLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.ModifyLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.ModifyLoadBalancerAttributesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.ModifyLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.ModifyLoadBalancerAttributesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterInstancesWithLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) RegisterInstancesWithLoadBalancer(ctx context.Context, params *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.RegisterInstancesWithLoadBalancerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.RegisterInstancesWithLoadBalancerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) RemoveTags(ctx context.Context, params *elasticloadbalancing.RemoveTagsInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.RemoveTagsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.RemoveTagsInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.RemoveTagsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.RemoveTagsInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLoadBalancerListenerSSLCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) SetLoadBalancerListenerSSLCertificate(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.SetLoadBalancerListenerSSLCertificateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.SetLoadBalancerListenerSSLCertificateInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLoadBalancerPoliciesForBackendServer provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) SetLoadBalancerPoliciesForBackendServer(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesForBackendServerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLoadBalancerPoliciesOfListener provides a mock function with given fields: ctx, params, optFns
func (_m *ELB) SetLoadBalancerPoliciesOfListener(ctx context.Context, params *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, optFns ...func(*elasticloadbalancing.Options)) (*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, ...func(*elasticloadbalancing.Options)) *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancing.SetLoadBalancerPoliciesOfListenerOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancing.SetLoadBalancerPoliciesOfListenerInput, ...func(*elasticloadbalancing.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
