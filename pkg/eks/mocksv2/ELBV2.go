// Code generated by mockery v2.35.3. DO NOT EDIT.

package mocksv2

import (
	context "context"

	elasticloadbalancingv2 "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2"
	mock "github.com/stretchr/testify/mock"
)

// ELBV2 is an autogenerated mock type for the ELBV2 type
type ELBV2 struct {
	mock.Mock
}

// AddListenerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) AddListenerCertificates(ctx context.Context, params *elasticloadbalancingv2.AddListenerCertificatesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddListenerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.AddListenerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddListenerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.AddListenerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.AddListenerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.AddListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) AddTags(ctx context.Context, params *elasticloadbalancingv2.AddTagsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.AddTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddTagsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.AddTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.AddTagsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.AddTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.AddTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.AddTagsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateListener provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) CreateListener(ctx context.Context, params *elasticloadbalancingv2.CreateListenerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.CreateListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateListenerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateListenerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateListenerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) CreateLoadBalancer(ctx context.Context, params *elasticloadbalancingv2.CreateLoadBalancerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.CreateLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRule provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) CreateRule(ctx context.Context, params *elasticloadbalancingv2.CreateRuleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.CreateRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateRuleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateRuleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateRuleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTargetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) CreateTargetGroup(ctx context.Context, params *elasticloadbalancingv2.CreateTargetGroupInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateTargetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.CreateTargetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.CreateTargetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.CreateTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.CreateTargetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.CreateTargetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.CreateTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteListener provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DeleteListener(ctx context.Context, params *elasticloadbalancingv2.DeleteListenerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DeleteListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteListenerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteListenerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteListenerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLoadBalancer provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DeleteLoadBalancer(ctx context.Context, params *elasticloadbalancingv2.DeleteLoadBalancerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteLoadBalancerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DeleteLoadBalancerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteLoadBalancerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteLoadBalancerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteLoadBalancerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteLoadBalancerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DeleteRule(ctx context.Context, params *elasticloadbalancingv2.DeleteRuleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DeleteRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteRuleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteRuleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteRuleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTargetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DeleteTargetGroup(ctx context.Context, params *elasticloadbalancingv2.DeleteTargetGroupInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteTargetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DeleteTargetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeleteTargetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeleteTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeleteTargetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeleteTargetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeleteTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTargets provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DeregisterTargets(ctx context.Context, params *elasticloadbalancingv2.DeregisterTargetsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeregisterTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DeregisterTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeregisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DeregisterTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DeregisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DeregisterTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DeregisterTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DeregisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountLimits provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeAccountLimits(ctx context.Context, params *elasticloadbalancingv2.DescribeAccountLimitsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeAccountLimitsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeAccountLimitsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeAccountLimitsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeAccountLimitsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeAccountLimitsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeAccountLimitsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeAccountLimitsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeAccountLimitsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeListenerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeListenerCertificates(ctx context.Context, params *elasticloadbalancingv2.DescribeListenerCertificatesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeListenerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeListenerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeListenerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeListeners provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeListeners(ctx context.Context, params *elasticloadbalancingv2.DescribeListenersInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeListenersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenersInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeListenersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeListenersInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeListenersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeListenersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeListenersInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeLoadBalancerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLoadBalancers provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeLoadBalancers(ctx context.Context, params *elasticloadbalancingv2.DescribeLoadBalancersInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeLoadBalancersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancersInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeLoadBalancersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancersInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeLoadBalancersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeLoadBalancersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeLoadBalancersInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRules provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeRules(ctx context.Context, params *elasticloadbalancingv2.DescribeRulesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeRulesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeRulesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeRulesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSSLPolicies provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeSSLPolicies(ctx context.Context, params *elasticloadbalancingv2.DescribeSSLPoliciesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeSSLPoliciesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeSSLPoliciesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeSSLPoliciesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeSSLPoliciesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeSSLPoliciesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeSSLPoliciesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeSSLPoliciesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeSSLPoliciesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeTags(ctx context.Context, params *elasticloadbalancingv2.DescribeTagsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTagsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTagsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTagsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetGroupAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeTargetGroupAttributes(ctx context.Context, params *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeTargetGroupAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTargetGroupAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTargetGroupAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetGroups provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeTargetGroups(ctx context.Context, params *elasticloadbalancingv2.DescribeTargetGroupsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeTargetGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTargetGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTargetGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTargetGroupsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTargetHealth provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) DescribeTargetHealth(ctx context.Context, params *elasticloadbalancingv2.DescribeTargetHealthInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetHealthOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.DescribeTargetHealthOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetHealthInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.DescribeTargetHealthOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.DescribeTargetHealthInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.DescribeTargetHealthOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.DescribeTargetHealthOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.DescribeTargetHealthInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyListener provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) ModifyListener(ctx context.Context, params *elasticloadbalancingv2.ModifyListenerInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyListenerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.ModifyListenerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyListenerInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyListenerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyListenerInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyListenerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyListenerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyListenerInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLoadBalancerAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) ModifyLoadBalancerAttributes(ctx context.Context, params *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyLoadBalancerAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyLoadBalancerAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyRule provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) ModifyRule(ctx context.Context, params *elasticloadbalancingv2.ModifyRuleInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.ModifyRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyRuleInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyRuleInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyRuleInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTargetGroup provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) ModifyTargetGroup(ctx context.Context, params *elasticloadbalancingv2.ModifyTargetGroupInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.ModifyTargetGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyTargetGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyTargetGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTargetGroupAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) ModifyTargetGroupAttributes(ctx context.Context, params *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.ModifyTargetGroupAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.ModifyTargetGroupAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.ModifyTargetGroupAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.ModifyTargetGroupAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.ModifyTargetGroupAttributesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTargets provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) RegisterTargets(ctx context.Context, params *elasticloadbalancingv2.RegisterTargetsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RegisterTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.RegisterTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RegisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RegisterTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RegisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RegisterTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RegisterTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RegisterTargetsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveListenerCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) RemoveListenerCertificates(ctx context.Context, params *elasticloadbalancingv2.RemoveListenerCertificatesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveListenerCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.RemoveListenerCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveListenerCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RemoveListenerCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RemoveListenerCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RemoveListenerCertificatesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTags provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) RemoveTags(ctx context.Context, params *elasticloadbalancingv2.RemoveTagsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.RemoveTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveTagsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.RemoveTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.RemoveTagsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.RemoveTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.RemoveTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.RemoveTagsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetIpAddressType provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) SetIpAddressType(ctx context.Context, params *elasticloadbalancingv2.SetIpAddressTypeInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetIpAddressTypeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.SetIpAddressTypeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetIpAddressTypeInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetIpAddressTypeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetIpAddressTypeInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetIpAddressTypeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetIpAddressTypeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetIpAddressTypeInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRulePriorities provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) SetRulePriorities(ctx context.Context, params *elasticloadbalancingv2.SetRulePrioritiesInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetRulePrioritiesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.SetRulePrioritiesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetRulePrioritiesInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetRulePrioritiesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetRulePrioritiesInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetRulePrioritiesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetRulePrioritiesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetRulePrioritiesInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) SetSecurityGroups(ctx context.Context, params *elasticloadbalancingv2.SetSecurityGroupsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.SetSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSecurityGroupsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSecurityGroupsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetSecurityGroupsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *ELBV2) SetSubnets(ctx context.Context, params *elasticloadbalancingv2.SetSubnetsInput, optFns ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *elasticloadbalancingv2.SetSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSubnetsInput, ...func(*elasticloadbalancingv2.Options)) (*elasticloadbalancingv2.SetSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *elasticloadbalancingv2.SetSubnetsInput, ...func(*elasticloadbalancingv2.Options)) *elasticloadbalancingv2.SetSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*elasticloadbalancingv2.SetSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *elasticloadbalancingv2.SetSubnetsInput, ...func(*elasticloadbalancingv2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewELBV2 creates a new instance of ELBV2. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewELBV2(t interface {
	mock.TestingT
	Cleanup(func())
}) *ELBV2 {
	mock := &ELBV2{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
