// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	typesa "github.com/aws/aws-sdk-go-v2/service/autoscaling/types"
	"github.com/aws/aws-sdk-go-v2/service/cloudformation"
	"github.com/aws/aws-sdk-go-v2/service/cloudformation/types"
	typesb "github.com/aws/aws-sdk-go-v2/service/cloudtrail/types"
	typesc "github.com/aws/aws-sdk-go-v2/service/eks/types"
	"github.com/weaveworks/eksctl/pkg/actions/accessentry"
	"github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
	"github.com/weaveworks/eksctl/pkg/cfn/builder"
	"github.com/weaveworks/eksctl/pkg/cfn/manager"
	iamoidc "github.com/weaveworks/eksctl/pkg/iam/oidc"
	"github.com/weaveworks/eksctl/pkg/kubernetes"
	"github.com/weaveworks/eksctl/pkg/utils/tasks"
	"github.com/weaveworks/eksctl/pkg/vpc"
)

type FakeStackManager struct {
	AppendNewClusterStackResourceStub        func(context.Context, bool, bool) (bool, error)
	appendNewClusterStackResourceMutex       sync.RWMutex
	appendNewClusterStackResourceArgsForCall []struct {
		arg1 context.Context
		arg2 bool
		arg3 bool
	}
	appendNewClusterStackResourceReturns struct {
		result1 bool
		result2 error
	}
	appendNewClusterStackResourceReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ClusterHasDedicatedVPCStub        func(context.Context) (bool, error)
	clusterHasDedicatedVPCMutex       sync.RWMutex
	clusterHasDedicatedVPCArgsForCall []struct {
		arg1 context.Context
	}
	clusterHasDedicatedVPCReturns struct {
		result1 bool
		result2 error
	}
	clusterHasDedicatedVPCReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateStackStub        func(context.Context, string, builder.ResourceSetReader, map[string]string, map[string]string, chan error) error
	createStackMutex       sync.RWMutex
	createStackArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 builder.ResourceSetReader
		arg4 map[string]string
		arg5 map[string]string
		arg6 chan error
	}
	createStackReturns struct {
		result1 error
	}
	createStackReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStackBySpecStub        func(context.Context, *types.Stack) (*types.Stack, error)
	deleteStackBySpecMutex       sync.RWMutex
	deleteStackBySpecArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	deleteStackBySpecReturns struct {
		result1 *types.Stack
		result2 error
	}
	deleteStackBySpecReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	DeleteStackBySpecSyncStub        func(context.Context, *types.Stack, chan error) error
	deleteStackBySpecSyncMutex       sync.RWMutex
	deleteStackBySpecSyncArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 chan error
	}
	deleteStackBySpecSyncReturns struct {
		result1 error
	}
	deleteStackBySpecSyncReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStackSyncStub        func(context.Context, *types.Stack) error
	deleteStackSyncMutex       sync.RWMutex
	deleteStackSyncArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	deleteStackSyncReturns struct {
		result1 error
	}
	deleteStackSyncReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTasksForDeprecatedStacksStub        func(context.Context) (*tasks.TaskTree, error)
	deleteTasksForDeprecatedStacksMutex       sync.RWMutex
	deleteTasksForDeprecatedStacksArgsForCall []struct {
		arg1 context.Context
	}
	deleteTasksForDeprecatedStacksReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	deleteTasksForDeprecatedStacksReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	DescribeClusterStackStub        func(context.Context) (*types.Stack, error)
	describeClusterStackMutex       sync.RWMutex
	describeClusterStackArgsForCall []struct {
		arg1 context.Context
	}
	describeClusterStackReturns struct {
		result1 *types.Stack
		result2 error
	}
	describeClusterStackReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	DescribeClusterStackIfExistsStub        func(context.Context) (*types.Stack, error)
	describeClusterStackIfExistsMutex       sync.RWMutex
	describeClusterStackIfExistsArgsForCall []struct {
		arg1 context.Context
	}
	describeClusterStackIfExistsReturns struct {
		result1 *types.Stack
		result2 error
	}
	describeClusterStackIfExistsReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	DescribeIAMServiceAccountStacksStub        func(context.Context) ([]*types.Stack, error)
	describeIAMServiceAccountStacksMutex       sync.RWMutex
	describeIAMServiceAccountStacksArgsForCall []struct {
		arg1 context.Context
	}
	describeIAMServiceAccountStacksReturns struct {
		result1 []*types.Stack
		result2 error
	}
	describeIAMServiceAccountStacksReturnsOnCall map[int]struct {
		result1 []*types.Stack
		result2 error
	}
	DescribeNodeGroupStackStub        func(context.Context, string) (*types.Stack, error)
	describeNodeGroupStackMutex       sync.RWMutex
	describeNodeGroupStackArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	describeNodeGroupStackReturns struct {
		result1 *types.Stack
		result2 error
	}
	describeNodeGroupStackReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	DescribeNodeGroupStacksAndResourcesStub        func(context.Context) (map[string]manager.StackInfo, error)
	describeNodeGroupStacksAndResourcesMutex       sync.RWMutex
	describeNodeGroupStacksAndResourcesArgsForCall []struct {
		arg1 context.Context
	}
	describeNodeGroupStacksAndResourcesReturns struct {
		result1 map[string]manager.StackInfo
		result2 error
	}
	describeNodeGroupStacksAndResourcesReturnsOnCall map[int]struct {
		result1 map[string]manager.StackInfo
		result2 error
	}
	DescribeStackStub        func(context.Context, *types.Stack) (*types.Stack, error)
	describeStackMutex       sync.RWMutex
	describeStackArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	describeStackReturns struct {
		result1 *types.Stack
		result2 error
	}
	describeStackReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	DescribeStackChangeSetStub        func(context.Context, *types.Stack, string) (*cloudformation.DescribeChangeSetOutput, error)
	describeStackChangeSetMutex       sync.RWMutex
	describeStackChangeSetArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 string
	}
	describeStackChangeSetReturns struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}
	describeStackChangeSetReturnsOnCall map[int]struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}
	DescribeStackEventsStub        func(context.Context, *types.Stack) ([]types.StackEvent, error)
	describeStackEventsMutex       sync.RWMutex
	describeStackEventsArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	describeStackEventsReturns struct {
		result1 []types.StackEvent
		result2 error
	}
	describeStackEventsReturnsOnCall map[int]struct {
		result1 []types.StackEvent
		result2 error
	}
	DoCreateStackRequestStub        func(context.Context, *types.Stack, manager.TemplateData, map[string]string, map[string]string, bool, bool) error
	doCreateStackRequestMutex       sync.RWMutex
	doCreateStackRequestArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 manager.TemplateData
		arg4 map[string]string
		arg5 map[string]string
		arg6 bool
		arg7 bool
	}
	doCreateStackRequestReturns struct {
		result1 error
	}
	doCreateStackRequestReturnsOnCall map[int]struct {
		result1 error
	}
	DoWaitUntilStackIsCreatedStub        func(context.Context, *types.Stack) error
	doWaitUntilStackIsCreatedMutex       sync.RWMutex
	doWaitUntilStackIsCreatedArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	doWaitUntilStackIsCreatedReturns struct {
		result1 error
	}
	doWaitUntilStackIsCreatedReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureMapPublicIPOnLaunchEnabledStub        func(context.Context) error
	ensureMapPublicIPOnLaunchEnabledMutex       sync.RWMutex
	ensureMapPublicIPOnLaunchEnabledArgsForCall []struct {
		arg1 context.Context
	}
	ensureMapPublicIPOnLaunchEnabledReturns struct {
		result1 error
	}
	ensureMapPublicIPOnLaunchEnabledReturnsOnCall map[int]struct {
		result1 error
	}
	FixClusterCompatibilityStub        func(context.Context) error
	fixClusterCompatibilityMutex       sync.RWMutex
	fixClusterCompatibilityArgsForCall []struct {
		arg1 context.Context
	}
	fixClusterCompatibilityReturns struct {
		result1 error
	}
	fixClusterCompatibilityReturnsOnCall map[int]struct {
		result1 error
	}
	GetAutoScalingGroupDesiredCapacityStub        func(context.Context, string) (typesa.AutoScalingGroup, error)
	getAutoScalingGroupDesiredCapacityMutex       sync.RWMutex
	getAutoScalingGroupDesiredCapacityArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getAutoScalingGroupDesiredCapacityReturns struct {
		result1 typesa.AutoScalingGroup
		result2 error
	}
	getAutoScalingGroupDesiredCapacityReturnsOnCall map[int]struct {
		result1 typesa.AutoScalingGroup
		result2 error
	}
	GetAutoScalingGroupNameStub        func(context.Context, *types.Stack) (string, error)
	getAutoScalingGroupNameMutex       sync.RWMutex
	getAutoScalingGroupNameArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	getAutoScalingGroupNameReturns struct {
		result1 string
		result2 error
	}
	getAutoScalingGroupNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetClusterStackIfExistsStub        func(context.Context) (*types.Stack, error)
	getClusterStackIfExistsMutex       sync.RWMutex
	getClusterStackIfExistsArgsForCall []struct {
		arg1 context.Context
	}
	getClusterStackIfExistsReturns struct {
		result1 *types.Stack
		result2 error
	}
	getClusterStackIfExistsReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	GetFargateStackStub        func(context.Context) (*types.Stack, error)
	getFargateStackMutex       sync.RWMutex
	getFargateStackArgsForCall []struct {
		arg1 context.Context
	}
	getFargateStackReturns struct {
		result1 *types.Stack
		result2 error
	}
	getFargateStackReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	GetIAMAddonNameStub        func(*types.Stack) string
	getIAMAddonNameMutex       sync.RWMutex
	getIAMAddonNameArgsForCall []struct {
		arg1 *types.Stack
	}
	getIAMAddonNameReturns struct {
		result1 string
	}
	getIAMAddonNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetIAMAddonsStacksStub        func(context.Context) ([]*types.Stack, error)
	getIAMAddonsStacksMutex       sync.RWMutex
	getIAMAddonsStacksArgsForCall []struct {
		arg1 context.Context
	}
	getIAMAddonsStacksReturns struct {
		result1 []*types.Stack
		result2 error
	}
	getIAMAddonsStacksReturnsOnCall map[int]struct {
		result1 []*types.Stack
		result2 error
	}
	GetIAMServiceAccountsStub        func(context.Context) ([]*v1alpha5.ClusterIAMServiceAccount, error)
	getIAMServiceAccountsMutex       sync.RWMutex
	getIAMServiceAccountsArgsForCall []struct {
		arg1 context.Context
	}
	getIAMServiceAccountsReturns struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}
	getIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}
	GetKarpenterStackStub        func(context.Context) (*types.Stack, error)
	getKarpenterStackMutex       sync.RWMutex
	getKarpenterStackArgsForCall []struct {
		arg1 context.Context
	}
	getKarpenterStackReturns struct {
		result1 *types.Stack
		result2 error
	}
	getKarpenterStackReturnsOnCall map[int]struct {
		result1 *types.Stack
		result2 error
	}
	GetManagedNodeGroupTemplateStub        func(context.Context, manager.GetNodegroupOption) (string, error)
	getManagedNodeGroupTemplateMutex       sync.RWMutex
	getManagedNodeGroupTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 manager.GetNodegroupOption
	}
	getManagedNodeGroupTemplateReturns struct {
		result1 string
		result2 error
	}
	getManagedNodeGroupTemplateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetNodeGroupNameStub        func(*types.Stack) string
	getNodeGroupNameMutex       sync.RWMutex
	getNodeGroupNameArgsForCall []struct {
		arg1 *types.Stack
	}
	getNodeGroupNameReturns struct {
		result1 string
	}
	getNodeGroupNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetNodeGroupStackTypeStub        func(context.Context, manager.GetNodegroupOption) (v1alpha5.NodeGroupType, error)
	getNodeGroupStackTypeMutex       sync.RWMutex
	getNodeGroupStackTypeArgsForCall []struct {
		arg1 context.Context
		arg2 manager.GetNodegroupOption
	}
	getNodeGroupStackTypeReturns struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}
	getNodeGroupStackTypeReturnsOnCall map[int]struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}
	GetStackTemplateStub        func(context.Context, string) (string, error)
	getStackTemplateMutex       sync.RWMutex
	getStackTemplateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getStackTemplateReturns struct {
		result1 string
		result2 error
	}
	getStackTemplateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetUnmanagedNodeGroupAutoScalingGroupNameStub        func(context.Context, *types.Stack) (string, error)
	getUnmanagedNodeGroupAutoScalingGroupNameMutex       sync.RWMutex
	getUnmanagedNodeGroupAutoScalingGroupNameArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	getUnmanagedNodeGroupAutoScalingGroupNameReturns struct {
		result1 string
		result2 error
	}
	getUnmanagedNodeGroupAutoScalingGroupNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HasClusterStackFromListStub        func(context.Context, []string, string) (bool, error)
	hasClusterStackFromListMutex       sync.RWMutex
	hasClusterStackFromListArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 string
	}
	hasClusterStackFromListReturns struct {
		result1 bool
		result2 error
	}
	hasClusterStackFromListReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ListAccessEntryStackNamesStub        func(context.Context, string) ([]string, error)
	listAccessEntryStackNamesMutex       sync.RWMutex
	listAccessEntryStackNamesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	listAccessEntryStackNamesReturns struct {
		result1 []string
		result2 error
	}
	listAccessEntryStackNamesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListClusterStackNamesStub        func(context.Context) ([]string, error)
	listClusterStackNamesMutex       sync.RWMutex
	listClusterStackNamesArgsForCall []struct {
		arg1 context.Context
	}
	listClusterStackNamesReturns struct {
		result1 []string
		result2 error
	}
	listClusterStackNamesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListIAMServiceAccountStacksStub        func(context.Context) ([]string, error)
	listIAMServiceAccountStacksMutex       sync.RWMutex
	listIAMServiceAccountStacksArgsForCall []struct {
		arg1 context.Context
	}
	listIAMServiceAccountStacksReturns struct {
		result1 []string
		result2 error
	}
	listIAMServiceAccountStacksReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListNodeGroupStacksStub        func(context.Context) ([]*types.Stack, error)
	listNodeGroupStacksMutex       sync.RWMutex
	listNodeGroupStacksArgsForCall []struct {
		arg1 context.Context
	}
	listNodeGroupStacksReturns struct {
		result1 []*types.Stack
		result2 error
	}
	listNodeGroupStacksReturnsOnCall map[int]struct {
		result1 []*types.Stack
		result2 error
	}
	ListNodeGroupStacksWithStatusesStub        func(context.Context) ([]manager.NodeGroupStack, error)
	listNodeGroupStacksWithStatusesMutex       sync.RWMutex
	listNodeGroupStacksWithStatusesArgsForCall []struct {
		arg1 context.Context
	}
	listNodeGroupStacksWithStatusesReturns struct {
		result1 []manager.NodeGroupStack
		result2 error
	}
	listNodeGroupStacksWithStatusesReturnsOnCall map[int]struct {
		result1 []manager.NodeGroupStack
		result2 error
	}
	ListPodIdentityStackNamesStub        func(context.Context) ([]string, error)
	listPodIdentityStackNamesMutex       sync.RWMutex
	listPodIdentityStackNamesArgsForCall []struct {
		arg1 context.Context
	}
	listPodIdentityStackNamesReturns struct {
		result1 []string
		result2 error
	}
	listPodIdentityStackNamesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListStackNamesStub        func(context.Context, string) ([]string, error)
	listStackNamesMutex       sync.RWMutex
	listStackNamesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	listStackNamesReturns struct {
		result1 []string
		result2 error
	}
	listStackNamesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ListStacksStub        func(context.Context) ([]*types.Stack, error)
	listStacksMutex       sync.RWMutex
	listStacksArgsForCall []struct {
		arg1 context.Context
	}
	listStacksReturns struct {
		result1 []*types.Stack
		result2 error
	}
	listStacksReturnsOnCall map[int]struct {
		result1 []*types.Stack
		result2 error
	}
	ListStacksMatchingStub        func(context.Context, string, ...types.StackStatus) ([]*types.Stack, error)
	listStacksMatchingMutex       sync.RWMutex
	listStacksMatchingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []types.StackStatus
	}
	listStacksMatchingReturns struct {
		result1 []*types.Stack
		result2 error
	}
	listStacksMatchingReturnsOnCall map[int]struct {
		result1 []*types.Stack
		result2 error
	}
	ListStacksWithStatusesStub        func(context.Context, ...types.StackStatus) ([]*types.Stack, error)
	listStacksWithStatusesMutex       sync.RWMutex
	listStacksWithStatusesArgsForCall []struct {
		arg1 context.Context
		arg2 []types.StackStatus
	}
	listStacksWithStatusesReturns struct {
		result1 []*types.Stack
		result2 error
	}
	listStacksWithStatusesReturnsOnCall map[int]struct {
		result1 []*types.Stack
		result2 error
	}
	LookupCloudTrailEventsStub        func(context.Context, *types.Stack) ([]typesb.Event, error)
	lookupCloudTrailEventsMutex       sync.RWMutex
	lookupCloudTrailEventsArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
	}
	lookupCloudTrailEventsReturns struct {
		result1 []typesb.Event
		result2 error
	}
	lookupCloudTrailEventsReturnsOnCall map[int]struct {
		result1 []typesb.Event
		result2 error
	}
	MakeChangeSetNameStub        func(string) string
	makeChangeSetNameMutex       sync.RWMutex
	makeChangeSetNameArgsForCall []struct {
		arg1 string
	}
	makeChangeSetNameReturns struct {
		result1 string
	}
	makeChangeSetNameReturnsOnCall map[int]struct {
		result1 string
	}
	MakeClusterStackNameStub        func() string
	makeClusterStackNameMutex       sync.RWMutex
	makeClusterStackNameArgsForCall []struct {
	}
	makeClusterStackNameReturns struct {
		result1 string
	}
	makeClusterStackNameReturnsOnCall map[int]struct {
		result1 string
	}
	MustUpdateStackStub        func(context.Context, manager.UpdateStackOptions) error
	mustUpdateStackMutex       sync.RWMutex
	mustUpdateStackArgsForCall []struct {
		arg1 context.Context
		arg2 manager.UpdateStackOptions
	}
	mustUpdateStackReturns struct {
		result1 error
	}
	mustUpdateStackReturnsOnCall map[int]struct {
		result1 error
	}
	NewManagedNodeGroupTaskStub        func(context.Context, []*v1alpha5.ManagedNodeGroup, bool, vpc.Importer) *tasks.TaskTree
	newManagedNodeGroupTaskMutex       sync.RWMutex
	newManagedNodeGroupTaskArgsForCall []struct {
		arg1 context.Context
		arg2 []*v1alpha5.ManagedNodeGroup
		arg3 bool
		arg4 vpc.Importer
	}
	newManagedNodeGroupTaskReturns struct {
		result1 *tasks.TaskTree
	}
	newManagedNodeGroupTaskReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	NewTaskToDeleteUnownedNodeGroupStub        func(context.Context, string, string, manager.NodeGroupDeleter, *manager.DeleteWaitCondition) tasks.Task
	newTaskToDeleteUnownedNodeGroupMutex       sync.RWMutex
	newTaskToDeleteUnownedNodeGroupArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 manager.NodeGroupDeleter
		arg5 *manager.DeleteWaitCondition
	}
	newTaskToDeleteUnownedNodeGroupReturns struct {
		result1 tasks.Task
	}
	newTaskToDeleteUnownedNodeGroupReturnsOnCall map[int]struct {
		result1 tasks.Task
	}
	NewTasksToCreateClusterStub        func(context.Context, []*v1alpha5.NodeGroup, []*v1alpha5.ManagedNodeGroup, []v1alpha5.AccessEntry, accessentry.CreatorInterface, ...tasks.Task) *tasks.TaskTree
	newTasksToCreateClusterMutex       sync.RWMutex
	newTasksToCreateClusterArgsForCall []struct {
		arg1 context.Context
		arg2 []*v1alpha5.NodeGroup
		arg3 []*v1alpha5.ManagedNodeGroup
		arg4 []v1alpha5.AccessEntry
		arg5 accessentry.CreatorInterface
		arg6 []tasks.Task
	}
	newTasksToCreateClusterReturns struct {
		result1 *tasks.TaskTree
	}
	newTasksToCreateClusterReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	NewTasksToCreateIAMServiceAccountsStub        func([]*v1alpha5.ClusterIAMServiceAccount, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) *tasks.TaskTree
	newTasksToCreateIAMServiceAccountsMutex       sync.RWMutex
	newTasksToCreateIAMServiceAccountsArgsForCall []struct {
		arg1 []*v1alpha5.ClusterIAMServiceAccount
		arg2 *iamoidc.OpenIDConnectManager
		arg3 kubernetes.ClientSetGetter
	}
	newTasksToCreateIAMServiceAccountsReturns struct {
		result1 *tasks.TaskTree
	}
	newTasksToCreateIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	NewTasksToDeleteClusterWithNodeGroupsStub        func(context.Context, *types.Stack, []manager.NodeGroupStack, bool, manager.NewOIDCManager, manager.NewTasksToDeleteAddonIAM, manager.NewTasksToDeletePodIdentityRole, *typesc.Cluster, kubernetes.ClientSetGetter, bool, bool, func(chan error, string) error) (*tasks.TaskTree, error)
	newTasksToDeleteClusterWithNodeGroupsMutex       sync.RWMutex
	newTasksToDeleteClusterWithNodeGroupsArgsForCall []struct {
		arg1  context.Context
		arg2  *types.Stack
		arg3  []manager.NodeGroupStack
		arg4  bool
		arg5  manager.NewOIDCManager
		arg6  manager.NewTasksToDeleteAddonIAM
		arg7  manager.NewTasksToDeletePodIdentityRole
		arg8  *typesc.Cluster
		arg9  kubernetes.ClientSetGetter
		arg10 bool
		arg11 bool
		arg12 func(chan error, string) error
	}
	newTasksToDeleteClusterWithNodeGroupsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteClusterWithNodeGroupsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToDeleteIAMServiceAccountsStub        func(context.Context, []string, kubernetes.ClientSetGetter, bool) (*tasks.TaskTree, error)
	newTasksToDeleteIAMServiceAccountsMutex       sync.RWMutex
	newTasksToDeleteIAMServiceAccountsArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 kubernetes.ClientSetGetter
		arg4 bool
	}
	newTasksToDeleteIAMServiceAccountsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToDeleteNodeGroupsStub        func([]manager.NodeGroupStack, func(_ string) bool, bool, func(chan error, string) error) (*tasks.TaskTree, error)
	newTasksToDeleteNodeGroupsMutex       sync.RWMutex
	newTasksToDeleteNodeGroupsArgsForCall []struct {
		arg1 []manager.NodeGroupStack
		arg2 func(_ string) bool
		arg3 bool
		arg4 func(chan error, string) error
	}
	newTasksToDeleteNodeGroupsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteNodeGroupsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub        func(context.Context, manager.NewOIDCManager, *typesc.Cluster, kubernetes.ClientSetGetter, bool) (*tasks.TaskTree, error)
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex       sync.RWMutex
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall []struct {
		arg1 context.Context
		arg2 manager.NewOIDCManager
		arg3 *typesc.Cluster
		arg4 kubernetes.ClientSetGetter
		arg5 bool
	}
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns struct {
		result1 *tasks.TaskTree
		result2 error
	}
	newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
		result2 error
	}
	NewUnmanagedNodeGroupTaskStub        func(context.Context, []*v1alpha5.NodeGroup, bool, bool, bool, vpc.Importer) *tasks.TaskTree
	newUnmanagedNodeGroupTaskMutex       sync.RWMutex
	newUnmanagedNodeGroupTaskArgsForCall []struct {
		arg1 context.Context
		arg2 []*v1alpha5.NodeGroup
		arg3 bool
		arg4 bool
		arg5 bool
		arg6 vpc.Importer
	}
	newUnmanagedNodeGroupTaskReturns struct {
		result1 *tasks.TaskTree
	}
	newUnmanagedNodeGroupTaskReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	PropagateManagedNodeGroupTagsToASGStub        func(string, map[string]string, []string, chan error) error
	propagateManagedNodeGroupTagsToASGMutex       sync.RWMutex
	propagateManagedNodeGroupTagsToASGArgsForCall []struct {
		arg1 string
		arg2 map[string]string
		arg3 []string
		arg4 chan error
	}
	propagateManagedNodeGroupTagsToASGReturns struct {
		result1 error
	}
	propagateManagedNodeGroupTagsToASGReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshFargatePodExecutionRoleARNStub        func(context.Context) error
	refreshFargatePodExecutionRoleARNMutex       sync.RWMutex
	refreshFargatePodExecutionRoleARNArgsForCall []struct {
		arg1 context.Context
	}
	refreshFargatePodExecutionRoleARNReturns struct {
		result1 error
	}
	refreshFargatePodExecutionRoleARNReturnsOnCall map[int]struct {
		result1 error
	}
	StackStatusIsNotTransitionalStub        func(*types.Stack) bool
	stackStatusIsNotTransitionalMutex       sync.RWMutex
	stackStatusIsNotTransitionalArgsForCall []struct {
		arg1 *types.Stack
	}
	stackStatusIsNotTransitionalReturns struct {
		result1 bool
	}
	stackStatusIsNotTransitionalReturnsOnCall map[int]struct {
		result1 bool
	}
	TroubleshootStackFailureCauseStub        func(context.Context, *types.Stack, types.StackStatus)
	troubleshootStackFailureCauseMutex       sync.RWMutex
	troubleshootStackFailureCauseArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 types.StackStatus
	}
	UpdateNodeGroupStackStub        func(context.Context, string, string, bool) error
	updateNodeGroupStackMutex       sync.RWMutex
	updateNodeGroupStackArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 bool
	}
	updateNodeGroupStackReturns struct {
		result1 error
	}
	updateNodeGroupStackReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStackStub        func(context.Context, manager.UpdateStackOptions) error
	updateStackMutex       sync.RWMutex
	updateStackArgsForCall []struct {
		arg1 context.Context
		arg2 manager.UpdateStackOptions
	}
	updateStackReturns struct {
		result1 error
	}
	updateStackReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStackManager) AppendNewClusterStackResource(arg1 context.Context, arg2 bool, arg3 bool) (bool, error) {
	fake.appendNewClusterStackResourceMutex.Lock()
	ret, specificReturn := fake.appendNewClusterStackResourceReturnsOnCall[len(fake.appendNewClusterStackResourceArgsForCall)]
	fake.appendNewClusterStackResourceArgsForCall = append(fake.appendNewClusterStackResourceArgsForCall, struct {
		arg1 context.Context
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.AppendNewClusterStackResourceStub
	fakeReturns := fake.appendNewClusterStackResourceReturns
	fake.recordInvocation("AppendNewClusterStackResource", []interface{}{arg1, arg2, arg3})
	fake.appendNewClusterStackResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) AppendNewClusterStackResourceCallCount() int {
	fake.appendNewClusterStackResourceMutex.RLock()
	defer fake.appendNewClusterStackResourceMutex.RUnlock()
	return len(fake.appendNewClusterStackResourceArgsForCall)
}

func (fake *FakeStackManager) AppendNewClusterStackResourceCalls(stub func(context.Context, bool, bool) (bool, error)) {
	fake.appendNewClusterStackResourceMutex.Lock()
	defer fake.appendNewClusterStackResourceMutex.Unlock()
	fake.AppendNewClusterStackResourceStub = stub
}

func (fake *FakeStackManager) AppendNewClusterStackResourceArgsForCall(i int) (context.Context, bool, bool) {
	fake.appendNewClusterStackResourceMutex.RLock()
	defer fake.appendNewClusterStackResourceMutex.RUnlock()
	argsForCall := fake.appendNewClusterStackResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) AppendNewClusterStackResourceReturns(result1 bool, result2 error) {
	fake.appendNewClusterStackResourceMutex.Lock()
	defer fake.appendNewClusterStackResourceMutex.Unlock()
	fake.AppendNewClusterStackResourceStub = nil
	fake.appendNewClusterStackResourceReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) AppendNewClusterStackResourceReturnsOnCall(i int, result1 bool, result2 error) {
	fake.appendNewClusterStackResourceMutex.Lock()
	defer fake.appendNewClusterStackResourceMutex.Unlock()
	fake.AppendNewClusterStackResourceStub = nil
	if fake.appendNewClusterStackResourceReturnsOnCall == nil {
		fake.appendNewClusterStackResourceReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.appendNewClusterStackResourceReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ClusterHasDedicatedVPC(arg1 context.Context) (bool, error) {
	fake.clusterHasDedicatedVPCMutex.Lock()
	ret, specificReturn := fake.clusterHasDedicatedVPCReturnsOnCall[len(fake.clusterHasDedicatedVPCArgsForCall)]
	fake.clusterHasDedicatedVPCArgsForCall = append(fake.clusterHasDedicatedVPCArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ClusterHasDedicatedVPCStub
	fakeReturns := fake.clusterHasDedicatedVPCReturns
	fake.recordInvocation("ClusterHasDedicatedVPC", []interface{}{arg1})
	fake.clusterHasDedicatedVPCMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ClusterHasDedicatedVPCCallCount() int {
	fake.clusterHasDedicatedVPCMutex.RLock()
	defer fake.clusterHasDedicatedVPCMutex.RUnlock()
	return len(fake.clusterHasDedicatedVPCArgsForCall)
}

func (fake *FakeStackManager) ClusterHasDedicatedVPCCalls(stub func(context.Context) (bool, error)) {
	fake.clusterHasDedicatedVPCMutex.Lock()
	defer fake.clusterHasDedicatedVPCMutex.Unlock()
	fake.ClusterHasDedicatedVPCStub = stub
}

func (fake *FakeStackManager) ClusterHasDedicatedVPCArgsForCall(i int) context.Context {
	fake.clusterHasDedicatedVPCMutex.RLock()
	defer fake.clusterHasDedicatedVPCMutex.RUnlock()
	argsForCall := fake.clusterHasDedicatedVPCArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ClusterHasDedicatedVPCReturns(result1 bool, result2 error) {
	fake.clusterHasDedicatedVPCMutex.Lock()
	defer fake.clusterHasDedicatedVPCMutex.Unlock()
	fake.ClusterHasDedicatedVPCStub = nil
	fake.clusterHasDedicatedVPCReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ClusterHasDedicatedVPCReturnsOnCall(i int, result1 bool, result2 error) {
	fake.clusterHasDedicatedVPCMutex.Lock()
	defer fake.clusterHasDedicatedVPCMutex.Unlock()
	fake.ClusterHasDedicatedVPCStub = nil
	if fake.clusterHasDedicatedVPCReturnsOnCall == nil {
		fake.clusterHasDedicatedVPCReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.clusterHasDedicatedVPCReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) CreateStack(arg1 context.Context, arg2 string, arg3 builder.ResourceSetReader, arg4 map[string]string, arg5 map[string]string, arg6 chan error) error {
	fake.createStackMutex.Lock()
	ret, specificReturn := fake.createStackReturnsOnCall[len(fake.createStackArgsForCall)]
	fake.createStackArgsForCall = append(fake.createStackArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 builder.ResourceSetReader
		arg4 map[string]string
		arg5 map[string]string
		arg6 chan error
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.CreateStackStub
	fakeReturns := fake.createStackReturns
	fake.recordInvocation("CreateStack", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.createStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) CreateStackCallCount() int {
	fake.createStackMutex.RLock()
	defer fake.createStackMutex.RUnlock()
	return len(fake.createStackArgsForCall)
}

func (fake *FakeStackManager) CreateStackCalls(stub func(context.Context, string, builder.ResourceSetReader, map[string]string, map[string]string, chan error) error) {
	fake.createStackMutex.Lock()
	defer fake.createStackMutex.Unlock()
	fake.CreateStackStub = stub
}

func (fake *FakeStackManager) CreateStackArgsForCall(i int) (context.Context, string, builder.ResourceSetReader, map[string]string, map[string]string, chan error) {
	fake.createStackMutex.RLock()
	defer fake.createStackMutex.RUnlock()
	argsForCall := fake.createStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStackManager) CreateStackReturns(result1 error) {
	fake.createStackMutex.Lock()
	defer fake.createStackMutex.Unlock()
	fake.CreateStackStub = nil
	fake.createStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) CreateStackReturnsOnCall(i int, result1 error) {
	fake.createStackMutex.Lock()
	defer fake.createStackMutex.Unlock()
	fake.CreateStackStub = nil
	if fake.createStackReturnsOnCall == nil {
		fake.createStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackBySpec(arg1 context.Context, arg2 *types.Stack) (*types.Stack, error) {
	fake.deleteStackBySpecMutex.Lock()
	ret, specificReturn := fake.deleteStackBySpecReturnsOnCall[len(fake.deleteStackBySpecArgsForCall)]
	fake.deleteStackBySpecArgsForCall = append(fake.deleteStackBySpecArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.DeleteStackBySpecStub
	fakeReturns := fake.deleteStackBySpecReturns
	fake.recordInvocation("DeleteStackBySpec", []interface{}{arg1, arg2})
	fake.deleteStackBySpecMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DeleteStackBySpecCallCount() int {
	fake.deleteStackBySpecMutex.RLock()
	defer fake.deleteStackBySpecMutex.RUnlock()
	return len(fake.deleteStackBySpecArgsForCall)
}

func (fake *FakeStackManager) DeleteStackBySpecCalls(stub func(context.Context, *types.Stack) (*types.Stack, error)) {
	fake.deleteStackBySpecMutex.Lock()
	defer fake.deleteStackBySpecMutex.Unlock()
	fake.DeleteStackBySpecStub = stub
}

func (fake *FakeStackManager) DeleteStackBySpecArgsForCall(i int) (context.Context, *types.Stack) {
	fake.deleteStackBySpecMutex.RLock()
	defer fake.deleteStackBySpecMutex.RUnlock()
	argsForCall := fake.deleteStackBySpecArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DeleteStackBySpecReturns(result1 *types.Stack, result2 error) {
	fake.deleteStackBySpecMutex.Lock()
	defer fake.deleteStackBySpecMutex.Unlock()
	fake.DeleteStackBySpecStub = nil
	fake.deleteStackBySpecReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteStackBySpecReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.deleteStackBySpecMutex.Lock()
	defer fake.deleteStackBySpecMutex.Unlock()
	fake.DeleteStackBySpecStub = nil
	if fake.deleteStackBySpecReturnsOnCall == nil {
		fake.deleteStackBySpecReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.deleteStackBySpecReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteStackBySpecSync(arg1 context.Context, arg2 *types.Stack, arg3 chan error) error {
	fake.deleteStackBySpecSyncMutex.Lock()
	ret, specificReturn := fake.deleteStackBySpecSyncReturnsOnCall[len(fake.deleteStackBySpecSyncArgsForCall)]
	fake.deleteStackBySpecSyncArgsForCall = append(fake.deleteStackBySpecSyncArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 chan error
	}{arg1, arg2, arg3})
	stub := fake.DeleteStackBySpecSyncStub
	fakeReturns := fake.deleteStackBySpecSyncReturns
	fake.recordInvocation("DeleteStackBySpecSync", []interface{}{arg1, arg2, arg3})
	fake.deleteStackBySpecSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DeleteStackBySpecSyncCallCount() int {
	fake.deleteStackBySpecSyncMutex.RLock()
	defer fake.deleteStackBySpecSyncMutex.RUnlock()
	return len(fake.deleteStackBySpecSyncArgsForCall)
}

func (fake *FakeStackManager) DeleteStackBySpecSyncCalls(stub func(context.Context, *types.Stack, chan error) error) {
	fake.deleteStackBySpecSyncMutex.Lock()
	defer fake.deleteStackBySpecSyncMutex.Unlock()
	fake.DeleteStackBySpecSyncStub = stub
}

func (fake *FakeStackManager) DeleteStackBySpecSyncArgsForCall(i int) (context.Context, *types.Stack, chan error) {
	fake.deleteStackBySpecSyncMutex.RLock()
	defer fake.deleteStackBySpecSyncMutex.RUnlock()
	argsForCall := fake.deleteStackBySpecSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) DeleteStackBySpecSyncReturns(result1 error) {
	fake.deleteStackBySpecSyncMutex.Lock()
	defer fake.deleteStackBySpecSyncMutex.Unlock()
	fake.DeleteStackBySpecSyncStub = nil
	fake.deleteStackBySpecSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackBySpecSyncReturnsOnCall(i int, result1 error) {
	fake.deleteStackBySpecSyncMutex.Lock()
	defer fake.deleteStackBySpecSyncMutex.Unlock()
	fake.DeleteStackBySpecSyncStub = nil
	if fake.deleteStackBySpecSyncReturnsOnCall == nil {
		fake.deleteStackBySpecSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteStackBySpecSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackSync(arg1 context.Context, arg2 *types.Stack) error {
	fake.deleteStackSyncMutex.Lock()
	ret, specificReturn := fake.deleteStackSyncReturnsOnCall[len(fake.deleteStackSyncArgsForCall)]
	fake.deleteStackSyncArgsForCall = append(fake.deleteStackSyncArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.DeleteStackSyncStub
	fakeReturns := fake.deleteStackSyncReturns
	fake.recordInvocation("DeleteStackSync", []interface{}{arg1, arg2})
	fake.deleteStackSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DeleteStackSyncCallCount() int {
	fake.deleteStackSyncMutex.RLock()
	defer fake.deleteStackSyncMutex.RUnlock()
	return len(fake.deleteStackSyncArgsForCall)
}

func (fake *FakeStackManager) DeleteStackSyncCalls(stub func(context.Context, *types.Stack) error) {
	fake.deleteStackSyncMutex.Lock()
	defer fake.deleteStackSyncMutex.Unlock()
	fake.DeleteStackSyncStub = stub
}

func (fake *FakeStackManager) DeleteStackSyncArgsForCall(i int) (context.Context, *types.Stack) {
	fake.deleteStackSyncMutex.RLock()
	defer fake.deleteStackSyncMutex.RUnlock()
	argsForCall := fake.deleteStackSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DeleteStackSyncReturns(result1 error) {
	fake.deleteStackSyncMutex.Lock()
	defer fake.deleteStackSyncMutex.Unlock()
	fake.DeleteStackSyncStub = nil
	fake.deleteStackSyncReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteStackSyncReturnsOnCall(i int, result1 error) {
	fake.deleteStackSyncMutex.Lock()
	defer fake.deleteStackSyncMutex.Unlock()
	fake.DeleteStackSyncStub = nil
	if fake.deleteStackSyncReturnsOnCall == nil {
		fake.deleteStackSyncReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteStackSyncReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacks(arg1 context.Context) (*tasks.TaskTree, error) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	ret, specificReturn := fake.deleteTasksForDeprecatedStacksReturnsOnCall[len(fake.deleteTasksForDeprecatedStacksArgsForCall)]
	fake.deleteTasksForDeprecatedStacksArgsForCall = append(fake.deleteTasksForDeprecatedStacksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DeleteTasksForDeprecatedStacksStub
	fakeReturns := fake.deleteTasksForDeprecatedStacksReturns
	fake.recordInvocation("DeleteTasksForDeprecatedStacks", []interface{}{arg1})
	fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksCallCount() int {
	fake.deleteTasksForDeprecatedStacksMutex.RLock()
	defer fake.deleteTasksForDeprecatedStacksMutex.RUnlock()
	return len(fake.deleteTasksForDeprecatedStacksArgsForCall)
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksCalls(stub func(context.Context) (*tasks.TaskTree, error)) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	defer fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	fake.DeleteTasksForDeprecatedStacksStub = stub
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksArgsForCall(i int) context.Context {
	fake.deleteTasksForDeprecatedStacksMutex.RLock()
	defer fake.deleteTasksForDeprecatedStacksMutex.RUnlock()
	argsForCall := fake.deleteTasksForDeprecatedStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksReturns(result1 *tasks.TaskTree, result2 error) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	defer fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	fake.DeleteTasksForDeprecatedStacksStub = nil
	fake.deleteTasksForDeprecatedStacksReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DeleteTasksForDeprecatedStacksReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.deleteTasksForDeprecatedStacksMutex.Lock()
	defer fake.deleteTasksForDeprecatedStacksMutex.Unlock()
	fake.DeleteTasksForDeprecatedStacksStub = nil
	if fake.deleteTasksForDeprecatedStacksReturnsOnCall == nil {
		fake.deleteTasksForDeprecatedStacksReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.deleteTasksForDeprecatedStacksReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeClusterStack(arg1 context.Context) (*types.Stack, error) {
	fake.describeClusterStackMutex.Lock()
	ret, specificReturn := fake.describeClusterStackReturnsOnCall[len(fake.describeClusterStackArgsForCall)]
	fake.describeClusterStackArgsForCall = append(fake.describeClusterStackArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DescribeClusterStackStub
	fakeReturns := fake.describeClusterStackReturns
	fake.recordInvocation("DescribeClusterStack", []interface{}{arg1})
	fake.describeClusterStackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeClusterStackCallCount() int {
	fake.describeClusterStackMutex.RLock()
	defer fake.describeClusterStackMutex.RUnlock()
	return len(fake.describeClusterStackArgsForCall)
}

func (fake *FakeStackManager) DescribeClusterStackCalls(stub func(context.Context) (*types.Stack, error)) {
	fake.describeClusterStackMutex.Lock()
	defer fake.describeClusterStackMutex.Unlock()
	fake.DescribeClusterStackStub = stub
}

func (fake *FakeStackManager) DescribeClusterStackArgsForCall(i int) context.Context {
	fake.describeClusterStackMutex.RLock()
	defer fake.describeClusterStackMutex.RUnlock()
	argsForCall := fake.describeClusterStackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeClusterStackReturns(result1 *types.Stack, result2 error) {
	fake.describeClusterStackMutex.Lock()
	defer fake.describeClusterStackMutex.Unlock()
	fake.DescribeClusterStackStub = nil
	fake.describeClusterStackReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeClusterStackReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.describeClusterStackMutex.Lock()
	defer fake.describeClusterStackMutex.Unlock()
	fake.DescribeClusterStackStub = nil
	if fake.describeClusterStackReturnsOnCall == nil {
		fake.describeClusterStackReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.describeClusterStackReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeClusterStackIfExists(arg1 context.Context) (*types.Stack, error) {
	fake.describeClusterStackIfExistsMutex.Lock()
	ret, specificReturn := fake.describeClusterStackIfExistsReturnsOnCall[len(fake.describeClusterStackIfExistsArgsForCall)]
	fake.describeClusterStackIfExistsArgsForCall = append(fake.describeClusterStackIfExistsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DescribeClusterStackIfExistsStub
	fakeReturns := fake.describeClusterStackIfExistsReturns
	fake.recordInvocation("DescribeClusterStackIfExists", []interface{}{arg1})
	fake.describeClusterStackIfExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeClusterStackIfExistsCallCount() int {
	fake.describeClusterStackIfExistsMutex.RLock()
	defer fake.describeClusterStackIfExistsMutex.RUnlock()
	return len(fake.describeClusterStackIfExistsArgsForCall)
}

func (fake *FakeStackManager) DescribeClusterStackIfExistsCalls(stub func(context.Context) (*types.Stack, error)) {
	fake.describeClusterStackIfExistsMutex.Lock()
	defer fake.describeClusterStackIfExistsMutex.Unlock()
	fake.DescribeClusterStackIfExistsStub = stub
}

func (fake *FakeStackManager) DescribeClusterStackIfExistsArgsForCall(i int) context.Context {
	fake.describeClusterStackIfExistsMutex.RLock()
	defer fake.describeClusterStackIfExistsMutex.RUnlock()
	argsForCall := fake.describeClusterStackIfExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeClusterStackIfExistsReturns(result1 *types.Stack, result2 error) {
	fake.describeClusterStackIfExistsMutex.Lock()
	defer fake.describeClusterStackIfExistsMutex.Unlock()
	fake.DescribeClusterStackIfExistsStub = nil
	fake.describeClusterStackIfExistsReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeClusterStackIfExistsReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.describeClusterStackIfExistsMutex.Lock()
	defer fake.describeClusterStackIfExistsMutex.Unlock()
	fake.DescribeClusterStackIfExistsStub = nil
	if fake.describeClusterStackIfExistsReturnsOnCall == nil {
		fake.describeClusterStackIfExistsReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.describeClusterStackIfExistsReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacks(arg1 context.Context) ([]*types.Stack, error) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	ret, specificReturn := fake.describeIAMServiceAccountStacksReturnsOnCall[len(fake.describeIAMServiceAccountStacksArgsForCall)]
	fake.describeIAMServiceAccountStacksArgsForCall = append(fake.describeIAMServiceAccountStacksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DescribeIAMServiceAccountStacksStub
	fakeReturns := fake.describeIAMServiceAccountStacksReturns
	fake.recordInvocation("DescribeIAMServiceAccountStacks", []interface{}{arg1})
	fake.describeIAMServiceAccountStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksCallCount() int {
	fake.describeIAMServiceAccountStacksMutex.RLock()
	defer fake.describeIAMServiceAccountStacksMutex.RUnlock()
	return len(fake.describeIAMServiceAccountStacksArgsForCall)
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksCalls(stub func(context.Context) ([]*types.Stack, error)) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	defer fake.describeIAMServiceAccountStacksMutex.Unlock()
	fake.DescribeIAMServiceAccountStacksStub = stub
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksArgsForCall(i int) context.Context {
	fake.describeIAMServiceAccountStacksMutex.RLock()
	defer fake.describeIAMServiceAccountStacksMutex.RUnlock()
	argsForCall := fake.describeIAMServiceAccountStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksReturns(result1 []*types.Stack, result2 error) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	defer fake.describeIAMServiceAccountStacksMutex.Unlock()
	fake.DescribeIAMServiceAccountStacksStub = nil
	fake.describeIAMServiceAccountStacksReturns = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeIAMServiceAccountStacksReturnsOnCall(i int, result1 []*types.Stack, result2 error) {
	fake.describeIAMServiceAccountStacksMutex.Lock()
	defer fake.describeIAMServiceAccountStacksMutex.Unlock()
	fake.DescribeIAMServiceAccountStacksStub = nil
	if fake.describeIAMServiceAccountStacksReturnsOnCall == nil {
		fake.describeIAMServiceAccountStacksReturnsOnCall = make(map[int]struct {
			result1 []*types.Stack
			result2 error
		})
	}
	fake.describeIAMServiceAccountStacksReturnsOnCall[i] = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStack(arg1 context.Context, arg2 string) (*types.Stack, error) {
	fake.describeNodeGroupStackMutex.Lock()
	ret, specificReturn := fake.describeNodeGroupStackReturnsOnCall[len(fake.describeNodeGroupStackArgsForCall)]
	fake.describeNodeGroupStackArgsForCall = append(fake.describeNodeGroupStackArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DescribeNodeGroupStackStub
	fakeReturns := fake.describeNodeGroupStackReturns
	fake.recordInvocation("DescribeNodeGroupStack", []interface{}{arg1, arg2})
	fake.describeNodeGroupStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeNodeGroupStackCallCount() int {
	fake.describeNodeGroupStackMutex.RLock()
	defer fake.describeNodeGroupStackMutex.RUnlock()
	return len(fake.describeNodeGroupStackArgsForCall)
}

func (fake *FakeStackManager) DescribeNodeGroupStackCalls(stub func(context.Context, string) (*types.Stack, error)) {
	fake.describeNodeGroupStackMutex.Lock()
	defer fake.describeNodeGroupStackMutex.Unlock()
	fake.DescribeNodeGroupStackStub = stub
}

func (fake *FakeStackManager) DescribeNodeGroupStackArgsForCall(i int) (context.Context, string) {
	fake.describeNodeGroupStackMutex.RLock()
	defer fake.describeNodeGroupStackMutex.RUnlock()
	argsForCall := fake.describeNodeGroupStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DescribeNodeGroupStackReturns(result1 *types.Stack, result2 error) {
	fake.describeNodeGroupStackMutex.Lock()
	defer fake.describeNodeGroupStackMutex.Unlock()
	fake.DescribeNodeGroupStackStub = nil
	fake.describeNodeGroupStackReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStackReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.describeNodeGroupStackMutex.Lock()
	defer fake.describeNodeGroupStackMutex.Unlock()
	fake.DescribeNodeGroupStackStub = nil
	if fake.describeNodeGroupStackReturnsOnCall == nil {
		fake.describeNodeGroupStackReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.describeNodeGroupStackReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResources(arg1 context.Context) (map[string]manager.StackInfo, error) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	ret, specificReturn := fake.describeNodeGroupStacksAndResourcesReturnsOnCall[len(fake.describeNodeGroupStacksAndResourcesArgsForCall)]
	fake.describeNodeGroupStacksAndResourcesArgsForCall = append(fake.describeNodeGroupStacksAndResourcesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.DescribeNodeGroupStacksAndResourcesStub
	fakeReturns := fake.describeNodeGroupStacksAndResourcesReturns
	fake.recordInvocation("DescribeNodeGroupStacksAndResources", []interface{}{arg1})
	fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesCallCount() int {
	fake.describeNodeGroupStacksAndResourcesMutex.RLock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.RUnlock()
	return len(fake.describeNodeGroupStacksAndResourcesArgsForCall)
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesCalls(stub func(context.Context) (map[string]manager.StackInfo, error)) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	fake.DescribeNodeGroupStacksAndResourcesStub = stub
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesArgsForCall(i int) context.Context {
	fake.describeNodeGroupStacksAndResourcesMutex.RLock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.RUnlock()
	argsForCall := fake.describeNodeGroupStacksAndResourcesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesReturns(result1 map[string]manager.StackInfo, result2 error) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	fake.DescribeNodeGroupStacksAndResourcesStub = nil
	fake.describeNodeGroupStacksAndResourcesReturns = struct {
		result1 map[string]manager.StackInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeNodeGroupStacksAndResourcesReturnsOnCall(i int, result1 map[string]manager.StackInfo, result2 error) {
	fake.describeNodeGroupStacksAndResourcesMutex.Lock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.Unlock()
	fake.DescribeNodeGroupStacksAndResourcesStub = nil
	if fake.describeNodeGroupStacksAndResourcesReturnsOnCall == nil {
		fake.describeNodeGroupStacksAndResourcesReturnsOnCall = make(map[int]struct {
			result1 map[string]manager.StackInfo
			result2 error
		})
	}
	fake.describeNodeGroupStacksAndResourcesReturnsOnCall[i] = struct {
		result1 map[string]manager.StackInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStack(arg1 context.Context, arg2 *types.Stack) (*types.Stack, error) {
	fake.describeStackMutex.Lock()
	ret, specificReturn := fake.describeStackReturnsOnCall[len(fake.describeStackArgsForCall)]
	fake.describeStackArgsForCall = append(fake.describeStackArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.DescribeStackStub
	fakeReturns := fake.describeStackReturns
	fake.recordInvocation("DescribeStack", []interface{}{arg1, arg2})
	fake.describeStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStackCallCount() int {
	fake.describeStackMutex.RLock()
	defer fake.describeStackMutex.RUnlock()
	return len(fake.describeStackArgsForCall)
}

func (fake *FakeStackManager) DescribeStackCalls(stub func(context.Context, *types.Stack) (*types.Stack, error)) {
	fake.describeStackMutex.Lock()
	defer fake.describeStackMutex.Unlock()
	fake.DescribeStackStub = stub
}

func (fake *FakeStackManager) DescribeStackArgsForCall(i int) (context.Context, *types.Stack) {
	fake.describeStackMutex.RLock()
	defer fake.describeStackMutex.RUnlock()
	argsForCall := fake.describeStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DescribeStackReturns(result1 *types.Stack, result2 error) {
	fake.describeStackMutex.Lock()
	defer fake.describeStackMutex.Unlock()
	fake.DescribeStackStub = nil
	fake.describeStackReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.describeStackMutex.Lock()
	defer fake.describeStackMutex.Unlock()
	fake.DescribeStackStub = nil
	if fake.describeStackReturnsOnCall == nil {
		fake.describeStackReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.describeStackReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackChangeSet(arg1 context.Context, arg2 *types.Stack, arg3 string) (*cloudformation.DescribeChangeSetOutput, error) {
	fake.describeStackChangeSetMutex.Lock()
	ret, specificReturn := fake.describeStackChangeSetReturnsOnCall[len(fake.describeStackChangeSetArgsForCall)]
	fake.describeStackChangeSetArgsForCall = append(fake.describeStackChangeSetArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DescribeStackChangeSetStub
	fakeReturns := fake.describeStackChangeSetReturns
	fake.recordInvocation("DescribeStackChangeSet", []interface{}{arg1, arg2, arg3})
	fake.describeStackChangeSetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStackChangeSetCallCount() int {
	fake.describeStackChangeSetMutex.RLock()
	defer fake.describeStackChangeSetMutex.RUnlock()
	return len(fake.describeStackChangeSetArgsForCall)
}

func (fake *FakeStackManager) DescribeStackChangeSetCalls(stub func(context.Context, *types.Stack, string) (*cloudformation.DescribeChangeSetOutput, error)) {
	fake.describeStackChangeSetMutex.Lock()
	defer fake.describeStackChangeSetMutex.Unlock()
	fake.DescribeStackChangeSetStub = stub
}

func (fake *FakeStackManager) DescribeStackChangeSetArgsForCall(i int) (context.Context, *types.Stack, string) {
	fake.describeStackChangeSetMutex.RLock()
	defer fake.describeStackChangeSetMutex.RUnlock()
	argsForCall := fake.describeStackChangeSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) DescribeStackChangeSetReturns(result1 *cloudformation.DescribeChangeSetOutput, result2 error) {
	fake.describeStackChangeSetMutex.Lock()
	defer fake.describeStackChangeSetMutex.Unlock()
	fake.DescribeStackChangeSetStub = nil
	fake.describeStackChangeSetReturns = struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackChangeSetReturnsOnCall(i int, result1 *cloudformation.DescribeChangeSetOutput, result2 error) {
	fake.describeStackChangeSetMutex.Lock()
	defer fake.describeStackChangeSetMutex.Unlock()
	fake.DescribeStackChangeSetStub = nil
	if fake.describeStackChangeSetReturnsOnCall == nil {
		fake.describeStackChangeSetReturnsOnCall = make(map[int]struct {
			result1 *cloudformation.DescribeChangeSetOutput
			result2 error
		})
	}
	fake.describeStackChangeSetReturnsOnCall[i] = struct {
		result1 *cloudformation.DescribeChangeSetOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackEvents(arg1 context.Context, arg2 *types.Stack) ([]types.StackEvent, error) {
	fake.describeStackEventsMutex.Lock()
	ret, specificReturn := fake.describeStackEventsReturnsOnCall[len(fake.describeStackEventsArgsForCall)]
	fake.describeStackEventsArgsForCall = append(fake.describeStackEventsArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.DescribeStackEventsStub
	fakeReturns := fake.describeStackEventsReturns
	fake.recordInvocation("DescribeStackEvents", []interface{}{arg1, arg2})
	fake.describeStackEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) DescribeStackEventsCallCount() int {
	fake.describeStackEventsMutex.RLock()
	defer fake.describeStackEventsMutex.RUnlock()
	return len(fake.describeStackEventsArgsForCall)
}

func (fake *FakeStackManager) DescribeStackEventsCalls(stub func(context.Context, *types.Stack) ([]types.StackEvent, error)) {
	fake.describeStackEventsMutex.Lock()
	defer fake.describeStackEventsMutex.Unlock()
	fake.DescribeStackEventsStub = stub
}

func (fake *FakeStackManager) DescribeStackEventsArgsForCall(i int) (context.Context, *types.Stack) {
	fake.describeStackEventsMutex.RLock()
	defer fake.describeStackEventsMutex.RUnlock()
	argsForCall := fake.describeStackEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DescribeStackEventsReturns(result1 []types.StackEvent, result2 error) {
	fake.describeStackEventsMutex.Lock()
	defer fake.describeStackEventsMutex.Unlock()
	fake.DescribeStackEventsStub = nil
	fake.describeStackEventsReturns = struct {
		result1 []types.StackEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DescribeStackEventsReturnsOnCall(i int, result1 []types.StackEvent, result2 error) {
	fake.describeStackEventsMutex.Lock()
	defer fake.describeStackEventsMutex.Unlock()
	fake.DescribeStackEventsStub = nil
	if fake.describeStackEventsReturnsOnCall == nil {
		fake.describeStackEventsReturnsOnCall = make(map[int]struct {
			result1 []types.StackEvent
			result2 error
		})
	}
	fake.describeStackEventsReturnsOnCall[i] = struct {
		result1 []types.StackEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) DoCreateStackRequest(arg1 context.Context, arg2 *types.Stack, arg3 manager.TemplateData, arg4 map[string]string, arg5 map[string]string, arg6 bool, arg7 bool) error {
	fake.doCreateStackRequestMutex.Lock()
	ret, specificReturn := fake.doCreateStackRequestReturnsOnCall[len(fake.doCreateStackRequestArgsForCall)]
	fake.doCreateStackRequestArgsForCall = append(fake.doCreateStackRequestArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 manager.TemplateData
		arg4 map[string]string
		arg5 map[string]string
		arg6 bool
		arg7 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.DoCreateStackRequestStub
	fakeReturns := fake.doCreateStackRequestReturns
	fake.recordInvocation("DoCreateStackRequest", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.doCreateStackRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DoCreateStackRequestCallCount() int {
	fake.doCreateStackRequestMutex.RLock()
	defer fake.doCreateStackRequestMutex.RUnlock()
	return len(fake.doCreateStackRequestArgsForCall)
}

func (fake *FakeStackManager) DoCreateStackRequestCalls(stub func(context.Context, *types.Stack, manager.TemplateData, map[string]string, map[string]string, bool, bool) error) {
	fake.doCreateStackRequestMutex.Lock()
	defer fake.doCreateStackRequestMutex.Unlock()
	fake.DoCreateStackRequestStub = stub
}

func (fake *FakeStackManager) DoCreateStackRequestArgsForCall(i int) (context.Context, *types.Stack, manager.TemplateData, map[string]string, map[string]string, bool, bool) {
	fake.doCreateStackRequestMutex.RLock()
	defer fake.doCreateStackRequestMutex.RUnlock()
	argsForCall := fake.doCreateStackRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeStackManager) DoCreateStackRequestReturns(result1 error) {
	fake.doCreateStackRequestMutex.Lock()
	defer fake.doCreateStackRequestMutex.Unlock()
	fake.DoCreateStackRequestStub = nil
	fake.doCreateStackRequestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DoCreateStackRequestReturnsOnCall(i int, result1 error) {
	fake.doCreateStackRequestMutex.Lock()
	defer fake.doCreateStackRequestMutex.Unlock()
	fake.DoCreateStackRequestStub = nil
	if fake.doCreateStackRequestReturnsOnCall == nil {
		fake.doCreateStackRequestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doCreateStackRequestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreated(arg1 context.Context, arg2 *types.Stack) error {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	ret, specificReturn := fake.doWaitUntilStackIsCreatedReturnsOnCall[len(fake.doWaitUntilStackIsCreatedArgsForCall)]
	fake.doWaitUntilStackIsCreatedArgsForCall = append(fake.doWaitUntilStackIsCreatedArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.DoWaitUntilStackIsCreatedStub
	fakeReturns := fake.doWaitUntilStackIsCreatedReturns
	fake.recordInvocation("DoWaitUntilStackIsCreated", []interface{}{arg1, arg2})
	fake.doWaitUntilStackIsCreatedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedCallCount() int {
	fake.doWaitUntilStackIsCreatedMutex.RLock()
	defer fake.doWaitUntilStackIsCreatedMutex.RUnlock()
	return len(fake.doWaitUntilStackIsCreatedArgsForCall)
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedCalls(stub func(context.Context, *types.Stack) error) {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	defer fake.doWaitUntilStackIsCreatedMutex.Unlock()
	fake.DoWaitUntilStackIsCreatedStub = stub
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedArgsForCall(i int) (context.Context, *types.Stack) {
	fake.doWaitUntilStackIsCreatedMutex.RLock()
	defer fake.doWaitUntilStackIsCreatedMutex.RUnlock()
	argsForCall := fake.doWaitUntilStackIsCreatedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedReturns(result1 error) {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	defer fake.doWaitUntilStackIsCreatedMutex.Unlock()
	fake.DoWaitUntilStackIsCreatedStub = nil
	fake.doWaitUntilStackIsCreatedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) DoWaitUntilStackIsCreatedReturnsOnCall(i int, result1 error) {
	fake.doWaitUntilStackIsCreatedMutex.Lock()
	defer fake.doWaitUntilStackIsCreatedMutex.Unlock()
	fake.DoWaitUntilStackIsCreatedStub = nil
	if fake.doWaitUntilStackIsCreatedReturnsOnCall == nil {
		fake.doWaitUntilStackIsCreatedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doWaitUntilStackIsCreatedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabled(arg1 context.Context) error {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	ret, specificReturn := fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall[len(fake.ensureMapPublicIPOnLaunchEnabledArgsForCall)]
	fake.ensureMapPublicIPOnLaunchEnabledArgsForCall = append(fake.ensureMapPublicIPOnLaunchEnabledArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.EnsureMapPublicIPOnLaunchEnabledStub
	fakeReturns := fake.ensureMapPublicIPOnLaunchEnabledReturns
	fake.recordInvocation("EnsureMapPublicIPOnLaunchEnabled", []interface{}{arg1})
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledCallCount() int {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.RLock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.RUnlock()
	return len(fake.ensureMapPublicIPOnLaunchEnabledArgsForCall)
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledCalls(stub func(context.Context) error) {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	fake.EnsureMapPublicIPOnLaunchEnabledStub = stub
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledArgsForCall(i int) context.Context {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.RLock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.RUnlock()
	argsForCall := fake.ensureMapPublicIPOnLaunchEnabledArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledReturns(result1 error) {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	fake.EnsureMapPublicIPOnLaunchEnabledStub = nil
	fake.ensureMapPublicIPOnLaunchEnabledReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) EnsureMapPublicIPOnLaunchEnabledReturnsOnCall(i int, result1 error) {
	fake.ensureMapPublicIPOnLaunchEnabledMutex.Lock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.Unlock()
	fake.EnsureMapPublicIPOnLaunchEnabledStub = nil
	if fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall == nil {
		fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureMapPublicIPOnLaunchEnabledReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) FixClusterCompatibility(arg1 context.Context) error {
	fake.fixClusterCompatibilityMutex.Lock()
	ret, specificReturn := fake.fixClusterCompatibilityReturnsOnCall[len(fake.fixClusterCompatibilityArgsForCall)]
	fake.fixClusterCompatibilityArgsForCall = append(fake.fixClusterCompatibilityArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.FixClusterCompatibilityStub
	fakeReturns := fake.fixClusterCompatibilityReturns
	fake.recordInvocation("FixClusterCompatibility", []interface{}{arg1})
	fake.fixClusterCompatibilityMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) FixClusterCompatibilityCallCount() int {
	fake.fixClusterCompatibilityMutex.RLock()
	defer fake.fixClusterCompatibilityMutex.RUnlock()
	return len(fake.fixClusterCompatibilityArgsForCall)
}

func (fake *FakeStackManager) FixClusterCompatibilityCalls(stub func(context.Context) error) {
	fake.fixClusterCompatibilityMutex.Lock()
	defer fake.fixClusterCompatibilityMutex.Unlock()
	fake.FixClusterCompatibilityStub = stub
}

func (fake *FakeStackManager) FixClusterCompatibilityArgsForCall(i int) context.Context {
	fake.fixClusterCompatibilityMutex.RLock()
	defer fake.fixClusterCompatibilityMutex.RUnlock()
	argsForCall := fake.fixClusterCompatibilityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) FixClusterCompatibilityReturns(result1 error) {
	fake.fixClusterCompatibilityMutex.Lock()
	defer fake.fixClusterCompatibilityMutex.Unlock()
	fake.FixClusterCompatibilityStub = nil
	fake.fixClusterCompatibilityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) FixClusterCompatibilityReturnsOnCall(i int, result1 error) {
	fake.fixClusterCompatibilityMutex.Lock()
	defer fake.fixClusterCompatibilityMutex.Unlock()
	fake.FixClusterCompatibilityStub = nil
	if fake.fixClusterCompatibilityReturnsOnCall == nil {
		fake.fixClusterCompatibilityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fixClusterCompatibilityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) GetAutoScalingGroupDesiredCapacity(arg1 context.Context, arg2 string) (typesa.AutoScalingGroup, error) {
	fake.getAutoScalingGroupDesiredCapacityMutex.Lock()
	ret, specificReturn := fake.getAutoScalingGroupDesiredCapacityReturnsOnCall[len(fake.getAutoScalingGroupDesiredCapacityArgsForCall)]
	fake.getAutoScalingGroupDesiredCapacityArgsForCall = append(fake.getAutoScalingGroupDesiredCapacityArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetAutoScalingGroupDesiredCapacityStub
	fakeReturns := fake.getAutoScalingGroupDesiredCapacityReturns
	fake.recordInvocation("GetAutoScalingGroupDesiredCapacity", []interface{}{arg1, arg2})
	fake.getAutoScalingGroupDesiredCapacityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetAutoScalingGroupDesiredCapacityCallCount() int {
	fake.getAutoScalingGroupDesiredCapacityMutex.RLock()
	defer fake.getAutoScalingGroupDesiredCapacityMutex.RUnlock()
	return len(fake.getAutoScalingGroupDesiredCapacityArgsForCall)
}

func (fake *FakeStackManager) GetAutoScalingGroupDesiredCapacityCalls(stub func(context.Context, string) (typesa.AutoScalingGroup, error)) {
	fake.getAutoScalingGroupDesiredCapacityMutex.Lock()
	defer fake.getAutoScalingGroupDesiredCapacityMutex.Unlock()
	fake.GetAutoScalingGroupDesiredCapacityStub = stub
}

func (fake *FakeStackManager) GetAutoScalingGroupDesiredCapacityArgsForCall(i int) (context.Context, string) {
	fake.getAutoScalingGroupDesiredCapacityMutex.RLock()
	defer fake.getAutoScalingGroupDesiredCapacityMutex.RUnlock()
	argsForCall := fake.getAutoScalingGroupDesiredCapacityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) GetAutoScalingGroupDesiredCapacityReturns(result1 typesa.AutoScalingGroup, result2 error) {
	fake.getAutoScalingGroupDesiredCapacityMutex.Lock()
	defer fake.getAutoScalingGroupDesiredCapacityMutex.Unlock()
	fake.GetAutoScalingGroupDesiredCapacityStub = nil
	fake.getAutoScalingGroupDesiredCapacityReturns = struct {
		result1 typesa.AutoScalingGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetAutoScalingGroupDesiredCapacityReturnsOnCall(i int, result1 typesa.AutoScalingGroup, result2 error) {
	fake.getAutoScalingGroupDesiredCapacityMutex.Lock()
	defer fake.getAutoScalingGroupDesiredCapacityMutex.Unlock()
	fake.GetAutoScalingGroupDesiredCapacityStub = nil
	if fake.getAutoScalingGroupDesiredCapacityReturnsOnCall == nil {
		fake.getAutoScalingGroupDesiredCapacityReturnsOnCall = make(map[int]struct {
			result1 typesa.AutoScalingGroup
			result2 error
		})
	}
	fake.getAutoScalingGroupDesiredCapacityReturnsOnCall[i] = struct {
		result1 typesa.AutoScalingGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetAutoScalingGroupName(arg1 context.Context, arg2 *types.Stack) (string, error) {
	fake.getAutoScalingGroupNameMutex.Lock()
	ret, specificReturn := fake.getAutoScalingGroupNameReturnsOnCall[len(fake.getAutoScalingGroupNameArgsForCall)]
	fake.getAutoScalingGroupNameArgsForCall = append(fake.getAutoScalingGroupNameArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.GetAutoScalingGroupNameStub
	fakeReturns := fake.getAutoScalingGroupNameReturns
	fake.recordInvocation("GetAutoScalingGroupName", []interface{}{arg1, arg2})
	fake.getAutoScalingGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetAutoScalingGroupNameCallCount() int {
	fake.getAutoScalingGroupNameMutex.RLock()
	defer fake.getAutoScalingGroupNameMutex.RUnlock()
	return len(fake.getAutoScalingGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetAutoScalingGroupNameCalls(stub func(context.Context, *types.Stack) (string, error)) {
	fake.getAutoScalingGroupNameMutex.Lock()
	defer fake.getAutoScalingGroupNameMutex.Unlock()
	fake.GetAutoScalingGroupNameStub = stub
}

func (fake *FakeStackManager) GetAutoScalingGroupNameArgsForCall(i int) (context.Context, *types.Stack) {
	fake.getAutoScalingGroupNameMutex.RLock()
	defer fake.getAutoScalingGroupNameMutex.RUnlock()
	argsForCall := fake.getAutoScalingGroupNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) GetAutoScalingGroupNameReturns(result1 string, result2 error) {
	fake.getAutoScalingGroupNameMutex.Lock()
	defer fake.getAutoScalingGroupNameMutex.Unlock()
	fake.GetAutoScalingGroupNameStub = nil
	fake.getAutoScalingGroupNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetAutoScalingGroupNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getAutoScalingGroupNameMutex.Lock()
	defer fake.getAutoScalingGroupNameMutex.Unlock()
	fake.GetAutoScalingGroupNameStub = nil
	if fake.getAutoScalingGroupNameReturnsOnCall == nil {
		fake.getAutoScalingGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getAutoScalingGroupNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetClusterStackIfExists(arg1 context.Context) (*types.Stack, error) {
	fake.getClusterStackIfExistsMutex.Lock()
	ret, specificReturn := fake.getClusterStackIfExistsReturnsOnCall[len(fake.getClusterStackIfExistsArgsForCall)]
	fake.getClusterStackIfExistsArgsForCall = append(fake.getClusterStackIfExistsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetClusterStackIfExistsStub
	fakeReturns := fake.getClusterStackIfExistsReturns
	fake.recordInvocation("GetClusterStackIfExists", []interface{}{arg1})
	fake.getClusterStackIfExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetClusterStackIfExistsCallCount() int {
	fake.getClusterStackIfExistsMutex.RLock()
	defer fake.getClusterStackIfExistsMutex.RUnlock()
	return len(fake.getClusterStackIfExistsArgsForCall)
}

func (fake *FakeStackManager) GetClusterStackIfExistsCalls(stub func(context.Context) (*types.Stack, error)) {
	fake.getClusterStackIfExistsMutex.Lock()
	defer fake.getClusterStackIfExistsMutex.Unlock()
	fake.GetClusterStackIfExistsStub = stub
}

func (fake *FakeStackManager) GetClusterStackIfExistsArgsForCall(i int) context.Context {
	fake.getClusterStackIfExistsMutex.RLock()
	defer fake.getClusterStackIfExistsMutex.RUnlock()
	argsForCall := fake.getClusterStackIfExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetClusterStackIfExistsReturns(result1 *types.Stack, result2 error) {
	fake.getClusterStackIfExistsMutex.Lock()
	defer fake.getClusterStackIfExistsMutex.Unlock()
	fake.GetClusterStackIfExistsStub = nil
	fake.getClusterStackIfExistsReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetClusterStackIfExistsReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.getClusterStackIfExistsMutex.Lock()
	defer fake.getClusterStackIfExistsMutex.Unlock()
	fake.GetClusterStackIfExistsStub = nil
	if fake.getClusterStackIfExistsReturnsOnCall == nil {
		fake.getClusterStackIfExistsReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.getClusterStackIfExistsReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetFargateStack(arg1 context.Context) (*types.Stack, error) {
	fake.getFargateStackMutex.Lock()
	ret, specificReturn := fake.getFargateStackReturnsOnCall[len(fake.getFargateStackArgsForCall)]
	fake.getFargateStackArgsForCall = append(fake.getFargateStackArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetFargateStackStub
	fakeReturns := fake.getFargateStackReturns
	fake.recordInvocation("GetFargateStack", []interface{}{arg1})
	fake.getFargateStackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetFargateStackCallCount() int {
	fake.getFargateStackMutex.RLock()
	defer fake.getFargateStackMutex.RUnlock()
	return len(fake.getFargateStackArgsForCall)
}

func (fake *FakeStackManager) GetFargateStackCalls(stub func(context.Context) (*types.Stack, error)) {
	fake.getFargateStackMutex.Lock()
	defer fake.getFargateStackMutex.Unlock()
	fake.GetFargateStackStub = stub
}

func (fake *FakeStackManager) GetFargateStackArgsForCall(i int) context.Context {
	fake.getFargateStackMutex.RLock()
	defer fake.getFargateStackMutex.RUnlock()
	argsForCall := fake.getFargateStackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetFargateStackReturns(result1 *types.Stack, result2 error) {
	fake.getFargateStackMutex.Lock()
	defer fake.getFargateStackMutex.Unlock()
	fake.GetFargateStackStub = nil
	fake.getFargateStackReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetFargateStackReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.getFargateStackMutex.Lock()
	defer fake.getFargateStackMutex.Unlock()
	fake.GetFargateStackStub = nil
	if fake.getFargateStackReturnsOnCall == nil {
		fake.getFargateStackReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.getFargateStackReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMAddonName(arg1 *types.Stack) string {
	fake.getIAMAddonNameMutex.Lock()
	ret, specificReturn := fake.getIAMAddonNameReturnsOnCall[len(fake.getIAMAddonNameArgsForCall)]
	fake.getIAMAddonNameArgsForCall = append(fake.getIAMAddonNameArgsForCall, struct {
		arg1 *types.Stack
	}{arg1})
	stub := fake.GetIAMAddonNameStub
	fakeReturns := fake.getIAMAddonNameReturns
	fake.recordInvocation("GetIAMAddonName", []interface{}{arg1})
	fake.getIAMAddonNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) GetIAMAddonNameCallCount() int {
	fake.getIAMAddonNameMutex.RLock()
	defer fake.getIAMAddonNameMutex.RUnlock()
	return len(fake.getIAMAddonNameArgsForCall)
}

func (fake *FakeStackManager) GetIAMAddonNameCalls(stub func(*types.Stack) string) {
	fake.getIAMAddonNameMutex.Lock()
	defer fake.getIAMAddonNameMutex.Unlock()
	fake.GetIAMAddonNameStub = stub
}

func (fake *FakeStackManager) GetIAMAddonNameArgsForCall(i int) *types.Stack {
	fake.getIAMAddonNameMutex.RLock()
	defer fake.getIAMAddonNameMutex.RUnlock()
	argsForCall := fake.getIAMAddonNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetIAMAddonNameReturns(result1 string) {
	fake.getIAMAddonNameMutex.Lock()
	defer fake.getIAMAddonNameMutex.Unlock()
	fake.GetIAMAddonNameStub = nil
	fake.getIAMAddonNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetIAMAddonNameReturnsOnCall(i int, result1 string) {
	fake.getIAMAddonNameMutex.Lock()
	defer fake.getIAMAddonNameMutex.Unlock()
	fake.GetIAMAddonNameStub = nil
	if fake.getIAMAddonNameReturnsOnCall == nil {
		fake.getIAMAddonNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getIAMAddonNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetIAMAddonsStacks(arg1 context.Context) ([]*types.Stack, error) {
	fake.getIAMAddonsStacksMutex.Lock()
	ret, specificReturn := fake.getIAMAddonsStacksReturnsOnCall[len(fake.getIAMAddonsStacksArgsForCall)]
	fake.getIAMAddonsStacksArgsForCall = append(fake.getIAMAddonsStacksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetIAMAddonsStacksStub
	fakeReturns := fake.getIAMAddonsStacksReturns
	fake.recordInvocation("GetIAMAddonsStacks", []interface{}{arg1})
	fake.getIAMAddonsStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetIAMAddonsStacksCallCount() int {
	fake.getIAMAddonsStacksMutex.RLock()
	defer fake.getIAMAddonsStacksMutex.RUnlock()
	return len(fake.getIAMAddonsStacksArgsForCall)
}

func (fake *FakeStackManager) GetIAMAddonsStacksCalls(stub func(context.Context) ([]*types.Stack, error)) {
	fake.getIAMAddonsStacksMutex.Lock()
	defer fake.getIAMAddonsStacksMutex.Unlock()
	fake.GetIAMAddonsStacksStub = stub
}

func (fake *FakeStackManager) GetIAMAddonsStacksArgsForCall(i int) context.Context {
	fake.getIAMAddonsStacksMutex.RLock()
	defer fake.getIAMAddonsStacksMutex.RUnlock()
	argsForCall := fake.getIAMAddonsStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetIAMAddonsStacksReturns(result1 []*types.Stack, result2 error) {
	fake.getIAMAddonsStacksMutex.Lock()
	defer fake.getIAMAddonsStacksMutex.Unlock()
	fake.GetIAMAddonsStacksStub = nil
	fake.getIAMAddonsStacksReturns = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMAddonsStacksReturnsOnCall(i int, result1 []*types.Stack, result2 error) {
	fake.getIAMAddonsStacksMutex.Lock()
	defer fake.getIAMAddonsStacksMutex.Unlock()
	fake.GetIAMAddonsStacksStub = nil
	if fake.getIAMAddonsStacksReturnsOnCall == nil {
		fake.getIAMAddonsStacksReturnsOnCall = make(map[int]struct {
			result1 []*types.Stack
			result2 error
		})
	}
	fake.getIAMAddonsStacksReturnsOnCall[i] = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMServiceAccounts(arg1 context.Context) ([]*v1alpha5.ClusterIAMServiceAccount, error) {
	fake.getIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.getIAMServiceAccountsReturnsOnCall[len(fake.getIAMServiceAccountsArgsForCall)]
	fake.getIAMServiceAccountsArgsForCall = append(fake.getIAMServiceAccountsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetIAMServiceAccountsStub
	fakeReturns := fake.getIAMServiceAccountsReturns
	fake.recordInvocation("GetIAMServiceAccounts", []interface{}{arg1})
	fake.getIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetIAMServiceAccountsCallCount() int {
	fake.getIAMServiceAccountsMutex.RLock()
	defer fake.getIAMServiceAccountsMutex.RUnlock()
	return len(fake.getIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) GetIAMServiceAccountsCalls(stub func(context.Context) ([]*v1alpha5.ClusterIAMServiceAccount, error)) {
	fake.getIAMServiceAccountsMutex.Lock()
	defer fake.getIAMServiceAccountsMutex.Unlock()
	fake.GetIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) GetIAMServiceAccountsArgsForCall(i int) context.Context {
	fake.getIAMServiceAccountsMutex.RLock()
	defer fake.getIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.getIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetIAMServiceAccountsReturns(result1 []*v1alpha5.ClusterIAMServiceAccount, result2 error) {
	fake.getIAMServiceAccountsMutex.Lock()
	defer fake.getIAMServiceAccountsMutex.Unlock()
	fake.GetIAMServiceAccountsStub = nil
	fake.getIAMServiceAccountsReturns = struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetIAMServiceAccountsReturnsOnCall(i int, result1 []*v1alpha5.ClusterIAMServiceAccount, result2 error) {
	fake.getIAMServiceAccountsMutex.Lock()
	defer fake.getIAMServiceAccountsMutex.Unlock()
	fake.GetIAMServiceAccountsStub = nil
	if fake.getIAMServiceAccountsReturnsOnCall == nil {
		fake.getIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 []*v1alpha5.ClusterIAMServiceAccount
			result2 error
		})
	}
	fake.getIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 []*v1alpha5.ClusterIAMServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetKarpenterStack(arg1 context.Context) (*types.Stack, error) {
	fake.getKarpenterStackMutex.Lock()
	ret, specificReturn := fake.getKarpenterStackReturnsOnCall[len(fake.getKarpenterStackArgsForCall)]
	fake.getKarpenterStackArgsForCall = append(fake.getKarpenterStackArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetKarpenterStackStub
	fakeReturns := fake.getKarpenterStackReturns
	fake.recordInvocation("GetKarpenterStack", []interface{}{arg1})
	fake.getKarpenterStackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetKarpenterStackCallCount() int {
	fake.getKarpenterStackMutex.RLock()
	defer fake.getKarpenterStackMutex.RUnlock()
	return len(fake.getKarpenterStackArgsForCall)
}

func (fake *FakeStackManager) GetKarpenterStackCalls(stub func(context.Context) (*types.Stack, error)) {
	fake.getKarpenterStackMutex.Lock()
	defer fake.getKarpenterStackMutex.Unlock()
	fake.GetKarpenterStackStub = stub
}

func (fake *FakeStackManager) GetKarpenterStackArgsForCall(i int) context.Context {
	fake.getKarpenterStackMutex.RLock()
	defer fake.getKarpenterStackMutex.RUnlock()
	argsForCall := fake.getKarpenterStackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetKarpenterStackReturns(result1 *types.Stack, result2 error) {
	fake.getKarpenterStackMutex.Lock()
	defer fake.getKarpenterStackMutex.Unlock()
	fake.GetKarpenterStackStub = nil
	fake.getKarpenterStackReturns = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetKarpenterStackReturnsOnCall(i int, result1 *types.Stack, result2 error) {
	fake.getKarpenterStackMutex.Lock()
	defer fake.getKarpenterStackMutex.Unlock()
	fake.GetKarpenterStackStub = nil
	if fake.getKarpenterStackReturnsOnCall == nil {
		fake.getKarpenterStackReturnsOnCall = make(map[int]struct {
			result1 *types.Stack
			result2 error
		})
	}
	fake.getKarpenterStackReturnsOnCall[i] = struct {
		result1 *types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplate(arg1 context.Context, arg2 manager.GetNodegroupOption) (string, error) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	ret, specificReturn := fake.getManagedNodeGroupTemplateReturnsOnCall[len(fake.getManagedNodeGroupTemplateArgsForCall)]
	fake.getManagedNodeGroupTemplateArgsForCall = append(fake.getManagedNodeGroupTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 manager.GetNodegroupOption
	}{arg1, arg2})
	stub := fake.GetManagedNodeGroupTemplateStub
	fakeReturns := fake.getManagedNodeGroupTemplateReturns
	fake.recordInvocation("GetManagedNodeGroupTemplate", []interface{}{arg1, arg2})
	fake.getManagedNodeGroupTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateCallCount() int {
	fake.getManagedNodeGroupTemplateMutex.RLock()
	defer fake.getManagedNodeGroupTemplateMutex.RUnlock()
	return len(fake.getManagedNodeGroupTemplateArgsForCall)
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateCalls(stub func(context.Context, manager.GetNodegroupOption) (string, error)) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	defer fake.getManagedNodeGroupTemplateMutex.Unlock()
	fake.GetManagedNodeGroupTemplateStub = stub
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateArgsForCall(i int) (context.Context, manager.GetNodegroupOption) {
	fake.getManagedNodeGroupTemplateMutex.RLock()
	defer fake.getManagedNodeGroupTemplateMutex.RUnlock()
	argsForCall := fake.getManagedNodeGroupTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateReturns(result1 string, result2 error) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	defer fake.getManagedNodeGroupTemplateMutex.Unlock()
	fake.GetManagedNodeGroupTemplateStub = nil
	fake.getManagedNodeGroupTemplateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetManagedNodeGroupTemplateReturnsOnCall(i int, result1 string, result2 error) {
	fake.getManagedNodeGroupTemplateMutex.Lock()
	defer fake.getManagedNodeGroupTemplateMutex.Unlock()
	fake.GetManagedNodeGroupTemplateStub = nil
	if fake.getManagedNodeGroupTemplateReturnsOnCall == nil {
		fake.getManagedNodeGroupTemplateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getManagedNodeGroupTemplateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupName(arg1 *types.Stack) string {
	fake.getNodeGroupNameMutex.Lock()
	ret, specificReturn := fake.getNodeGroupNameReturnsOnCall[len(fake.getNodeGroupNameArgsForCall)]
	fake.getNodeGroupNameArgsForCall = append(fake.getNodeGroupNameArgsForCall, struct {
		arg1 *types.Stack
	}{arg1})
	stub := fake.GetNodeGroupNameStub
	fakeReturns := fake.getNodeGroupNameReturns
	fake.recordInvocation("GetNodeGroupName", []interface{}{arg1})
	fake.getNodeGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) GetNodeGroupNameCallCount() int {
	fake.getNodeGroupNameMutex.RLock()
	defer fake.getNodeGroupNameMutex.RUnlock()
	return len(fake.getNodeGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetNodeGroupNameCalls(stub func(*types.Stack) string) {
	fake.getNodeGroupNameMutex.Lock()
	defer fake.getNodeGroupNameMutex.Unlock()
	fake.GetNodeGroupNameStub = stub
}

func (fake *FakeStackManager) GetNodeGroupNameArgsForCall(i int) *types.Stack {
	fake.getNodeGroupNameMutex.RLock()
	defer fake.getNodeGroupNameMutex.RUnlock()
	argsForCall := fake.getNodeGroupNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) GetNodeGroupNameReturns(result1 string) {
	fake.getNodeGroupNameMutex.Lock()
	defer fake.getNodeGroupNameMutex.Unlock()
	fake.GetNodeGroupNameStub = nil
	fake.getNodeGroupNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetNodeGroupNameReturnsOnCall(i int, result1 string) {
	fake.getNodeGroupNameMutex.Lock()
	defer fake.getNodeGroupNameMutex.Unlock()
	fake.GetNodeGroupNameStub = nil
	if fake.getNodeGroupNameReturnsOnCall == nil {
		fake.getNodeGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getNodeGroupNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) GetNodeGroupStackType(arg1 context.Context, arg2 manager.GetNodegroupOption) (v1alpha5.NodeGroupType, error) {
	fake.getNodeGroupStackTypeMutex.Lock()
	ret, specificReturn := fake.getNodeGroupStackTypeReturnsOnCall[len(fake.getNodeGroupStackTypeArgsForCall)]
	fake.getNodeGroupStackTypeArgsForCall = append(fake.getNodeGroupStackTypeArgsForCall, struct {
		arg1 context.Context
		arg2 manager.GetNodegroupOption
	}{arg1, arg2})
	stub := fake.GetNodeGroupStackTypeStub
	fakeReturns := fake.getNodeGroupStackTypeReturns
	fake.recordInvocation("GetNodeGroupStackType", []interface{}{arg1, arg2})
	fake.getNodeGroupStackTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetNodeGroupStackTypeCallCount() int {
	fake.getNodeGroupStackTypeMutex.RLock()
	defer fake.getNodeGroupStackTypeMutex.RUnlock()
	return len(fake.getNodeGroupStackTypeArgsForCall)
}

func (fake *FakeStackManager) GetNodeGroupStackTypeCalls(stub func(context.Context, manager.GetNodegroupOption) (v1alpha5.NodeGroupType, error)) {
	fake.getNodeGroupStackTypeMutex.Lock()
	defer fake.getNodeGroupStackTypeMutex.Unlock()
	fake.GetNodeGroupStackTypeStub = stub
}

func (fake *FakeStackManager) GetNodeGroupStackTypeArgsForCall(i int) (context.Context, manager.GetNodegroupOption) {
	fake.getNodeGroupStackTypeMutex.RLock()
	defer fake.getNodeGroupStackTypeMutex.RUnlock()
	argsForCall := fake.getNodeGroupStackTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) GetNodeGroupStackTypeReturns(result1 v1alpha5.NodeGroupType, result2 error) {
	fake.getNodeGroupStackTypeMutex.Lock()
	defer fake.getNodeGroupStackTypeMutex.Unlock()
	fake.GetNodeGroupStackTypeStub = nil
	fake.getNodeGroupStackTypeReturns = struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetNodeGroupStackTypeReturnsOnCall(i int, result1 v1alpha5.NodeGroupType, result2 error) {
	fake.getNodeGroupStackTypeMutex.Lock()
	defer fake.getNodeGroupStackTypeMutex.Unlock()
	fake.GetNodeGroupStackTypeStub = nil
	if fake.getNodeGroupStackTypeReturnsOnCall == nil {
		fake.getNodeGroupStackTypeReturnsOnCall = make(map[int]struct {
			result1 v1alpha5.NodeGroupType
			result2 error
		})
	}
	fake.getNodeGroupStackTypeReturnsOnCall[i] = struct {
		result1 v1alpha5.NodeGroupType
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetStackTemplate(arg1 context.Context, arg2 string) (string, error) {
	fake.getStackTemplateMutex.Lock()
	ret, specificReturn := fake.getStackTemplateReturnsOnCall[len(fake.getStackTemplateArgsForCall)]
	fake.getStackTemplateArgsForCall = append(fake.getStackTemplateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStackTemplateStub
	fakeReturns := fake.getStackTemplateReturns
	fake.recordInvocation("GetStackTemplate", []interface{}{arg1, arg2})
	fake.getStackTemplateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetStackTemplateCallCount() int {
	fake.getStackTemplateMutex.RLock()
	defer fake.getStackTemplateMutex.RUnlock()
	return len(fake.getStackTemplateArgsForCall)
}

func (fake *FakeStackManager) GetStackTemplateCalls(stub func(context.Context, string) (string, error)) {
	fake.getStackTemplateMutex.Lock()
	defer fake.getStackTemplateMutex.Unlock()
	fake.GetStackTemplateStub = stub
}

func (fake *FakeStackManager) GetStackTemplateArgsForCall(i int) (context.Context, string) {
	fake.getStackTemplateMutex.RLock()
	defer fake.getStackTemplateMutex.RUnlock()
	argsForCall := fake.getStackTemplateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) GetStackTemplateReturns(result1 string, result2 error) {
	fake.getStackTemplateMutex.Lock()
	defer fake.getStackTemplateMutex.Unlock()
	fake.GetStackTemplateStub = nil
	fake.getStackTemplateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetStackTemplateReturnsOnCall(i int, result1 string, result2 error) {
	fake.getStackTemplateMutex.Lock()
	defer fake.getStackTemplateMutex.Unlock()
	fake.GetStackTemplateStub = nil
	if fake.getStackTemplateReturnsOnCall == nil {
		fake.getStackTemplateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStackTemplateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetUnmanagedNodeGroupAutoScalingGroupName(arg1 context.Context, arg2 *types.Stack) (string, error) {
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Lock()
	ret, specificReturn := fake.getUnmanagedNodeGroupAutoScalingGroupNameReturnsOnCall[len(fake.getUnmanagedNodeGroupAutoScalingGroupNameArgsForCall)]
	fake.getUnmanagedNodeGroupAutoScalingGroupNameArgsForCall = append(fake.getUnmanagedNodeGroupAutoScalingGroupNameArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.GetUnmanagedNodeGroupAutoScalingGroupNameStub
	fakeReturns := fake.getUnmanagedNodeGroupAutoScalingGroupNameReturns
	fake.recordInvocation("GetUnmanagedNodeGroupAutoScalingGroupName", []interface{}{arg1, arg2})
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) GetUnmanagedNodeGroupAutoScalingGroupNameCallCount() int {
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.RUnlock()
	return len(fake.getUnmanagedNodeGroupAutoScalingGroupNameArgsForCall)
}

func (fake *FakeStackManager) GetUnmanagedNodeGroupAutoScalingGroupNameCalls(stub func(context.Context, *types.Stack) (string, error)) {
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetUnmanagedNodeGroupAutoScalingGroupNameStub = stub
}

func (fake *FakeStackManager) GetUnmanagedNodeGroupAutoScalingGroupNameArgsForCall(i int) (context.Context, *types.Stack) {
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.RUnlock()
	argsForCall := fake.getUnmanagedNodeGroupAutoScalingGroupNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) GetUnmanagedNodeGroupAutoScalingGroupNameReturns(result1 string, result2 error) {
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetUnmanagedNodeGroupAutoScalingGroupNameStub = nil
	fake.getUnmanagedNodeGroupAutoScalingGroupNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) GetUnmanagedNodeGroupAutoScalingGroupNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Lock()
	defer fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.Unlock()
	fake.GetUnmanagedNodeGroupAutoScalingGroupNameStub = nil
	if fake.getUnmanagedNodeGroupAutoScalingGroupNameReturnsOnCall == nil {
		fake.getUnmanagedNodeGroupAutoScalingGroupNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUnmanagedNodeGroupAutoScalingGroupNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) HasClusterStackFromList(arg1 context.Context, arg2 []string, arg3 string) (bool, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.hasClusterStackFromListMutex.Lock()
	ret, specificReturn := fake.hasClusterStackFromListReturnsOnCall[len(fake.hasClusterStackFromListArgsForCall)]
	fake.hasClusterStackFromListArgsForCall = append(fake.hasClusterStackFromListArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 string
	}{arg1, arg2Copy, arg3})
	stub := fake.HasClusterStackFromListStub
	fakeReturns := fake.hasClusterStackFromListReturns
	fake.recordInvocation("HasClusterStackFromList", []interface{}{arg1, arg2Copy, arg3})
	fake.hasClusterStackFromListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) HasClusterStackFromListCallCount() int {
	fake.hasClusterStackFromListMutex.RLock()
	defer fake.hasClusterStackFromListMutex.RUnlock()
	return len(fake.hasClusterStackFromListArgsForCall)
}

func (fake *FakeStackManager) HasClusterStackFromListCalls(stub func(context.Context, []string, string) (bool, error)) {
	fake.hasClusterStackFromListMutex.Lock()
	defer fake.hasClusterStackFromListMutex.Unlock()
	fake.HasClusterStackFromListStub = stub
}

func (fake *FakeStackManager) HasClusterStackFromListArgsForCall(i int) (context.Context, []string, string) {
	fake.hasClusterStackFromListMutex.RLock()
	defer fake.hasClusterStackFromListMutex.RUnlock()
	argsForCall := fake.hasClusterStackFromListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) HasClusterStackFromListReturns(result1 bool, result2 error) {
	fake.hasClusterStackFromListMutex.Lock()
	defer fake.hasClusterStackFromListMutex.Unlock()
	fake.HasClusterStackFromListStub = nil
	fake.hasClusterStackFromListReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) HasClusterStackFromListReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasClusterStackFromListMutex.Lock()
	defer fake.hasClusterStackFromListMutex.Unlock()
	fake.HasClusterStackFromListStub = nil
	if fake.hasClusterStackFromListReturnsOnCall == nil {
		fake.hasClusterStackFromListReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasClusterStackFromListReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListAccessEntryStackNames(arg1 context.Context, arg2 string) ([]string, error) {
	fake.listAccessEntryStackNamesMutex.Lock()
	ret, specificReturn := fake.listAccessEntryStackNamesReturnsOnCall[len(fake.listAccessEntryStackNamesArgsForCall)]
	fake.listAccessEntryStackNamesArgsForCall = append(fake.listAccessEntryStackNamesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ListAccessEntryStackNamesStub
	fakeReturns := fake.listAccessEntryStackNamesReturns
	fake.recordInvocation("ListAccessEntryStackNames", []interface{}{arg1, arg2})
	fake.listAccessEntryStackNamesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListAccessEntryStackNamesCallCount() int {
	fake.listAccessEntryStackNamesMutex.RLock()
	defer fake.listAccessEntryStackNamesMutex.RUnlock()
	return len(fake.listAccessEntryStackNamesArgsForCall)
}

func (fake *FakeStackManager) ListAccessEntryStackNamesCalls(stub func(context.Context, string) ([]string, error)) {
	fake.listAccessEntryStackNamesMutex.Lock()
	defer fake.listAccessEntryStackNamesMutex.Unlock()
	fake.ListAccessEntryStackNamesStub = stub
}

func (fake *FakeStackManager) ListAccessEntryStackNamesArgsForCall(i int) (context.Context, string) {
	fake.listAccessEntryStackNamesMutex.RLock()
	defer fake.listAccessEntryStackNamesMutex.RUnlock()
	argsForCall := fake.listAccessEntryStackNamesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) ListAccessEntryStackNamesReturns(result1 []string, result2 error) {
	fake.listAccessEntryStackNamesMutex.Lock()
	defer fake.listAccessEntryStackNamesMutex.Unlock()
	fake.ListAccessEntryStackNamesStub = nil
	fake.listAccessEntryStackNamesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListAccessEntryStackNamesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listAccessEntryStackNamesMutex.Lock()
	defer fake.listAccessEntryStackNamesMutex.Unlock()
	fake.ListAccessEntryStackNamesStub = nil
	if fake.listAccessEntryStackNamesReturnsOnCall == nil {
		fake.listAccessEntryStackNamesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listAccessEntryStackNamesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListClusterStackNames(arg1 context.Context) ([]string, error) {
	fake.listClusterStackNamesMutex.Lock()
	ret, specificReturn := fake.listClusterStackNamesReturnsOnCall[len(fake.listClusterStackNamesArgsForCall)]
	fake.listClusterStackNamesArgsForCall = append(fake.listClusterStackNamesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListClusterStackNamesStub
	fakeReturns := fake.listClusterStackNamesReturns
	fake.recordInvocation("ListClusterStackNames", []interface{}{arg1})
	fake.listClusterStackNamesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListClusterStackNamesCallCount() int {
	fake.listClusterStackNamesMutex.RLock()
	defer fake.listClusterStackNamesMutex.RUnlock()
	return len(fake.listClusterStackNamesArgsForCall)
}

func (fake *FakeStackManager) ListClusterStackNamesCalls(stub func(context.Context) ([]string, error)) {
	fake.listClusterStackNamesMutex.Lock()
	defer fake.listClusterStackNamesMutex.Unlock()
	fake.ListClusterStackNamesStub = stub
}

func (fake *FakeStackManager) ListClusterStackNamesArgsForCall(i int) context.Context {
	fake.listClusterStackNamesMutex.RLock()
	defer fake.listClusterStackNamesMutex.RUnlock()
	argsForCall := fake.listClusterStackNamesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListClusterStackNamesReturns(result1 []string, result2 error) {
	fake.listClusterStackNamesMutex.Lock()
	defer fake.listClusterStackNamesMutex.Unlock()
	fake.ListClusterStackNamesStub = nil
	fake.listClusterStackNamesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListClusterStackNamesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listClusterStackNamesMutex.Lock()
	defer fake.listClusterStackNamesMutex.Unlock()
	fake.ListClusterStackNamesStub = nil
	if fake.listClusterStackNamesReturnsOnCall == nil {
		fake.listClusterStackNamesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listClusterStackNamesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListIAMServiceAccountStacks(arg1 context.Context) ([]string, error) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	ret, specificReturn := fake.listIAMServiceAccountStacksReturnsOnCall[len(fake.listIAMServiceAccountStacksArgsForCall)]
	fake.listIAMServiceAccountStacksArgsForCall = append(fake.listIAMServiceAccountStacksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListIAMServiceAccountStacksStub
	fakeReturns := fake.listIAMServiceAccountStacksReturns
	fake.recordInvocation("ListIAMServiceAccountStacks", []interface{}{arg1})
	fake.listIAMServiceAccountStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksCallCount() int {
	fake.listIAMServiceAccountStacksMutex.RLock()
	defer fake.listIAMServiceAccountStacksMutex.RUnlock()
	return len(fake.listIAMServiceAccountStacksArgsForCall)
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksCalls(stub func(context.Context) ([]string, error)) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	defer fake.listIAMServiceAccountStacksMutex.Unlock()
	fake.ListIAMServiceAccountStacksStub = stub
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksArgsForCall(i int) context.Context {
	fake.listIAMServiceAccountStacksMutex.RLock()
	defer fake.listIAMServiceAccountStacksMutex.RUnlock()
	argsForCall := fake.listIAMServiceAccountStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksReturns(result1 []string, result2 error) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	defer fake.listIAMServiceAccountStacksMutex.Unlock()
	fake.ListIAMServiceAccountStacksStub = nil
	fake.listIAMServiceAccountStacksReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListIAMServiceAccountStacksReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listIAMServiceAccountStacksMutex.Lock()
	defer fake.listIAMServiceAccountStacksMutex.Unlock()
	fake.ListIAMServiceAccountStacksStub = nil
	if fake.listIAMServiceAccountStacksReturnsOnCall == nil {
		fake.listIAMServiceAccountStacksReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listIAMServiceAccountStacksReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListNodeGroupStacks(arg1 context.Context) ([]*types.Stack, error) {
	fake.listNodeGroupStacksMutex.Lock()
	ret, specificReturn := fake.listNodeGroupStacksReturnsOnCall[len(fake.listNodeGroupStacksArgsForCall)]
	fake.listNodeGroupStacksArgsForCall = append(fake.listNodeGroupStacksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListNodeGroupStacksStub
	fakeReturns := fake.listNodeGroupStacksReturns
	fake.recordInvocation("ListNodeGroupStacks", []interface{}{arg1})
	fake.listNodeGroupStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListNodeGroupStacksCallCount() int {
	fake.listNodeGroupStacksMutex.RLock()
	defer fake.listNodeGroupStacksMutex.RUnlock()
	return len(fake.listNodeGroupStacksArgsForCall)
}

func (fake *FakeStackManager) ListNodeGroupStacksCalls(stub func(context.Context) ([]*types.Stack, error)) {
	fake.listNodeGroupStacksMutex.Lock()
	defer fake.listNodeGroupStacksMutex.Unlock()
	fake.ListNodeGroupStacksStub = stub
}

func (fake *FakeStackManager) ListNodeGroupStacksArgsForCall(i int) context.Context {
	fake.listNodeGroupStacksMutex.RLock()
	defer fake.listNodeGroupStacksMutex.RUnlock()
	argsForCall := fake.listNodeGroupStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListNodeGroupStacksReturns(result1 []*types.Stack, result2 error) {
	fake.listNodeGroupStacksMutex.Lock()
	defer fake.listNodeGroupStacksMutex.Unlock()
	fake.ListNodeGroupStacksStub = nil
	fake.listNodeGroupStacksReturns = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListNodeGroupStacksReturnsOnCall(i int, result1 []*types.Stack, result2 error) {
	fake.listNodeGroupStacksMutex.Lock()
	defer fake.listNodeGroupStacksMutex.Unlock()
	fake.ListNodeGroupStacksStub = nil
	if fake.listNodeGroupStacksReturnsOnCall == nil {
		fake.listNodeGroupStacksReturnsOnCall = make(map[int]struct {
			result1 []*types.Stack
			result2 error
		})
	}
	fake.listNodeGroupStacksReturnsOnCall[i] = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListNodeGroupStacksWithStatuses(arg1 context.Context) ([]manager.NodeGroupStack, error) {
	fake.listNodeGroupStacksWithStatusesMutex.Lock()
	ret, specificReturn := fake.listNodeGroupStacksWithStatusesReturnsOnCall[len(fake.listNodeGroupStacksWithStatusesArgsForCall)]
	fake.listNodeGroupStacksWithStatusesArgsForCall = append(fake.listNodeGroupStacksWithStatusesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListNodeGroupStacksWithStatusesStub
	fakeReturns := fake.listNodeGroupStacksWithStatusesReturns
	fake.recordInvocation("ListNodeGroupStacksWithStatuses", []interface{}{arg1})
	fake.listNodeGroupStacksWithStatusesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListNodeGroupStacksWithStatusesCallCount() int {
	fake.listNodeGroupStacksWithStatusesMutex.RLock()
	defer fake.listNodeGroupStacksWithStatusesMutex.RUnlock()
	return len(fake.listNodeGroupStacksWithStatusesArgsForCall)
}

func (fake *FakeStackManager) ListNodeGroupStacksWithStatusesCalls(stub func(context.Context) ([]manager.NodeGroupStack, error)) {
	fake.listNodeGroupStacksWithStatusesMutex.Lock()
	defer fake.listNodeGroupStacksWithStatusesMutex.Unlock()
	fake.ListNodeGroupStacksWithStatusesStub = stub
}

func (fake *FakeStackManager) ListNodeGroupStacksWithStatusesArgsForCall(i int) context.Context {
	fake.listNodeGroupStacksWithStatusesMutex.RLock()
	defer fake.listNodeGroupStacksWithStatusesMutex.RUnlock()
	argsForCall := fake.listNodeGroupStacksWithStatusesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListNodeGroupStacksWithStatusesReturns(result1 []manager.NodeGroupStack, result2 error) {
	fake.listNodeGroupStacksWithStatusesMutex.Lock()
	defer fake.listNodeGroupStacksWithStatusesMutex.Unlock()
	fake.ListNodeGroupStacksWithStatusesStub = nil
	fake.listNodeGroupStacksWithStatusesReturns = struct {
		result1 []manager.NodeGroupStack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListNodeGroupStacksWithStatusesReturnsOnCall(i int, result1 []manager.NodeGroupStack, result2 error) {
	fake.listNodeGroupStacksWithStatusesMutex.Lock()
	defer fake.listNodeGroupStacksWithStatusesMutex.Unlock()
	fake.ListNodeGroupStacksWithStatusesStub = nil
	if fake.listNodeGroupStacksWithStatusesReturnsOnCall == nil {
		fake.listNodeGroupStacksWithStatusesReturnsOnCall = make(map[int]struct {
			result1 []manager.NodeGroupStack
			result2 error
		})
	}
	fake.listNodeGroupStacksWithStatusesReturnsOnCall[i] = struct {
		result1 []manager.NodeGroupStack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListPodIdentityStackNames(arg1 context.Context) ([]string, error) {
	fake.listPodIdentityStackNamesMutex.Lock()
	ret, specificReturn := fake.listPodIdentityStackNamesReturnsOnCall[len(fake.listPodIdentityStackNamesArgsForCall)]
	fake.listPodIdentityStackNamesArgsForCall = append(fake.listPodIdentityStackNamesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListPodIdentityStackNamesStub
	fakeReturns := fake.listPodIdentityStackNamesReturns
	fake.recordInvocation("ListPodIdentityStackNames", []interface{}{arg1})
	fake.listPodIdentityStackNamesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListPodIdentityStackNamesCallCount() int {
	fake.listPodIdentityStackNamesMutex.RLock()
	defer fake.listPodIdentityStackNamesMutex.RUnlock()
	return len(fake.listPodIdentityStackNamesArgsForCall)
}

func (fake *FakeStackManager) ListPodIdentityStackNamesCalls(stub func(context.Context) ([]string, error)) {
	fake.listPodIdentityStackNamesMutex.Lock()
	defer fake.listPodIdentityStackNamesMutex.Unlock()
	fake.ListPodIdentityStackNamesStub = stub
}

func (fake *FakeStackManager) ListPodIdentityStackNamesArgsForCall(i int) context.Context {
	fake.listPodIdentityStackNamesMutex.RLock()
	defer fake.listPodIdentityStackNamesMutex.RUnlock()
	argsForCall := fake.listPodIdentityStackNamesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListPodIdentityStackNamesReturns(result1 []string, result2 error) {
	fake.listPodIdentityStackNamesMutex.Lock()
	defer fake.listPodIdentityStackNamesMutex.Unlock()
	fake.ListPodIdentityStackNamesStub = nil
	fake.listPodIdentityStackNamesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListPodIdentityStackNamesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listPodIdentityStackNamesMutex.Lock()
	defer fake.listPodIdentityStackNamesMutex.Unlock()
	fake.ListPodIdentityStackNamesStub = nil
	if fake.listPodIdentityStackNamesReturnsOnCall == nil {
		fake.listPodIdentityStackNamesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listPodIdentityStackNamesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStackNames(arg1 context.Context, arg2 string) ([]string, error) {
	fake.listStackNamesMutex.Lock()
	ret, specificReturn := fake.listStackNamesReturnsOnCall[len(fake.listStackNamesArgsForCall)]
	fake.listStackNamesArgsForCall = append(fake.listStackNamesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ListStackNamesStub
	fakeReturns := fake.listStackNamesReturns
	fake.recordInvocation("ListStackNames", []interface{}{arg1, arg2})
	fake.listStackNamesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListStackNamesCallCount() int {
	fake.listStackNamesMutex.RLock()
	defer fake.listStackNamesMutex.RUnlock()
	return len(fake.listStackNamesArgsForCall)
}

func (fake *FakeStackManager) ListStackNamesCalls(stub func(context.Context, string) ([]string, error)) {
	fake.listStackNamesMutex.Lock()
	defer fake.listStackNamesMutex.Unlock()
	fake.ListStackNamesStub = stub
}

func (fake *FakeStackManager) ListStackNamesArgsForCall(i int) (context.Context, string) {
	fake.listStackNamesMutex.RLock()
	defer fake.listStackNamesMutex.RUnlock()
	argsForCall := fake.listStackNamesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) ListStackNamesReturns(result1 []string, result2 error) {
	fake.listStackNamesMutex.Lock()
	defer fake.listStackNamesMutex.Unlock()
	fake.ListStackNamesStub = nil
	fake.listStackNamesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStackNamesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listStackNamesMutex.Lock()
	defer fake.listStackNamesMutex.Unlock()
	fake.ListStackNamesStub = nil
	if fake.listStackNamesReturnsOnCall == nil {
		fake.listStackNamesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listStackNamesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacks(arg1 context.Context) ([]*types.Stack, error) {
	fake.listStacksMutex.Lock()
	ret, specificReturn := fake.listStacksReturnsOnCall[len(fake.listStacksArgsForCall)]
	fake.listStacksArgsForCall = append(fake.listStacksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListStacksStub
	fakeReturns := fake.listStacksReturns
	fake.recordInvocation("ListStacks", []interface{}{arg1})
	fake.listStacksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListStacksCallCount() int {
	fake.listStacksMutex.RLock()
	defer fake.listStacksMutex.RUnlock()
	return len(fake.listStacksArgsForCall)
}

func (fake *FakeStackManager) ListStacksCalls(stub func(context.Context) ([]*types.Stack, error)) {
	fake.listStacksMutex.Lock()
	defer fake.listStacksMutex.Unlock()
	fake.ListStacksStub = stub
}

func (fake *FakeStackManager) ListStacksArgsForCall(i int) context.Context {
	fake.listStacksMutex.RLock()
	defer fake.listStacksMutex.RUnlock()
	argsForCall := fake.listStacksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) ListStacksReturns(result1 []*types.Stack, result2 error) {
	fake.listStacksMutex.Lock()
	defer fake.listStacksMutex.Unlock()
	fake.ListStacksStub = nil
	fake.listStacksReturns = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksReturnsOnCall(i int, result1 []*types.Stack, result2 error) {
	fake.listStacksMutex.Lock()
	defer fake.listStacksMutex.Unlock()
	fake.ListStacksStub = nil
	if fake.listStacksReturnsOnCall == nil {
		fake.listStacksReturnsOnCall = make(map[int]struct {
			result1 []*types.Stack
			result2 error
		})
	}
	fake.listStacksReturnsOnCall[i] = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksMatching(arg1 context.Context, arg2 string, arg3 ...types.StackStatus) ([]*types.Stack, error) {
	fake.listStacksMatchingMutex.Lock()
	ret, specificReturn := fake.listStacksMatchingReturnsOnCall[len(fake.listStacksMatchingArgsForCall)]
	fake.listStacksMatchingArgsForCall = append(fake.listStacksMatchingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []types.StackStatus
	}{arg1, arg2, arg3})
	stub := fake.ListStacksMatchingStub
	fakeReturns := fake.listStacksMatchingReturns
	fake.recordInvocation("ListStacksMatching", []interface{}{arg1, arg2, arg3})
	fake.listStacksMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListStacksMatchingCallCount() int {
	fake.listStacksMatchingMutex.RLock()
	defer fake.listStacksMatchingMutex.RUnlock()
	return len(fake.listStacksMatchingArgsForCall)
}

func (fake *FakeStackManager) ListStacksMatchingCalls(stub func(context.Context, string, ...types.StackStatus) ([]*types.Stack, error)) {
	fake.listStacksMatchingMutex.Lock()
	defer fake.listStacksMatchingMutex.Unlock()
	fake.ListStacksMatchingStub = stub
}

func (fake *FakeStackManager) ListStacksMatchingArgsForCall(i int) (context.Context, string, []types.StackStatus) {
	fake.listStacksMatchingMutex.RLock()
	defer fake.listStacksMatchingMutex.RUnlock()
	argsForCall := fake.listStacksMatchingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) ListStacksMatchingReturns(result1 []*types.Stack, result2 error) {
	fake.listStacksMatchingMutex.Lock()
	defer fake.listStacksMatchingMutex.Unlock()
	fake.ListStacksMatchingStub = nil
	fake.listStacksMatchingReturns = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksMatchingReturnsOnCall(i int, result1 []*types.Stack, result2 error) {
	fake.listStacksMatchingMutex.Lock()
	defer fake.listStacksMatchingMutex.Unlock()
	fake.ListStacksMatchingStub = nil
	if fake.listStacksMatchingReturnsOnCall == nil {
		fake.listStacksMatchingReturnsOnCall = make(map[int]struct {
			result1 []*types.Stack
			result2 error
		})
	}
	fake.listStacksMatchingReturnsOnCall[i] = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksWithStatuses(arg1 context.Context, arg2 ...types.StackStatus) ([]*types.Stack, error) {
	fake.listStacksWithStatusesMutex.Lock()
	ret, specificReturn := fake.listStacksWithStatusesReturnsOnCall[len(fake.listStacksWithStatusesArgsForCall)]
	fake.listStacksWithStatusesArgsForCall = append(fake.listStacksWithStatusesArgsForCall, struct {
		arg1 context.Context
		arg2 []types.StackStatus
	}{arg1, arg2})
	stub := fake.ListStacksWithStatusesStub
	fakeReturns := fake.listStacksWithStatusesReturns
	fake.recordInvocation("ListStacksWithStatuses", []interface{}{arg1, arg2})
	fake.listStacksWithStatusesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) ListStacksWithStatusesCallCount() int {
	fake.listStacksWithStatusesMutex.RLock()
	defer fake.listStacksWithStatusesMutex.RUnlock()
	return len(fake.listStacksWithStatusesArgsForCall)
}

func (fake *FakeStackManager) ListStacksWithStatusesCalls(stub func(context.Context, ...types.StackStatus) ([]*types.Stack, error)) {
	fake.listStacksWithStatusesMutex.Lock()
	defer fake.listStacksWithStatusesMutex.Unlock()
	fake.ListStacksWithStatusesStub = stub
}

func (fake *FakeStackManager) ListStacksWithStatusesArgsForCall(i int) (context.Context, []types.StackStatus) {
	fake.listStacksWithStatusesMutex.RLock()
	defer fake.listStacksWithStatusesMutex.RUnlock()
	argsForCall := fake.listStacksWithStatusesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) ListStacksWithStatusesReturns(result1 []*types.Stack, result2 error) {
	fake.listStacksWithStatusesMutex.Lock()
	defer fake.listStacksWithStatusesMutex.Unlock()
	fake.ListStacksWithStatusesStub = nil
	fake.listStacksWithStatusesReturns = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) ListStacksWithStatusesReturnsOnCall(i int, result1 []*types.Stack, result2 error) {
	fake.listStacksWithStatusesMutex.Lock()
	defer fake.listStacksWithStatusesMutex.Unlock()
	fake.ListStacksWithStatusesStub = nil
	if fake.listStacksWithStatusesReturnsOnCall == nil {
		fake.listStacksWithStatusesReturnsOnCall = make(map[int]struct {
			result1 []*types.Stack
			result2 error
		})
	}
	fake.listStacksWithStatusesReturnsOnCall[i] = struct {
		result1 []*types.Stack
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) LookupCloudTrailEvents(arg1 context.Context, arg2 *types.Stack) ([]typesb.Event, error) {
	fake.lookupCloudTrailEventsMutex.Lock()
	ret, specificReturn := fake.lookupCloudTrailEventsReturnsOnCall[len(fake.lookupCloudTrailEventsArgsForCall)]
	fake.lookupCloudTrailEventsArgsForCall = append(fake.lookupCloudTrailEventsArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
	}{arg1, arg2})
	stub := fake.LookupCloudTrailEventsStub
	fakeReturns := fake.lookupCloudTrailEventsReturns
	fake.recordInvocation("LookupCloudTrailEvents", []interface{}{arg1, arg2})
	fake.lookupCloudTrailEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) LookupCloudTrailEventsCallCount() int {
	fake.lookupCloudTrailEventsMutex.RLock()
	defer fake.lookupCloudTrailEventsMutex.RUnlock()
	return len(fake.lookupCloudTrailEventsArgsForCall)
}

func (fake *FakeStackManager) LookupCloudTrailEventsCalls(stub func(context.Context, *types.Stack) ([]typesb.Event, error)) {
	fake.lookupCloudTrailEventsMutex.Lock()
	defer fake.lookupCloudTrailEventsMutex.Unlock()
	fake.LookupCloudTrailEventsStub = stub
}

func (fake *FakeStackManager) LookupCloudTrailEventsArgsForCall(i int) (context.Context, *types.Stack) {
	fake.lookupCloudTrailEventsMutex.RLock()
	defer fake.lookupCloudTrailEventsMutex.RUnlock()
	argsForCall := fake.lookupCloudTrailEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) LookupCloudTrailEventsReturns(result1 []typesb.Event, result2 error) {
	fake.lookupCloudTrailEventsMutex.Lock()
	defer fake.lookupCloudTrailEventsMutex.Unlock()
	fake.LookupCloudTrailEventsStub = nil
	fake.lookupCloudTrailEventsReturns = struct {
		result1 []typesb.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) LookupCloudTrailEventsReturnsOnCall(i int, result1 []typesb.Event, result2 error) {
	fake.lookupCloudTrailEventsMutex.Lock()
	defer fake.lookupCloudTrailEventsMutex.Unlock()
	fake.LookupCloudTrailEventsStub = nil
	if fake.lookupCloudTrailEventsReturnsOnCall == nil {
		fake.lookupCloudTrailEventsReturnsOnCall = make(map[int]struct {
			result1 []typesb.Event
			result2 error
		})
	}
	fake.lookupCloudTrailEventsReturnsOnCall[i] = struct {
		result1 []typesb.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) MakeChangeSetName(arg1 string) string {
	fake.makeChangeSetNameMutex.Lock()
	ret, specificReturn := fake.makeChangeSetNameReturnsOnCall[len(fake.makeChangeSetNameArgsForCall)]
	fake.makeChangeSetNameArgsForCall = append(fake.makeChangeSetNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.MakeChangeSetNameStub
	fakeReturns := fake.makeChangeSetNameReturns
	fake.recordInvocation("MakeChangeSetName", []interface{}{arg1})
	fake.makeChangeSetNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) MakeChangeSetNameCallCount() int {
	fake.makeChangeSetNameMutex.RLock()
	defer fake.makeChangeSetNameMutex.RUnlock()
	return len(fake.makeChangeSetNameArgsForCall)
}

func (fake *FakeStackManager) MakeChangeSetNameCalls(stub func(string) string) {
	fake.makeChangeSetNameMutex.Lock()
	defer fake.makeChangeSetNameMutex.Unlock()
	fake.MakeChangeSetNameStub = stub
}

func (fake *FakeStackManager) MakeChangeSetNameArgsForCall(i int) string {
	fake.makeChangeSetNameMutex.RLock()
	defer fake.makeChangeSetNameMutex.RUnlock()
	argsForCall := fake.makeChangeSetNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) MakeChangeSetNameReturns(result1 string) {
	fake.makeChangeSetNameMutex.Lock()
	defer fake.makeChangeSetNameMutex.Unlock()
	fake.MakeChangeSetNameStub = nil
	fake.makeChangeSetNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) MakeChangeSetNameReturnsOnCall(i int, result1 string) {
	fake.makeChangeSetNameMutex.Lock()
	defer fake.makeChangeSetNameMutex.Unlock()
	fake.MakeChangeSetNameStub = nil
	if fake.makeChangeSetNameReturnsOnCall == nil {
		fake.makeChangeSetNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.makeChangeSetNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) MakeClusterStackName() string {
	fake.makeClusterStackNameMutex.Lock()
	ret, specificReturn := fake.makeClusterStackNameReturnsOnCall[len(fake.makeClusterStackNameArgsForCall)]
	fake.makeClusterStackNameArgsForCall = append(fake.makeClusterStackNameArgsForCall, struct {
	}{})
	stub := fake.MakeClusterStackNameStub
	fakeReturns := fake.makeClusterStackNameReturns
	fake.recordInvocation("MakeClusterStackName", []interface{}{})
	fake.makeClusterStackNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) MakeClusterStackNameCallCount() int {
	fake.makeClusterStackNameMutex.RLock()
	defer fake.makeClusterStackNameMutex.RUnlock()
	return len(fake.makeClusterStackNameArgsForCall)
}

func (fake *FakeStackManager) MakeClusterStackNameCalls(stub func() string) {
	fake.makeClusterStackNameMutex.Lock()
	defer fake.makeClusterStackNameMutex.Unlock()
	fake.MakeClusterStackNameStub = stub
}

func (fake *FakeStackManager) MakeClusterStackNameReturns(result1 string) {
	fake.makeClusterStackNameMutex.Lock()
	defer fake.makeClusterStackNameMutex.Unlock()
	fake.MakeClusterStackNameStub = nil
	fake.makeClusterStackNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) MakeClusterStackNameReturnsOnCall(i int, result1 string) {
	fake.makeClusterStackNameMutex.Lock()
	defer fake.makeClusterStackNameMutex.Unlock()
	fake.MakeClusterStackNameStub = nil
	if fake.makeClusterStackNameReturnsOnCall == nil {
		fake.makeClusterStackNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.makeClusterStackNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeStackManager) MustUpdateStack(arg1 context.Context, arg2 manager.UpdateStackOptions) error {
	fake.mustUpdateStackMutex.Lock()
	ret, specificReturn := fake.mustUpdateStackReturnsOnCall[len(fake.mustUpdateStackArgsForCall)]
	fake.mustUpdateStackArgsForCall = append(fake.mustUpdateStackArgsForCall, struct {
		arg1 context.Context
		arg2 manager.UpdateStackOptions
	}{arg1, arg2})
	stub := fake.MustUpdateStackStub
	fakeReturns := fake.mustUpdateStackReturns
	fake.recordInvocation("MustUpdateStack", []interface{}{arg1, arg2})
	fake.mustUpdateStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) MustUpdateStackCallCount() int {
	fake.mustUpdateStackMutex.RLock()
	defer fake.mustUpdateStackMutex.RUnlock()
	return len(fake.mustUpdateStackArgsForCall)
}

func (fake *FakeStackManager) MustUpdateStackCalls(stub func(context.Context, manager.UpdateStackOptions) error) {
	fake.mustUpdateStackMutex.Lock()
	defer fake.mustUpdateStackMutex.Unlock()
	fake.MustUpdateStackStub = stub
}

func (fake *FakeStackManager) MustUpdateStackArgsForCall(i int) (context.Context, manager.UpdateStackOptions) {
	fake.mustUpdateStackMutex.RLock()
	defer fake.mustUpdateStackMutex.RUnlock()
	argsForCall := fake.mustUpdateStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) MustUpdateStackReturns(result1 error) {
	fake.mustUpdateStackMutex.Lock()
	defer fake.mustUpdateStackMutex.Unlock()
	fake.MustUpdateStackStub = nil
	fake.mustUpdateStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) MustUpdateStackReturnsOnCall(i int, result1 error) {
	fake.mustUpdateStackMutex.Lock()
	defer fake.mustUpdateStackMutex.Unlock()
	fake.MustUpdateStackStub = nil
	if fake.mustUpdateStackReturnsOnCall == nil {
		fake.mustUpdateStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mustUpdateStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) NewManagedNodeGroupTask(arg1 context.Context, arg2 []*v1alpha5.ManagedNodeGroup, arg3 bool, arg4 vpc.Importer) *tasks.TaskTree {
	var arg2Copy []*v1alpha5.ManagedNodeGroup
	if arg2 != nil {
		arg2Copy = make([]*v1alpha5.ManagedNodeGroup, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newManagedNodeGroupTaskMutex.Lock()
	ret, specificReturn := fake.newManagedNodeGroupTaskReturnsOnCall[len(fake.newManagedNodeGroupTaskArgsForCall)]
	fake.newManagedNodeGroupTaskArgsForCall = append(fake.newManagedNodeGroupTaskArgsForCall, struct {
		arg1 context.Context
		arg2 []*v1alpha5.ManagedNodeGroup
		arg3 bool
		arg4 vpc.Importer
	}{arg1, arg2Copy, arg3, arg4})
	stub := fake.NewManagedNodeGroupTaskStub
	fakeReturns := fake.newManagedNodeGroupTaskReturns
	fake.recordInvocation("NewManagedNodeGroupTask", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.newManagedNodeGroupTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskCallCount() int {
	fake.newManagedNodeGroupTaskMutex.RLock()
	defer fake.newManagedNodeGroupTaskMutex.RUnlock()
	return len(fake.newManagedNodeGroupTaskArgsForCall)
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskCalls(stub func(context.Context, []*v1alpha5.ManagedNodeGroup, bool, vpc.Importer) *tasks.TaskTree) {
	fake.newManagedNodeGroupTaskMutex.Lock()
	defer fake.newManagedNodeGroupTaskMutex.Unlock()
	fake.NewManagedNodeGroupTaskStub = stub
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskArgsForCall(i int) (context.Context, []*v1alpha5.ManagedNodeGroup, bool, vpc.Importer) {
	fake.newManagedNodeGroupTaskMutex.RLock()
	defer fake.newManagedNodeGroupTaskMutex.RUnlock()
	argsForCall := fake.newManagedNodeGroupTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskReturns(result1 *tasks.TaskTree) {
	fake.newManagedNodeGroupTaskMutex.Lock()
	defer fake.newManagedNodeGroupTaskMutex.Unlock()
	fake.NewManagedNodeGroupTaskStub = nil
	fake.newManagedNodeGroupTaskReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewManagedNodeGroupTaskReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newManagedNodeGroupTaskMutex.Lock()
	defer fake.newManagedNodeGroupTaskMutex.Unlock()
	fake.NewManagedNodeGroupTaskStub = nil
	if fake.newManagedNodeGroupTaskReturnsOnCall == nil {
		fake.newManagedNodeGroupTaskReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newManagedNodeGroupTaskReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTaskToDeleteUnownedNodeGroup(arg1 context.Context, arg2 string, arg3 string, arg4 manager.NodeGroupDeleter, arg5 *manager.DeleteWaitCondition) tasks.Task {
	fake.newTaskToDeleteUnownedNodeGroupMutex.Lock()
	ret, specificReturn := fake.newTaskToDeleteUnownedNodeGroupReturnsOnCall[len(fake.newTaskToDeleteUnownedNodeGroupArgsForCall)]
	fake.newTaskToDeleteUnownedNodeGroupArgsForCall = append(fake.newTaskToDeleteUnownedNodeGroupArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 manager.NodeGroupDeleter
		arg5 *manager.DeleteWaitCondition
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NewTaskToDeleteUnownedNodeGroupStub
	fakeReturns := fake.newTaskToDeleteUnownedNodeGroupReturns
	fake.recordInvocation("NewTaskToDeleteUnownedNodeGroup", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.newTaskToDeleteUnownedNodeGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewTaskToDeleteUnownedNodeGroupCallCount() int {
	fake.newTaskToDeleteUnownedNodeGroupMutex.RLock()
	defer fake.newTaskToDeleteUnownedNodeGroupMutex.RUnlock()
	return len(fake.newTaskToDeleteUnownedNodeGroupArgsForCall)
}

func (fake *FakeStackManager) NewTaskToDeleteUnownedNodeGroupCalls(stub func(context.Context, string, string, manager.NodeGroupDeleter, *manager.DeleteWaitCondition) tasks.Task) {
	fake.newTaskToDeleteUnownedNodeGroupMutex.Lock()
	defer fake.newTaskToDeleteUnownedNodeGroupMutex.Unlock()
	fake.NewTaskToDeleteUnownedNodeGroupStub = stub
}

func (fake *FakeStackManager) NewTaskToDeleteUnownedNodeGroupArgsForCall(i int) (context.Context, string, string, manager.NodeGroupDeleter, *manager.DeleteWaitCondition) {
	fake.newTaskToDeleteUnownedNodeGroupMutex.RLock()
	defer fake.newTaskToDeleteUnownedNodeGroupMutex.RUnlock()
	argsForCall := fake.newTaskToDeleteUnownedNodeGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStackManager) NewTaskToDeleteUnownedNodeGroupReturns(result1 tasks.Task) {
	fake.newTaskToDeleteUnownedNodeGroupMutex.Lock()
	defer fake.newTaskToDeleteUnownedNodeGroupMutex.Unlock()
	fake.NewTaskToDeleteUnownedNodeGroupStub = nil
	fake.newTaskToDeleteUnownedNodeGroupReturns = struct {
		result1 tasks.Task
	}{result1}
}

func (fake *FakeStackManager) NewTaskToDeleteUnownedNodeGroupReturnsOnCall(i int, result1 tasks.Task) {
	fake.newTaskToDeleteUnownedNodeGroupMutex.Lock()
	defer fake.newTaskToDeleteUnownedNodeGroupMutex.Unlock()
	fake.NewTaskToDeleteUnownedNodeGroupStub = nil
	if fake.newTaskToDeleteUnownedNodeGroupReturnsOnCall == nil {
		fake.newTaskToDeleteUnownedNodeGroupReturnsOnCall = make(map[int]struct {
			result1 tasks.Task
		})
	}
	fake.newTaskToDeleteUnownedNodeGroupReturnsOnCall[i] = struct {
		result1 tasks.Task
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateCluster(arg1 context.Context, arg2 []*v1alpha5.NodeGroup, arg3 []*v1alpha5.ManagedNodeGroup, arg4 []v1alpha5.AccessEntry, arg5 accessentry.CreatorInterface, arg6 ...tasks.Task) *tasks.TaskTree {
	var arg2Copy []*v1alpha5.NodeGroup
	if arg2 != nil {
		arg2Copy = make([]*v1alpha5.NodeGroup, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []*v1alpha5.ManagedNodeGroup
	if arg3 != nil {
		arg3Copy = make([]*v1alpha5.ManagedNodeGroup, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []v1alpha5.AccessEntry
	if arg4 != nil {
		arg4Copy = make([]v1alpha5.AccessEntry, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.newTasksToCreateClusterMutex.Lock()
	ret, specificReturn := fake.newTasksToCreateClusterReturnsOnCall[len(fake.newTasksToCreateClusterArgsForCall)]
	fake.newTasksToCreateClusterArgsForCall = append(fake.newTasksToCreateClusterArgsForCall, struct {
		arg1 context.Context
		arg2 []*v1alpha5.NodeGroup
		arg3 []*v1alpha5.ManagedNodeGroup
		arg4 []v1alpha5.AccessEntry
		arg5 accessentry.CreatorInterface
		arg6 []tasks.Task
	}{arg1, arg2Copy, arg3Copy, arg4Copy, arg5, arg6})
	stub := fake.NewTasksToCreateClusterStub
	fakeReturns := fake.newTasksToCreateClusterReturns
	fake.recordInvocation("NewTasksToCreateCluster", []interface{}{arg1, arg2Copy, arg3Copy, arg4Copy, arg5, arg6})
	fake.newTasksToCreateClusterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewTasksToCreateClusterCallCount() int {
	fake.newTasksToCreateClusterMutex.RLock()
	defer fake.newTasksToCreateClusterMutex.RUnlock()
	return len(fake.newTasksToCreateClusterArgsForCall)
}

func (fake *FakeStackManager) NewTasksToCreateClusterCalls(stub func(context.Context, []*v1alpha5.NodeGroup, []*v1alpha5.ManagedNodeGroup, []v1alpha5.AccessEntry, accessentry.CreatorInterface, ...tasks.Task) *tasks.TaskTree) {
	fake.newTasksToCreateClusterMutex.Lock()
	defer fake.newTasksToCreateClusterMutex.Unlock()
	fake.NewTasksToCreateClusterStub = stub
}

func (fake *FakeStackManager) NewTasksToCreateClusterArgsForCall(i int) (context.Context, []*v1alpha5.NodeGroup, []*v1alpha5.ManagedNodeGroup, []v1alpha5.AccessEntry, accessentry.CreatorInterface, []tasks.Task) {
	fake.newTasksToCreateClusterMutex.RLock()
	defer fake.newTasksToCreateClusterMutex.RUnlock()
	argsForCall := fake.newTasksToCreateClusterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStackManager) NewTasksToCreateClusterReturns(result1 *tasks.TaskTree) {
	fake.newTasksToCreateClusterMutex.Lock()
	defer fake.newTasksToCreateClusterMutex.Unlock()
	fake.NewTasksToCreateClusterStub = nil
	fake.newTasksToCreateClusterReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateClusterReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newTasksToCreateClusterMutex.Lock()
	defer fake.newTasksToCreateClusterMutex.Unlock()
	fake.NewTasksToCreateClusterStub = nil
	if fake.newTasksToCreateClusterReturnsOnCall == nil {
		fake.newTasksToCreateClusterReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newTasksToCreateClusterReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccounts(arg1 []*v1alpha5.ClusterIAMServiceAccount, arg2 *iamoidc.OpenIDConnectManager, arg3 kubernetes.ClientSetGetter) *tasks.TaskTree {
	var arg1Copy []*v1alpha5.ClusterIAMServiceAccount
	if arg1 != nil {
		arg1Copy = make([]*v1alpha5.ClusterIAMServiceAccount, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.newTasksToCreateIAMServiceAccountsReturnsOnCall[len(fake.newTasksToCreateIAMServiceAccountsArgsForCall)]
	fake.newTasksToCreateIAMServiceAccountsArgsForCall = append(fake.newTasksToCreateIAMServiceAccountsArgsForCall, struct {
		arg1 []*v1alpha5.ClusterIAMServiceAccount
		arg2 *iamoidc.OpenIDConnectManager
		arg3 kubernetes.ClientSetGetter
	}{arg1Copy, arg2, arg3})
	stub := fake.NewTasksToCreateIAMServiceAccountsStub
	fakeReturns := fake.newTasksToCreateIAMServiceAccountsReturns
	fake.recordInvocation("NewTasksToCreateIAMServiceAccounts", []interface{}{arg1Copy, arg2, arg3})
	fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsCallCount() int {
	fake.newTasksToCreateIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.RUnlock()
	return len(fake.newTasksToCreateIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsCalls(stub func([]*v1alpha5.ClusterIAMServiceAccount, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) *tasks.TaskTree) {
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToCreateIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsArgsForCall(i int) ([]*v1alpha5.ClusterIAMServiceAccount, *iamoidc.OpenIDConnectManager, kubernetes.ClientSetGetter) {
	fake.newTasksToCreateIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.newTasksToCreateIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsReturns(result1 *tasks.TaskTree) {
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToCreateIAMServiceAccountsStub = nil
	fake.newTasksToCreateIAMServiceAccountsReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToCreateIAMServiceAccountsReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newTasksToCreateIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToCreateIAMServiceAccountsStub = nil
	if fake.newTasksToCreateIAMServiceAccountsReturnsOnCall == nil {
		fake.newTasksToCreateIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newTasksToCreateIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroups(arg1 context.Context, arg2 *types.Stack, arg3 []manager.NodeGroupStack, arg4 bool, arg5 manager.NewOIDCManager, arg6 manager.NewTasksToDeleteAddonIAM, arg7 manager.NewTasksToDeletePodIdentityRole, arg8 *typesc.Cluster, arg9 kubernetes.ClientSetGetter, arg10 bool, arg11 bool, arg12 func(chan error, string) error) (*tasks.TaskTree, error) {
	var arg3Copy []manager.NodeGroupStack
	if arg3 != nil {
		arg3Copy = make([]manager.NodeGroupStack, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall[len(fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall)]
	fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall = append(fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall, struct {
		arg1  context.Context
		arg2  *types.Stack
		arg3  []manager.NodeGroupStack
		arg4  bool
		arg5  manager.NewOIDCManager
		arg6  manager.NewTasksToDeleteAddonIAM
		arg7  manager.NewTasksToDeletePodIdentityRole
		arg8  *typesc.Cluster
		arg9  kubernetes.ClientSetGetter
		arg10 bool
		arg11 bool
		arg12 func(chan error, string) error
	}{arg1, arg2, arg3Copy, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12})
	stub := fake.NewTasksToDeleteClusterWithNodeGroupsStub
	fakeReturns := fake.newTasksToDeleteClusterWithNodeGroupsReturns
	fake.recordInvocation("NewTasksToDeleteClusterWithNodeGroups", []interface{}{arg1, arg2, arg3Copy, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12})
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsCallCount() int {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.RUnlock()
	return len(fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsCalls(stub func(context.Context, *types.Stack, []manager.NodeGroupStack, bool, manager.NewOIDCManager, manager.NewTasksToDeleteAddonIAM, manager.NewTasksToDeletePodIdentityRole, *typesc.Cluster, kubernetes.ClientSetGetter, bool, bool, func(chan error, string) error) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteClusterWithNodeGroupsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsArgsForCall(i int) (context.Context, *types.Stack, []manager.NodeGroupStack, bool, manager.NewOIDCManager, manager.NewTasksToDeleteAddonIAM, manager.NewTasksToDeletePodIdentityRole, *typesc.Cluster, kubernetes.ClientSetGetter, bool, bool, func(chan error, string) error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteClusterWithNodeGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10, argsForCall.arg11, argsForCall.arg12
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteClusterWithNodeGroupsStub = nil
	fake.newTasksToDeleteClusterWithNodeGroupsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteClusterWithNodeGroupsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteClusterWithNodeGroupsStub = nil
	if fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall == nil {
		fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteClusterWithNodeGroupsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccounts(arg1 context.Context, arg2 []string, arg3 kubernetes.ClientSetGetter, arg4 bool) (*tasks.TaskTree, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall[len(fake.newTasksToDeleteIAMServiceAccountsArgsForCall)]
	fake.newTasksToDeleteIAMServiceAccountsArgsForCall = append(fake.newTasksToDeleteIAMServiceAccountsArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 kubernetes.ClientSetGetter
		arg4 bool
	}{arg1, arg2Copy, arg3, arg4})
	stub := fake.NewTasksToDeleteIAMServiceAccountsStub
	fakeReturns := fake.newTasksToDeleteIAMServiceAccountsReturns
	fake.recordInvocation("NewTasksToDeleteIAMServiceAccounts", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsCallCount() int {
	fake.newTasksToDeleteIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.RUnlock()
	return len(fake.newTasksToDeleteIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsCalls(stub func(context.Context, []string, kubernetes.ClientSetGetter, bool) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsArgsForCall(i int) (context.Context, []string, kubernetes.ClientSetGetter, bool) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteIAMServiceAccountsStub = nil
	fake.newTasksToDeleteIAMServiceAccountsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteIAMServiceAccountsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteIAMServiceAccountsStub = nil
	if fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall == nil {
		fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroups(arg1 []manager.NodeGroupStack, arg2 func(_ string) bool, arg3 bool, arg4 func(chan error, string) error) (*tasks.TaskTree, error) {
	var arg1Copy []manager.NodeGroupStack
	if arg1 != nil {
		arg1Copy = make([]manager.NodeGroupStack, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteNodeGroupsReturnsOnCall[len(fake.newTasksToDeleteNodeGroupsArgsForCall)]
	fake.newTasksToDeleteNodeGroupsArgsForCall = append(fake.newTasksToDeleteNodeGroupsArgsForCall, struct {
		arg1 []manager.NodeGroupStack
		arg2 func(_ string) bool
		arg3 bool
		arg4 func(chan error, string) error
	}{arg1Copy, arg2, arg3, arg4})
	stub := fake.NewTasksToDeleteNodeGroupsStub
	fakeReturns := fake.newTasksToDeleteNodeGroupsReturns
	fake.recordInvocation("NewTasksToDeleteNodeGroups", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsCallCount() int {
	fake.newTasksToDeleteNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteNodeGroupsMutex.RUnlock()
	return len(fake.newTasksToDeleteNodeGroupsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsCalls(stub func([]manager.NodeGroupStack, func(_ string) bool, bool, func(chan error, string) error) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteNodeGroupsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsArgsForCall(i int) ([]manager.NodeGroupStack, func(_ string) bool, bool, func(chan error, string) error) {
	fake.newTasksToDeleteNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteNodeGroupsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteNodeGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteNodeGroupsStub = nil
	fake.newTasksToDeleteNodeGroupsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteNodeGroupsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteNodeGroupsMutex.Lock()
	defer fake.newTasksToDeleteNodeGroupsMutex.Unlock()
	fake.NewTasksToDeleteNodeGroupsStub = nil
	if fake.newTasksToDeleteNodeGroupsReturnsOnCall == nil {
		fake.newTasksToDeleteNodeGroupsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteNodeGroupsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccounts(arg1 context.Context, arg2 manager.NewOIDCManager, arg3 *typesc.Cluster, arg4 kubernetes.ClientSetGetter, arg5 bool) (*tasks.TaskTree, error) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	ret, specificReturn := fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall[len(fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall)]
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall = append(fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall, struct {
		arg1 context.Context
		arg2 manager.NewOIDCManager
		arg3 *typesc.Cluster
		arg4 kubernetes.ClientSetGetter
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub
	fakeReturns := fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns
	fake.recordInvocation("NewTasksToDeleteOIDCProviderWithIAMServiceAccounts", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsCallCount() int {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RUnlock()
	return len(fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall)
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsCalls(stub func(context.Context, manager.NewOIDCManager, *typesc.Cluster, kubernetes.ClientSetGetter, bool) (*tasks.TaskTree, error)) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub = stub
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall(i int) (context.Context, manager.NewOIDCManager, *typesc.Cluster, kubernetes.ClientSetGetter, bool) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RUnlock()
	argsForCall := fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns(result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub = nil
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturns = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall(i int, result1 *tasks.TaskTree, result2 error) {
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Lock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.Unlock()
	fake.NewTasksToDeleteOIDCProviderWithIAMServiceAccountsStub = nil
	if fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall == nil {
		fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
			result2 error
		})
	}
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
		result2 error
	}{result1, result2}
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTask(arg1 context.Context, arg2 []*v1alpha5.NodeGroup, arg3 bool, arg4 bool, arg5 bool, arg6 vpc.Importer) *tasks.TaskTree {
	var arg2Copy []*v1alpha5.NodeGroup
	if arg2 != nil {
		arg2Copy = make([]*v1alpha5.NodeGroup, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	ret, specificReturn := fake.newUnmanagedNodeGroupTaskReturnsOnCall[len(fake.newUnmanagedNodeGroupTaskArgsForCall)]
	fake.newUnmanagedNodeGroupTaskArgsForCall = append(fake.newUnmanagedNodeGroupTaskArgsForCall, struct {
		arg1 context.Context
		arg2 []*v1alpha5.NodeGroup
		arg3 bool
		arg4 bool
		arg5 bool
		arg6 vpc.Importer
	}{arg1, arg2Copy, arg3, arg4, arg5, arg6})
	stub := fake.NewUnmanagedNodeGroupTaskStub
	fakeReturns := fake.newUnmanagedNodeGroupTaskReturns
	fake.recordInvocation("NewUnmanagedNodeGroupTask", []interface{}{arg1, arg2Copy, arg3, arg4, arg5, arg6})
	fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskCallCount() int {
	fake.newUnmanagedNodeGroupTaskMutex.RLock()
	defer fake.newUnmanagedNodeGroupTaskMutex.RUnlock()
	return len(fake.newUnmanagedNodeGroupTaskArgsForCall)
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskCalls(stub func(context.Context, []*v1alpha5.NodeGroup, bool, bool, bool, vpc.Importer) *tasks.TaskTree) {
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	defer fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	fake.NewUnmanagedNodeGroupTaskStub = stub
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskArgsForCall(i int) (context.Context, []*v1alpha5.NodeGroup, bool, bool, bool, vpc.Importer) {
	fake.newUnmanagedNodeGroupTaskMutex.RLock()
	defer fake.newUnmanagedNodeGroupTaskMutex.RUnlock()
	argsForCall := fake.newUnmanagedNodeGroupTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskReturns(result1 *tasks.TaskTree) {
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	defer fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	fake.NewUnmanagedNodeGroupTaskStub = nil
	fake.newUnmanagedNodeGroupTaskReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) NewUnmanagedNodeGroupTaskReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.newUnmanagedNodeGroupTaskMutex.Lock()
	defer fake.newUnmanagedNodeGroupTaskMutex.Unlock()
	fake.NewUnmanagedNodeGroupTaskStub = nil
	if fake.newUnmanagedNodeGroupTaskReturnsOnCall == nil {
		fake.newUnmanagedNodeGroupTaskReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.newUnmanagedNodeGroupTaskReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeStackManager) PropagateManagedNodeGroupTagsToASG(arg1 string, arg2 map[string]string, arg3 []string, arg4 chan error) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.propagateManagedNodeGroupTagsToASGMutex.Lock()
	ret, specificReturn := fake.propagateManagedNodeGroupTagsToASGReturnsOnCall[len(fake.propagateManagedNodeGroupTagsToASGArgsForCall)]
	fake.propagateManagedNodeGroupTagsToASGArgsForCall = append(fake.propagateManagedNodeGroupTagsToASGArgsForCall, struct {
		arg1 string
		arg2 map[string]string
		arg3 []string
		arg4 chan error
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.PropagateManagedNodeGroupTagsToASGStub
	fakeReturns := fake.propagateManagedNodeGroupTagsToASGReturns
	fake.recordInvocation("PropagateManagedNodeGroupTagsToASG", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.propagateManagedNodeGroupTagsToASGMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) PropagateManagedNodeGroupTagsToASGCallCount() int {
	fake.propagateManagedNodeGroupTagsToASGMutex.RLock()
	defer fake.propagateManagedNodeGroupTagsToASGMutex.RUnlock()
	return len(fake.propagateManagedNodeGroupTagsToASGArgsForCall)
}

func (fake *FakeStackManager) PropagateManagedNodeGroupTagsToASGCalls(stub func(string, map[string]string, []string, chan error) error) {
	fake.propagateManagedNodeGroupTagsToASGMutex.Lock()
	defer fake.propagateManagedNodeGroupTagsToASGMutex.Unlock()
	fake.PropagateManagedNodeGroupTagsToASGStub = stub
}

func (fake *FakeStackManager) PropagateManagedNodeGroupTagsToASGArgsForCall(i int) (string, map[string]string, []string, chan error) {
	fake.propagateManagedNodeGroupTagsToASGMutex.RLock()
	defer fake.propagateManagedNodeGroupTagsToASGMutex.RUnlock()
	argsForCall := fake.propagateManagedNodeGroupTagsToASGArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStackManager) PropagateManagedNodeGroupTagsToASGReturns(result1 error) {
	fake.propagateManagedNodeGroupTagsToASGMutex.Lock()
	defer fake.propagateManagedNodeGroupTagsToASGMutex.Unlock()
	fake.PropagateManagedNodeGroupTagsToASGStub = nil
	fake.propagateManagedNodeGroupTagsToASGReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) PropagateManagedNodeGroupTagsToASGReturnsOnCall(i int, result1 error) {
	fake.propagateManagedNodeGroupTagsToASGMutex.Lock()
	defer fake.propagateManagedNodeGroupTagsToASGMutex.Unlock()
	fake.PropagateManagedNodeGroupTagsToASGStub = nil
	if fake.propagateManagedNodeGroupTagsToASGReturnsOnCall == nil {
		fake.propagateManagedNodeGroupTagsToASGReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.propagateManagedNodeGroupTagsToASGReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARN(arg1 context.Context) error {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	ret, specificReturn := fake.refreshFargatePodExecutionRoleARNReturnsOnCall[len(fake.refreshFargatePodExecutionRoleARNArgsForCall)]
	fake.refreshFargatePodExecutionRoleARNArgsForCall = append(fake.refreshFargatePodExecutionRoleARNArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.RefreshFargatePodExecutionRoleARNStub
	fakeReturns := fake.refreshFargatePodExecutionRoleARNReturns
	fake.recordInvocation("RefreshFargatePodExecutionRoleARN", []interface{}{arg1})
	fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNCallCount() int {
	fake.refreshFargatePodExecutionRoleARNMutex.RLock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.RUnlock()
	return len(fake.refreshFargatePodExecutionRoleARNArgsForCall)
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNCalls(stub func(context.Context) error) {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	fake.RefreshFargatePodExecutionRoleARNStub = stub
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNArgsForCall(i int) context.Context {
	fake.refreshFargatePodExecutionRoleARNMutex.RLock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.RUnlock()
	argsForCall := fake.refreshFargatePodExecutionRoleARNArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNReturns(result1 error) {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	fake.RefreshFargatePodExecutionRoleARNStub = nil
	fake.refreshFargatePodExecutionRoleARNReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) RefreshFargatePodExecutionRoleARNReturnsOnCall(i int, result1 error) {
	fake.refreshFargatePodExecutionRoleARNMutex.Lock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.Unlock()
	fake.RefreshFargatePodExecutionRoleARNStub = nil
	if fake.refreshFargatePodExecutionRoleARNReturnsOnCall == nil {
		fake.refreshFargatePodExecutionRoleARNReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshFargatePodExecutionRoleARNReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) StackStatusIsNotTransitional(arg1 *types.Stack) bool {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	ret, specificReturn := fake.stackStatusIsNotTransitionalReturnsOnCall[len(fake.stackStatusIsNotTransitionalArgsForCall)]
	fake.stackStatusIsNotTransitionalArgsForCall = append(fake.stackStatusIsNotTransitionalArgsForCall, struct {
		arg1 *types.Stack
	}{arg1})
	stub := fake.StackStatusIsNotTransitionalStub
	fakeReturns := fake.stackStatusIsNotTransitionalReturns
	fake.recordInvocation("StackStatusIsNotTransitional", []interface{}{arg1})
	fake.stackStatusIsNotTransitionalMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalCallCount() int {
	fake.stackStatusIsNotTransitionalMutex.RLock()
	defer fake.stackStatusIsNotTransitionalMutex.RUnlock()
	return len(fake.stackStatusIsNotTransitionalArgsForCall)
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalCalls(stub func(*types.Stack) bool) {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	defer fake.stackStatusIsNotTransitionalMutex.Unlock()
	fake.StackStatusIsNotTransitionalStub = stub
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalArgsForCall(i int) *types.Stack {
	fake.stackStatusIsNotTransitionalMutex.RLock()
	defer fake.stackStatusIsNotTransitionalMutex.RUnlock()
	argsForCall := fake.stackStatusIsNotTransitionalArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalReturns(result1 bool) {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	defer fake.stackStatusIsNotTransitionalMutex.Unlock()
	fake.StackStatusIsNotTransitionalStub = nil
	fake.stackStatusIsNotTransitionalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStackManager) StackStatusIsNotTransitionalReturnsOnCall(i int, result1 bool) {
	fake.stackStatusIsNotTransitionalMutex.Lock()
	defer fake.stackStatusIsNotTransitionalMutex.Unlock()
	fake.StackStatusIsNotTransitionalStub = nil
	if fake.stackStatusIsNotTransitionalReturnsOnCall == nil {
		fake.stackStatusIsNotTransitionalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.stackStatusIsNotTransitionalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStackManager) TroubleshootStackFailureCause(arg1 context.Context, arg2 *types.Stack, arg3 types.StackStatus) {
	fake.troubleshootStackFailureCauseMutex.Lock()
	fake.troubleshootStackFailureCauseArgsForCall = append(fake.troubleshootStackFailureCauseArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Stack
		arg3 types.StackStatus
	}{arg1, arg2, arg3})
	stub := fake.TroubleshootStackFailureCauseStub
	fake.recordInvocation("TroubleshootStackFailureCause", []interface{}{arg1, arg2, arg3})
	fake.troubleshootStackFailureCauseMutex.Unlock()
	if stub != nil {
		fake.TroubleshootStackFailureCauseStub(arg1, arg2, arg3)
	}
}

func (fake *FakeStackManager) TroubleshootStackFailureCauseCallCount() int {
	fake.troubleshootStackFailureCauseMutex.RLock()
	defer fake.troubleshootStackFailureCauseMutex.RUnlock()
	return len(fake.troubleshootStackFailureCauseArgsForCall)
}

func (fake *FakeStackManager) TroubleshootStackFailureCauseCalls(stub func(context.Context, *types.Stack, types.StackStatus)) {
	fake.troubleshootStackFailureCauseMutex.Lock()
	defer fake.troubleshootStackFailureCauseMutex.Unlock()
	fake.TroubleshootStackFailureCauseStub = stub
}

func (fake *FakeStackManager) TroubleshootStackFailureCauseArgsForCall(i int) (context.Context, *types.Stack, types.StackStatus) {
	fake.troubleshootStackFailureCauseMutex.RLock()
	defer fake.troubleshootStackFailureCauseMutex.RUnlock()
	argsForCall := fake.troubleshootStackFailureCauseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStackManager) UpdateNodeGroupStack(arg1 context.Context, arg2 string, arg3 string, arg4 bool) error {
	fake.updateNodeGroupStackMutex.Lock()
	ret, specificReturn := fake.updateNodeGroupStackReturnsOnCall[len(fake.updateNodeGroupStackArgsForCall)]
	fake.updateNodeGroupStackArgsForCall = append(fake.updateNodeGroupStackArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateNodeGroupStackStub
	fakeReturns := fake.updateNodeGroupStackReturns
	fake.recordInvocation("UpdateNodeGroupStack", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateNodeGroupStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) UpdateNodeGroupStackCallCount() int {
	fake.updateNodeGroupStackMutex.RLock()
	defer fake.updateNodeGroupStackMutex.RUnlock()
	return len(fake.updateNodeGroupStackArgsForCall)
}

func (fake *FakeStackManager) UpdateNodeGroupStackCalls(stub func(context.Context, string, string, bool) error) {
	fake.updateNodeGroupStackMutex.Lock()
	defer fake.updateNodeGroupStackMutex.Unlock()
	fake.UpdateNodeGroupStackStub = stub
}

func (fake *FakeStackManager) UpdateNodeGroupStackArgsForCall(i int) (context.Context, string, string, bool) {
	fake.updateNodeGroupStackMutex.RLock()
	defer fake.updateNodeGroupStackMutex.RUnlock()
	argsForCall := fake.updateNodeGroupStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStackManager) UpdateNodeGroupStackReturns(result1 error) {
	fake.updateNodeGroupStackMutex.Lock()
	defer fake.updateNodeGroupStackMutex.Unlock()
	fake.UpdateNodeGroupStackStub = nil
	fake.updateNodeGroupStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) UpdateNodeGroupStackReturnsOnCall(i int, result1 error) {
	fake.updateNodeGroupStackMutex.Lock()
	defer fake.updateNodeGroupStackMutex.Unlock()
	fake.UpdateNodeGroupStackStub = nil
	if fake.updateNodeGroupStackReturnsOnCall == nil {
		fake.updateNodeGroupStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateNodeGroupStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) UpdateStack(arg1 context.Context, arg2 manager.UpdateStackOptions) error {
	fake.updateStackMutex.Lock()
	ret, specificReturn := fake.updateStackReturnsOnCall[len(fake.updateStackArgsForCall)]
	fake.updateStackArgsForCall = append(fake.updateStackArgsForCall, struct {
		arg1 context.Context
		arg2 manager.UpdateStackOptions
	}{arg1, arg2})
	stub := fake.UpdateStackStub
	fakeReturns := fake.updateStackReturns
	fake.recordInvocation("UpdateStack", []interface{}{arg1, arg2})
	fake.updateStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStackManager) UpdateStackCallCount() int {
	fake.updateStackMutex.RLock()
	defer fake.updateStackMutex.RUnlock()
	return len(fake.updateStackArgsForCall)
}

func (fake *FakeStackManager) UpdateStackCalls(stub func(context.Context, manager.UpdateStackOptions) error) {
	fake.updateStackMutex.Lock()
	defer fake.updateStackMutex.Unlock()
	fake.UpdateStackStub = stub
}

func (fake *FakeStackManager) UpdateStackArgsForCall(i int) (context.Context, manager.UpdateStackOptions) {
	fake.updateStackMutex.RLock()
	defer fake.updateStackMutex.RUnlock()
	argsForCall := fake.updateStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStackManager) UpdateStackReturns(result1 error) {
	fake.updateStackMutex.Lock()
	defer fake.updateStackMutex.Unlock()
	fake.UpdateStackStub = nil
	fake.updateStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) UpdateStackReturnsOnCall(i int, result1 error) {
	fake.updateStackMutex.Lock()
	defer fake.updateStackMutex.Unlock()
	fake.UpdateStackStub = nil
	if fake.updateStackReturnsOnCall == nil {
		fake.updateStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStackManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appendNewClusterStackResourceMutex.RLock()
	defer fake.appendNewClusterStackResourceMutex.RUnlock()
	fake.clusterHasDedicatedVPCMutex.RLock()
	defer fake.clusterHasDedicatedVPCMutex.RUnlock()
	fake.createStackMutex.RLock()
	defer fake.createStackMutex.RUnlock()
	fake.deleteStackBySpecMutex.RLock()
	defer fake.deleteStackBySpecMutex.RUnlock()
	fake.deleteStackBySpecSyncMutex.RLock()
	defer fake.deleteStackBySpecSyncMutex.RUnlock()
	fake.deleteStackSyncMutex.RLock()
	defer fake.deleteStackSyncMutex.RUnlock()
	fake.deleteTasksForDeprecatedStacksMutex.RLock()
	defer fake.deleteTasksForDeprecatedStacksMutex.RUnlock()
	fake.describeClusterStackMutex.RLock()
	defer fake.describeClusterStackMutex.RUnlock()
	fake.describeClusterStackIfExistsMutex.RLock()
	defer fake.describeClusterStackIfExistsMutex.RUnlock()
	fake.describeIAMServiceAccountStacksMutex.RLock()
	defer fake.describeIAMServiceAccountStacksMutex.RUnlock()
	fake.describeNodeGroupStackMutex.RLock()
	defer fake.describeNodeGroupStackMutex.RUnlock()
	fake.describeNodeGroupStacksAndResourcesMutex.RLock()
	defer fake.describeNodeGroupStacksAndResourcesMutex.RUnlock()
	fake.describeStackMutex.RLock()
	defer fake.describeStackMutex.RUnlock()
	fake.describeStackChangeSetMutex.RLock()
	defer fake.describeStackChangeSetMutex.RUnlock()
	fake.describeStackEventsMutex.RLock()
	defer fake.describeStackEventsMutex.RUnlock()
	fake.doCreateStackRequestMutex.RLock()
	defer fake.doCreateStackRequestMutex.RUnlock()
	fake.doWaitUntilStackIsCreatedMutex.RLock()
	defer fake.doWaitUntilStackIsCreatedMutex.RUnlock()
	fake.ensureMapPublicIPOnLaunchEnabledMutex.RLock()
	defer fake.ensureMapPublicIPOnLaunchEnabledMutex.RUnlock()
	fake.fixClusterCompatibilityMutex.RLock()
	defer fake.fixClusterCompatibilityMutex.RUnlock()
	fake.getAutoScalingGroupDesiredCapacityMutex.RLock()
	defer fake.getAutoScalingGroupDesiredCapacityMutex.RUnlock()
	fake.getAutoScalingGroupNameMutex.RLock()
	defer fake.getAutoScalingGroupNameMutex.RUnlock()
	fake.getClusterStackIfExistsMutex.RLock()
	defer fake.getClusterStackIfExistsMutex.RUnlock()
	fake.getFargateStackMutex.RLock()
	defer fake.getFargateStackMutex.RUnlock()
	fake.getIAMAddonNameMutex.RLock()
	defer fake.getIAMAddonNameMutex.RUnlock()
	fake.getIAMAddonsStacksMutex.RLock()
	defer fake.getIAMAddonsStacksMutex.RUnlock()
	fake.getIAMServiceAccountsMutex.RLock()
	defer fake.getIAMServiceAccountsMutex.RUnlock()
	fake.getKarpenterStackMutex.RLock()
	defer fake.getKarpenterStackMutex.RUnlock()
	fake.getManagedNodeGroupTemplateMutex.RLock()
	defer fake.getManagedNodeGroupTemplateMutex.RUnlock()
	fake.getNodeGroupNameMutex.RLock()
	defer fake.getNodeGroupNameMutex.RUnlock()
	fake.getNodeGroupStackTypeMutex.RLock()
	defer fake.getNodeGroupStackTypeMutex.RUnlock()
	fake.getStackTemplateMutex.RLock()
	defer fake.getStackTemplateMutex.RUnlock()
	fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.RLock()
	defer fake.getUnmanagedNodeGroupAutoScalingGroupNameMutex.RUnlock()
	fake.hasClusterStackFromListMutex.RLock()
	defer fake.hasClusterStackFromListMutex.RUnlock()
	fake.listAccessEntryStackNamesMutex.RLock()
	defer fake.listAccessEntryStackNamesMutex.RUnlock()
	fake.listClusterStackNamesMutex.RLock()
	defer fake.listClusterStackNamesMutex.RUnlock()
	fake.listIAMServiceAccountStacksMutex.RLock()
	defer fake.listIAMServiceAccountStacksMutex.RUnlock()
	fake.listNodeGroupStacksMutex.RLock()
	defer fake.listNodeGroupStacksMutex.RUnlock()
	fake.listNodeGroupStacksWithStatusesMutex.RLock()
	defer fake.listNodeGroupStacksWithStatusesMutex.RUnlock()
	fake.listPodIdentityStackNamesMutex.RLock()
	defer fake.listPodIdentityStackNamesMutex.RUnlock()
	fake.listStackNamesMutex.RLock()
	defer fake.listStackNamesMutex.RUnlock()
	fake.listStacksMutex.RLock()
	defer fake.listStacksMutex.RUnlock()
	fake.listStacksMatchingMutex.RLock()
	defer fake.listStacksMatchingMutex.RUnlock()
	fake.listStacksWithStatusesMutex.RLock()
	defer fake.listStacksWithStatusesMutex.RUnlock()
	fake.lookupCloudTrailEventsMutex.RLock()
	defer fake.lookupCloudTrailEventsMutex.RUnlock()
	fake.makeChangeSetNameMutex.RLock()
	defer fake.makeChangeSetNameMutex.RUnlock()
	fake.makeClusterStackNameMutex.RLock()
	defer fake.makeClusterStackNameMutex.RUnlock()
	fake.mustUpdateStackMutex.RLock()
	defer fake.mustUpdateStackMutex.RUnlock()
	fake.newManagedNodeGroupTaskMutex.RLock()
	defer fake.newManagedNodeGroupTaskMutex.RUnlock()
	fake.newTaskToDeleteUnownedNodeGroupMutex.RLock()
	defer fake.newTaskToDeleteUnownedNodeGroupMutex.RUnlock()
	fake.newTasksToCreateClusterMutex.RLock()
	defer fake.newTasksToCreateClusterMutex.RUnlock()
	fake.newTasksToCreateIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToCreateIAMServiceAccountsMutex.RUnlock()
	fake.newTasksToDeleteClusterWithNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteClusterWithNodeGroupsMutex.RUnlock()
	fake.newTasksToDeleteIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteIAMServiceAccountsMutex.RUnlock()
	fake.newTasksToDeleteNodeGroupsMutex.RLock()
	defer fake.newTasksToDeleteNodeGroupsMutex.RUnlock()
	fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RLock()
	defer fake.newTasksToDeleteOIDCProviderWithIAMServiceAccountsMutex.RUnlock()
	fake.newUnmanagedNodeGroupTaskMutex.RLock()
	defer fake.newUnmanagedNodeGroupTaskMutex.RUnlock()
	fake.propagateManagedNodeGroupTagsToASGMutex.RLock()
	defer fake.propagateManagedNodeGroupTagsToASGMutex.RUnlock()
	fake.refreshFargatePodExecutionRoleARNMutex.RLock()
	defer fake.refreshFargatePodExecutionRoleARNMutex.RUnlock()
	fake.stackStatusIsNotTransitionalMutex.RLock()
	defer fake.stackStatusIsNotTransitionalMutex.RUnlock()
	fake.troubleshootStackFailureCauseMutex.RLock()
	defer fake.troubleshootStackFailureCauseMutex.RUnlock()
	fake.updateNodeGroupStackMutex.RLock()
	defer fake.updateNodeGroupStackMutex.RUnlock()
	fake.updateStackMutex.RLock()
	defer fake.updateStackMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStackManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ manager.StackManager = new(FakeStackManager)
