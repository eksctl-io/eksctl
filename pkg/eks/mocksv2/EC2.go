// Code generated by mockery v2.35.3. DO NOT EDIT.

package mocksv2

import (
	context "context"

	ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"
	mock "github.com/stretchr/testify/mock"
)

// EC2 is an autogenerated mock type for the EC2 type
type EC2 struct {
	mock.Mock
}

// AcceptReservedInstancesExchangeQuote provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptReservedInstancesExchangeQuote(ctx context.Context, params *ec2.AcceptReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AcceptReservedInstancesExchangeQuoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.AcceptReservedInstancesExchangeQuoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) *ec2.AcceptReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptReservedInstancesExchangeQuoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.AcceptTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AcceptTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptTransitGatewayVpcAttachment(ctx context.Context, params *ec2.AcceptTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AcceptTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.AcceptTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.AcceptTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptVpcEndpointConnections(ctx context.Context, params *ec2.AcceptVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AcceptVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.AcceptVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.AcceptVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AcceptVpcPeeringConnection(ctx context.Context, params *ec2.AcceptVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AcceptVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.AcceptVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.AcceptVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AcceptVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AcceptVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AdvertiseByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AdvertiseByoipCidr(ctx context.Context, params *ec2.AdvertiseByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AdvertiseByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) (*ec2.AdvertiseByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) *ec2.AdvertiseByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AdvertiseByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AdvertiseByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AllocateAddress(ctx context.Context, params *ec2.AllocateAddressInput, optFns ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AllocateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) (*ec2.AllocateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) *ec2.AllocateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AllocateHosts(ctx context.Context, params *ec2.AllocateHostsInput, optFns ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AllocateHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) (*ec2.AllocateHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) *ec2.AllocateHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AllocateIpamPoolCidr(ctx context.Context, params *ec2.AllocateIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AllocateIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.AllocateIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.AllocateIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AllocateIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AllocateIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplySecurityGroupsToClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ApplySecurityGroupsToClientVpnTargetNetwork(ctx context.Context, params *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ApplySecurityGroupsToClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ApplySecurityGroupsToClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignIpv6Addresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssignIpv6Addresses(ctx context.Context, params *ec2.AssignIpv6AddressesInput, optFns ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssignIpv6AddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.AssignIpv6AddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) *ec2.AssignIpv6AddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignIpv6AddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignIpv6AddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssignPrivateIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssignPrivateIpAddresses(ctx context.Context, params *ec2.AssignPrivateIpAddressesInput, optFns ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssignPrivateIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.AssignPrivateIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) *ec2.AssignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssignPrivateIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssignPrivateIpAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateAddress(ctx context.Context, params *ec2.AssociateAddressInput, optFns ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) (*ec2.AssociateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) *ec2.AssociateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateClientVpnTargetNetwork(ctx context.Context, params *ec2.AssociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.AssociateClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.AssociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateDhcpOptions(ctx context.Context, params *ec2.AssociateDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.AssociateDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) *ec2.AssociateDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateEnclaveCertificateIamRole provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateEnclaveCertificateIamRole(ctx context.Context, params *ec2.AssociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateEnclaveCertificateIamRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.AssociateEnclaveCertificateIamRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) *ec2.AssociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateEnclaveCertificateIamRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateIamInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateIamInstanceProfile(ctx context.Context, params *ec2.AssociateIamInstanceProfileInput, optFns ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateIamInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.AssociateIamInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) *ec2.AssociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateIamInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateIamInstanceProfileInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateInstanceEventWindow(ctx context.Context, params *ec2.AssociateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.AssociateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.AssociateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateRouteTable(ctx context.Context, params *ec2.AssociateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) *ec2.AssociateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateSubnetCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateSubnetCidrBlock(ctx context.Context, params *ec2.AssociateSubnetCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateSubnetCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateSubnetCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) *ec2.AssociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateSubnetCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateSubnetCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.AssociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateTransitGatewayRouteTable(ctx context.Context, params *ec2.AssociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.AssociateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.AssociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateTrunkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateTrunkInterface(ctx context.Context, params *ec2.AssociateTrunkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateTrunkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.AssociateTrunkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) *ec2.AssociateTrunkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateTrunkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateTrunkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AssociateVpcCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AssociateVpcCidrBlock(ctx context.Context, params *ec2.AssociateVpcCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AssociateVpcCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.AssociateVpcCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) *ec2.AssociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AssociateVpcCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AssociateVpcCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachClassicLinkVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachClassicLinkVpc(ctx context.Context, params *ec2.AttachClassicLinkVpcInput, optFns ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AttachClassicLinkVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.AttachClassicLinkVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) *ec2.AttachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachClassicLinkVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachClassicLinkVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachInternetGateway(ctx context.Context, params *ec2.AttachInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AttachInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.AttachInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) *ec2.AttachInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachNetworkInterface(ctx context.Context, params *ec2.AttachNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AttachNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.AttachNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.AttachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachVolume(ctx context.Context, params *ec2.AttachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AttachVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) *ec2.AttachVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AttachVpnGateway(ctx context.Context, params *ec2.AttachVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AttachVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.AttachVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) *ec2.AttachVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AttachVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AttachVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeClientVpnIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AuthorizeClientVpnIngress(ctx context.Context, params *ec2.AuthorizeClientVpnIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AuthorizeClientVpnIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeClientVpnIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeClientVpnIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeClientVpnIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeClientVpnIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSecurityGroupEgress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AuthorizeSecurityGroupEgress(ctx context.Context, params *ec2.AuthorizeSecurityGroupEgressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AuthorizeSecurityGroupEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthorizeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) AuthorizeSecurityGroupIngress(ctx context.Context, params *ec2.AuthorizeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.AuthorizeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BundleInstance provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) BundleInstance(ctx context.Context, params *ec2.BundleInstanceInput, optFns ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.BundleInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) (*ec2.BundleInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) *ec2.BundleInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.BundleInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.BundleInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelBundleTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelBundleTask(ctx context.Context, params *ec2.CancelBundleTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelBundleTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) (*ec2.CancelBundleTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) *ec2.CancelBundleTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelBundleTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelBundleTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelCapacityReservation(ctx context.Context, params *ec2.CancelCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) *ec2.CancelCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCapacityReservationFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelCapacityReservationFleets(ctx context.Context, params *ec2.CancelCapacityReservationFleetsInput, optFns ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelCapacityReservationFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.CancelCapacityReservationFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) *ec2.CancelCapacityReservationFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelCapacityReservationFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelCapacityReservationFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelConversionTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelConversionTask(ctx context.Context, params *ec2.CancelConversionTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelConversionTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) (*ec2.CancelConversionTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) *ec2.CancelConversionTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelConversionTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelConversionTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelExportTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelExportTask(ctx context.Context, params *ec2.CancelExportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelExportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) (*ec2.CancelExportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) *ec2.CancelExportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelExportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelExportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelImportTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelImportTask(ctx context.Context, params *ec2.CancelImportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelImportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) (*ec2.CancelImportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) *ec2.CancelImportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelImportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelImportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelReservedInstancesListing provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelReservedInstancesListing(ctx context.Context, params *ec2.CancelReservedInstancesListingInput, optFns ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelReservedInstancesListingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CancelReservedInstancesListingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) *ec2.CancelReservedInstancesListingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelReservedInstancesListingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelReservedInstancesListingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSpotFleetRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelSpotFleetRequests(ctx context.Context, params *ec2.CancelSpotFleetRequestsInput, optFns ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelSpotFleetRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotFleetRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) *ec2.CancelSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotFleetRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelSpotFleetRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelSpotInstanceRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CancelSpotInstanceRequests(ctx context.Context, params *ec2.CancelSpotInstanceRequestsInput, optFns ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CancelSpotInstanceRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.CancelSpotInstanceRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) *ec2.CancelSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CancelSpotInstanceRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CancelSpotInstanceRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfirmProductInstance provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ConfirmProductInstance(ctx context.Context, params *ec2.ConfirmProductInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ConfirmProductInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) (*ec2.ConfirmProductInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) *ec2.ConfirmProductInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ConfirmProductInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ConfirmProductInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CopyFpgaImage(ctx context.Context, params *ec2.CopyFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CopyFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) (*ec2.CopyFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) *ec2.CopyFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopyImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CopyImage(ctx context.Context, params *ec2.CopyImageInput, optFns ...func(*ec2.Options)) (*ec2.CopyImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CopyImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) (*ec2.CopyImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) *ec2.CopyImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopyImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopyImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CopySnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CopySnapshot(ctx context.Context, params *ec2.CopySnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CopySnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) (*ec2.CopySnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) *ec2.CopySnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CopySnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CopySnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCapacityReservation(ctx context.Context, params *ec2.CreateCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCapacityReservationFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCapacityReservationFleet(ctx context.Context, params *ec2.CreateCapacityReservationFleetInput, optFns ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateCapacityReservationFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.CreateCapacityReservationFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) *ec2.CreateCapacityReservationFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCapacityReservationFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCapacityReservationFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCarrierGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCarrierGateway(ctx context.Context, params *ec2.CreateCarrierGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateCarrierGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCarrierGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) *ec2.CreateCarrierGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCarrierGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCarrierGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateClientVpnEndpoint(ctx context.Context, params *ec2.CreateClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.CreateClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientVpnRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateClientVpnRoute(ctx context.Context, params *ec2.CreateClientVpnRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateClientVpnRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.CreateClientVpnRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) *ec2.CreateClientVpnRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateClientVpnRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateClientVpnRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCustomerGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateCustomerGateway(ctx context.Context, params *ec2.CreateCustomerGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateCustomerGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.CreateCustomerGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) *ec2.CreateCustomerGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateCustomerGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateCustomerGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDefaultSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateDefaultSubnet(ctx context.Context, params *ec2.CreateDefaultSubnetInput, optFns ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateDefaultSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) (*ec2.CreateDefaultSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) *ec2.CreateDefaultSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDefaultSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDefaultVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateDefaultVpc(ctx context.Context, params *ec2.CreateDefaultVpcInput, optFns ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateDefaultVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) (*ec2.CreateDefaultVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) *ec2.CreateDefaultVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDefaultVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDefaultVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateDhcpOptions(ctx context.Context, params *ec2.CreateDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.CreateDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) *ec2.CreateDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateEgressOnlyInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateEgressOnlyInternetGateway(ctx context.Context, params *ec2.CreateEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateEgressOnlyInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateEgressOnlyInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) *ec2.CreateEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateEgressOnlyInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateFleet(ctx context.Context, params *ec2.CreateFleetInput, optFns ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) (*ec2.CreateFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) *ec2.CreateFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateFlowLogs(ctx context.Context, params *ec2.CreateFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) (*ec2.CreateFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) *ec2.CreateFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateFpgaImage(ctx context.Context, params *ec2.CreateFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) (*ec2.CreateFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) *ec2.CreateFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateImage(ctx context.Context, params *ec2.CreateImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) (*ec2.CreateImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) *ec2.CreateImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateInstanceEventWindow(ctx context.Context, params *ec2.CreateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.CreateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.CreateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInstanceExportTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateInstanceExportTask(ctx context.Context, params *ec2.CreateInstanceExportTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateInstanceExportTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) (*ec2.CreateInstanceExportTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) *ec2.CreateInstanceExportTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInstanceExportTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInstanceExportTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateInternetGateway(ctx context.Context, params *ec2.CreateInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) (*ec2.CreateInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) *ec2.CreateInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateIpam(ctx context.Context, params *ec2.CreateIpamInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) (*ec2.CreateIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) *ec2.CreateIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateIpamPool(ctx context.Context, params *ec2.CreateIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) (*ec2.CreateIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) *ec2.CreateIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateIpamScope(ctx context.Context, params *ec2.CreateIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) (*ec2.CreateIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) *ec2.CreateIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateKeyPair(ctx context.Context, params *ec2.CreateKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) (*ec2.CreateKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) *ec2.CreateKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLaunchTemplate(ctx context.Context, params *ec2.CreateLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) *ec2.CreateLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLaunchTemplateVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLaunchTemplateVersion(ctx context.Context, params *ec2.CreateLaunchTemplateVersionInput, optFns ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateLaunchTemplateVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) (*ec2.CreateLaunchTemplateVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) *ec2.CreateLaunchTemplateVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLaunchTemplateVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLaunchTemplateVersionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLocalGatewayRoute(ctx context.Context, params *ec2.CreateLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalGatewayRouteTableVpcAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateLocalGatewayRouteTableVpcAssociation(ctx context.Context, params *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) *ec2.CreateLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateManagedPrefixList(ctx context.Context, params *ec2.CreateManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.CreateManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) *ec2.CreateManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNatGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNatGateway(ctx context.Context, params *ec2.CreateNatGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNatGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) (*ec2.CreateNatGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) *ec2.CreateNatGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNatGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNatGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkAcl provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkAcl(ctx context.Context, params *ec2.CreateNetworkAclInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNetworkAclOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) *ec2.CreateNetworkAclOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkAclInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkAclEntry(ctx context.Context, params *ec2.CreateNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.CreateNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.CreateNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInsightsAccessScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInsightsAccessScope(ctx context.Context, params *ec2.CreateNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNetworkInsightsAccessScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsAccessScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) *ec2.CreateNetworkInsightsAccessScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInsightsAccessScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInsightsPath provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInsightsPath(ctx context.Context, params *ec2.CreateNetworkInsightsPathInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNetworkInsightsPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInsightsPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) *ec2.CreateNetworkInsightsPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInsightsPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInsightsPathInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInterface(ctx context.Context, params *ec2.CreateNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.CreateNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetworkInterfacePermission provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateNetworkInterfacePermission(ctx context.Context, params *ec2.CreateNetworkInterfacePermissionInput, optFns ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateNetworkInterfacePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.CreateNetworkInterfacePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) *ec2.CreateNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateNetworkInterfacePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateNetworkInterfacePermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePlacementGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreatePlacementGroup(ctx context.Context, params *ec2.CreatePlacementGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreatePlacementGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) (*ec2.CreatePlacementGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) *ec2.CreatePlacementGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePlacementGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreatePlacementGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePublicIpv4Pool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreatePublicIpv4Pool(ctx context.Context, params *ec2.CreatePublicIpv4PoolInput, optFns ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreatePublicIpv4PoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.CreatePublicIpv4PoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) *ec2.CreatePublicIpv4PoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreatePublicIpv4PoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreatePublicIpv4PoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReplaceRootVolumeTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateReplaceRootVolumeTask(ctx context.Context, params *ec2.CreateReplaceRootVolumeTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateReplaceRootVolumeTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) (*ec2.CreateReplaceRootVolumeTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) *ec2.CreateReplaceRootVolumeTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReplaceRootVolumeTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateReplaceRootVolumeTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateReservedInstancesListing provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateReservedInstancesListing(ctx context.Context, params *ec2.CreateReservedInstancesListingInput, optFns ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateReservedInstancesListingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) (*ec2.CreateReservedInstancesListingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) *ec2.CreateReservedInstancesListingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateReservedInstancesListingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateReservedInstancesListingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRestoreImageTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateRestoreImageTask(ctx context.Context, params *ec2.CreateRestoreImageTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateRestoreImageTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateRestoreImageTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) *ec2.CreateRestoreImageTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRestoreImageTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRestoreImageTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateRoute(ctx context.Context, params *ec2.CreateRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) (*ec2.CreateRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) *ec2.CreateRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateRouteTable(ctx context.Context, params *ec2.CreateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) *ec2.CreateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSecurityGroup(ctx context.Context, params *ec2.CreateSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) *ec2.CreateSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSnapshot(ctx context.Context, params *ec2.CreateSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) *ec2.CreateSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSnapshots(ctx context.Context, params *ec2.CreateSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) (*ec2.CreateSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) *ec2.CreateSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSpotDatafeedSubscription(ctx context.Context, params *ec2.CreateSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.CreateSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.CreateSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateStoreImageTask provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateStoreImageTask(ctx context.Context, params *ec2.CreateStoreImageTaskInput, optFns ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateStoreImageTaskOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) (*ec2.CreateStoreImageTaskOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) *ec2.CreateStoreImageTaskOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateStoreImageTaskOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateStoreImageTaskInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSubnet(ctx context.Context, params *ec2.CreateSubnetInput, optFns ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) (*ec2.CreateSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) *ec2.CreateSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnetCidrReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateSubnetCidrReservation(ctx context.Context, params *ec2.CreateSubnetCidrReservationInput, optFns ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateSubnetCidrReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.CreateSubnetCidrReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) *ec2.CreateSubnetCidrReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSubnetCidrReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSubnetCidrReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTags provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTags(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) *ec2.CreateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorFilter provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorFilter(ctx context.Context, params *ec2.CreateTrafficMirrorFilterInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTrafficMirrorFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorFilterInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorFilterRule(ctx context.Context, params *ec2.CreateTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorSession(ctx context.Context, params *ec2.CreateTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTrafficMirrorTarget provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTrafficMirrorTarget(ctx context.Context, params *ec2.CreateTrafficMirrorTargetInput, optFns ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTrafficMirrorTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.CreateTrafficMirrorTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) *ec2.CreateTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTrafficMirrorTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTrafficMirrorTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGateway(ctx context.Context, params *ec2.CreateTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayConnect provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayConnect(ctx context.Context, params *ec2.CreateTransitGatewayConnectInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayConnectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayConnectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayConnectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayConnectInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayConnectPeer provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayConnectPeer(ctx context.Context, params *ec2.CreateTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayConnectPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayConnectPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayConnectPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayConnectPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayConnectPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.CreateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.CreateTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayPrefixListReference(ctx context.Context, params *ec2.CreateTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayRoute(ctx context.Context, params *ec2.CreateTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayRouteTable(ctx context.Context, params *ec2.CreateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateTransitGatewayVpcAttachment(ctx context.Context, params *ec2.CreateTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.CreateTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.CreateTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVolume(ctx context.Context, params *ec2.CreateVolumeInput, optFns ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) *ec2.CreateVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpc(ctx context.Context, params *ec2.CreateVpcInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) (*ec2.CreateVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) *ec2.CreateVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcEndpoint(ctx context.Context, params *ec2.CreateVpcEndpointInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointConnectionNotification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcEndpointConnectionNotification(ctx context.Context, params *ec2.CreateVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpcEndpointConnectionNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointConnectionNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointConnectionNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcEndpointServiceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcEndpointServiceConfiguration(ctx context.Context, params *ec2.CreateVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpcEndpointServiceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.CreateVpcEndpointServiceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) *ec2.CreateVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcEndpointServiceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpcPeeringConnection(ctx context.Context, params *ec2.CreateVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.CreateVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpnConnection(ctx context.Context, params *ec2.CreateVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) *ec2.CreateVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnConnectionRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpnConnectionRoute(ctx context.Context, params *ec2.CreateVpnConnectionRouteInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpnConnectionRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.CreateVpnConnectionRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) *ec2.CreateVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnConnectionRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnConnectionRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) CreateVpnGateway(ctx context.Context, params *ec2.CreateVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.CreateVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) (*ec2.CreateVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) *ec2.CreateVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCarrierGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteCarrierGateway(ctx context.Context, params *ec2.DeleteCarrierGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteCarrierGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCarrierGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) *ec2.DeleteCarrierGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCarrierGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCarrierGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteClientVpnEndpoint(ctx context.Context, params *ec2.DeleteClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.DeleteClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClientVpnRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteClientVpnRoute(ctx context.Context, params *ec2.DeleteClientVpnRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteClientVpnRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) (*ec2.DeleteClientVpnRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) *ec2.DeleteClientVpnRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteClientVpnRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteClientVpnRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCustomerGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteCustomerGateway(ctx context.Context, params *ec2.DeleteCustomerGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteCustomerGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteCustomerGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) *ec2.DeleteCustomerGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteCustomerGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteCustomerGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteDhcpOptions(ctx context.Context, params *ec2.DeleteDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DeleteDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) *ec2.DeleteDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEgressOnlyInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteEgressOnlyInternetGateway(ctx context.Context, params *ec2.DeleteEgressOnlyInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteEgressOnlyInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteEgressOnlyInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) *ec2.DeleteEgressOnlyInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteEgressOnlyInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteEgressOnlyInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteFleets(ctx context.Context, params *ec2.DeleteFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) (*ec2.DeleteFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) *ec2.DeleteFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteFlowLogs(ctx context.Context, params *ec2.DeleteFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) (*ec2.DeleteFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) *ec2.DeleteFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFpgaImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteFpgaImage(ctx context.Context, params *ec2.DeleteFpgaImageInput, optFns ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteFpgaImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) (*ec2.DeleteFpgaImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) *ec2.DeleteFpgaImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteFpgaImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteFpgaImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteInstanceEventWindow(ctx context.Context, params *ec2.DeleteInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DeleteInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.DeleteInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteInternetGateway(ctx context.Context, params *ec2.DeleteInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) *ec2.DeleteInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteIpam(ctx context.Context, params *ec2.DeleteIpamInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) (*ec2.DeleteIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) *ec2.DeleteIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteIpamPool(ctx context.Context, params *ec2.DeleteIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) (*ec2.DeleteIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) *ec2.DeleteIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteIpamScope(ctx context.Context, params *ec2.DeleteIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) (*ec2.DeleteIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) *ec2.DeleteIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteKeyPair(ctx context.Context, params *ec2.DeleteKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) (*ec2.DeleteKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) *ec2.DeleteKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLaunchTemplate(ctx context.Context, params *ec2.DeleteLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) *ec2.DeleteLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLaunchTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLaunchTemplateVersions(ctx context.Context, params *ec2.DeleteLaunchTemplateVersionsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteLaunchTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DeleteLaunchTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) *ec2.DeleteLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLaunchTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLaunchTemplateVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLocalGatewayRoute(ctx context.Context, params *ec2.DeleteLocalGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteLocalGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLocalGatewayRouteTableVpcAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteLocalGatewayRouteTableVpcAssociation(ctx context.Context, params *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) (*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) *ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteLocalGatewayRouteTableVpcAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteLocalGatewayRouteTableVpcAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteManagedPrefixList(ctx context.Context, params *ec2.DeleteManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.DeleteManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) *ec2.DeleteManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNatGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNatGateway(ctx context.Context, params *ec2.DeleteNatGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNatGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteNatGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) *ec2.DeleteNatGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNatGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNatGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkAcl provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkAcl(ctx context.Context, params *ec2.DeleteNetworkAclInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkAclOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) *ec2.DeleteNetworkAclOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkAclInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkAclEntry(ctx context.Context, params *ec2.DeleteNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.DeleteNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsAccessScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsAccessScope(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkInsightsAccessScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAccessScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAccessScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsAccessScopeAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsAccessScopeAnalysis(ctx context.Context, params *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAccessScopeAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsAnalysis(ctx context.Context, params *ec2.DeleteNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkInsightsAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInsightsPath provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInsightsPath(ctx context.Context, params *ec2.DeleteNetworkInsightsPathInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkInsightsPathOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInsightsPathOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInsightsPathOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInsightsPathOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInsightsPathInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInterface(ctx context.Context, params *ec2.DeleteNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetworkInterfacePermission provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteNetworkInterfacePermission(ctx context.Context, params *ec2.DeleteNetworkInterfacePermissionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteNetworkInterfacePermissionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) (*ec2.DeleteNetworkInterfacePermissionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) *ec2.DeleteNetworkInterfacePermissionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteNetworkInterfacePermissionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteNetworkInterfacePermissionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlacementGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeletePlacementGroup(ctx context.Context, params *ec2.DeletePlacementGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeletePlacementGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) (*ec2.DeletePlacementGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) *ec2.DeletePlacementGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePlacementGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeletePlacementGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePublicIpv4Pool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeletePublicIpv4Pool(ctx context.Context, params *ec2.DeletePublicIpv4PoolInput, optFns ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeletePublicIpv4PoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) (*ec2.DeletePublicIpv4PoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) *ec2.DeletePublicIpv4PoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeletePublicIpv4PoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeletePublicIpv4PoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteQueuedReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteQueuedReservedInstances(ctx context.Context, params *ec2.DeleteQueuedReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteQueuedReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DeleteQueuedReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) *ec2.DeleteQueuedReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteQueuedReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteQueuedReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteRoute(ctx context.Context, params *ec2.DeleteRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) (*ec2.DeleteRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) *ec2.DeleteRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteRouteTable(ctx context.Context, params *ec2.DeleteRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSecurityGroup(ctx context.Context, params *ec2.DeleteSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) *ec2.DeleteSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSnapshot(ctx context.Context, params *ec2.DeleteSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) *ec2.DeleteSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSpotDatafeedSubscription(ctx context.Context, params *ec2.DeleteSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DeleteSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.DeleteSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSubnet(ctx context.Context, params *ec2.DeleteSubnetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteSubnetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) *ec2.DeleteSubnetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSubnetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetCidrReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteSubnetCidrReservation(ctx context.Context, params *ec2.DeleteSubnetCidrReservationInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteSubnetCidrReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) (*ec2.DeleteSubnetCidrReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) *ec2.DeleteSubnetCidrReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSubnetCidrReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSubnetCidrReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTags(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) *ec2.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorFilter provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorFilter(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTrafficMirrorFilterOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorFilterOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorFilterInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorFilterRule(ctx context.Context, params *ec2.DeleteTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorSession(ctx context.Context, params *ec2.DeleteTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTrafficMirrorTarget provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTrafficMirrorTarget(ctx context.Context, params *ec2.DeleteTrafficMirrorTargetInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTrafficMirrorTargetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) (*ec2.DeleteTrafficMirrorTargetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) *ec2.DeleteTrafficMirrorTargetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTrafficMirrorTargetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTrafficMirrorTargetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGateway(ctx context.Context, params *ec2.DeleteTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayConnect provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayConnect(ctx context.Context, params *ec2.DeleteTransitGatewayConnectInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayConnectOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayConnectOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayConnectOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayConnectInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayConnectPeer provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayConnectPeer(ctx context.Context, params *ec2.DeleteTransitGatewayConnectPeerInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayConnectPeerOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayConnectPeerOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayConnectPeerOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayConnectPeerOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayConnectPeerInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayMulticastDomain(ctx context.Context, params *ec2.DeleteTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.DeleteTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayPrefixListReference(ctx context.Context, params *ec2.DeleteTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayRoute(ctx context.Context, params *ec2.DeleteTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayRouteTable(ctx context.Context, params *ec2.DeleteTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteTransitGatewayVpcAttachment(ctx context.Context, params *ec2.DeleteTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.DeleteTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.DeleteTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVolume(ctx context.Context, params *ec2.DeleteVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) *ec2.DeleteVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpc(ctx context.Context, params *ec2.DeleteVpcInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) (*ec2.DeleteVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) *ec2.DeleteVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointConnectionNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcEndpointConnectionNotifications(ctx context.Context, params *ec2.DeleteVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpcEndpointConnectionNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointConnectionNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointConnectionNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpointServiceConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcEndpointServiceConfigurations(ctx context.Context, params *ec2.DeleteVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpcEndpointServiceConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointServiceConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointServiceConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcEndpoints(ctx context.Context, params *ec2.DeleteVpcEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DeleteVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) *ec2.DeleteVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpcPeeringConnection(ctx context.Context, params *ec2.DeleteVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.DeleteVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpnConnection(ctx context.Context, params *ec2.DeleteVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) *ec2.DeleteVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnConnectionRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpnConnectionRoute(ctx context.Context, params *ec2.DeleteVpnConnectionRouteInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpnConnectionRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) (*ec2.DeleteVpnConnectionRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) *ec2.DeleteVpnConnectionRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnConnectionRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnConnectionRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeleteVpnGateway(ctx context.Context, params *ec2.DeleteVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeleteVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DeleteVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) *ec2.DeleteVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeprovisionByoipCidr(ctx context.Context, params *ec2.DeprovisionByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeprovisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeprovisionIpamPoolCidr(ctx context.Context, params *ec2.DeprovisionIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeprovisionIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeprovisionPublicIpv4PoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeprovisionPublicIpv4PoolCidr(ctx context.Context, params *ec2.DeprovisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeprovisionPublicIpv4PoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.DeprovisionPublicIpv4PoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) *ec2.DeprovisionPublicIpv4PoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeprovisionPublicIpv4PoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeprovisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterImage(ctx context.Context, params *ec2.DeregisterImageInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeregisterImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) (*ec2.DeregisterImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) *ec2.DeregisterImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterInstanceEventNotificationAttributes(ctx context.Context, params *ec2.DeregisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeregisterInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DeregisterInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.DeregisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTransitGatewayMulticastGroupMembers provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterTransitGatewayMulticastGroupMembers(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) *ec2.DeregisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterTransitGatewayMulticastGroupSources provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DeregisterTransitGatewayMulticastGroupSources(ctx context.Context, params *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) *ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeregisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeregisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAccountAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAccountAttributes(ctx context.Context, params *ec2.DescribeAccountAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeAccountAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeAccountAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) *ec2.DescribeAccountAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAccountAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAccountAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAddresses(ctx context.Context, params *ec2.DescribeAddressesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) *ec2.DescribeAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAddressesAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAddressesAttribute(ctx context.Context, params *ec2.DescribeAddressesAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeAddressesAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeAddressesAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) *ec2.DescribeAddressesAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAddressesAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAddressesAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAggregateIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAggregateIdFormat(ctx context.Context, params *ec2.DescribeAggregateIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeAggregateIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeAggregateIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeAggregateIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAggregateIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAggregateIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAvailabilityZones provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeAvailabilityZones(ctx context.Context, params *ec2.DescribeAvailabilityZonesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeAvailabilityZonesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) *ec2.DescribeAvailabilityZonesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeAvailabilityZonesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeAvailabilityZonesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeBundleTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeBundleTasks(ctx context.Context, params *ec2.DescribeBundleTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeBundleTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) (*ec2.DescribeBundleTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) *ec2.DescribeBundleTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeBundleTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeBundleTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeByoipCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeByoipCidrs(ctx context.Context, params *ec2.DescribeByoipCidrsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeByoipCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) (*ec2.DescribeByoipCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) *ec2.DescribeByoipCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeByoipCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeByoipCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservationFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCapacityReservationFleets(ctx context.Context, params *ec2.DescribeCapacityReservationFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeCapacityReservationFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCapacityReservations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCapacityReservations(ctx context.Context, params *ec2.DescribeCapacityReservationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeCapacityReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeCapacityReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) *ec2.DescribeCapacityReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCapacityReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCapacityReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCarrierGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCarrierGateways(ctx context.Context, params *ec2.DescribeCarrierGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeCarrierGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCarrierGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeCarrierGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCarrierGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCarrierGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClassicLinkInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClassicLinkInstances(ctx context.Context, params *ec2.DescribeClassicLinkInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeClassicLinkInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeClassicLinkInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) *ec2.DescribeClassicLinkInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClassicLinkInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClassicLinkInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnAuthorizationRules provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnAuthorizationRules(ctx context.Context, params *ec2.DescribeClientVpnAuthorizationRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeClientVpnAuthorizationRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnAuthorizationRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnAuthorizationRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnAuthorizationRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnAuthorizationRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnConnections(ctx context.Context, params *ec2.DescribeClientVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeClientVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnEndpoints(ctx context.Context, params *ec2.DescribeClientVpnEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeClientVpnEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnRoutes(ctx context.Context, params *ec2.DescribeClientVpnRoutesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeClientVpnRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeClientVpnTargetNetworks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeClientVpnTargetNetworks(ctx context.Context, params *ec2.DescribeClientVpnTargetNetworksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeClientVpnTargetNetworksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) (*ec2.DescribeClientVpnTargetNetworksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) *ec2.DescribeClientVpnTargetNetworksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeClientVpnTargetNetworksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeClientVpnTargetNetworksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCoipPools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCoipPools(ctx context.Context, params *ec2.DescribeCoipPoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeCoipPoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeCoipPoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) *ec2.DescribeCoipPoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCoipPoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCoipPoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeConversionTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeConversionTasks(ctx context.Context, params *ec2.DescribeConversionTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeConversionTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) (*ec2.DescribeConversionTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) *ec2.DescribeConversionTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeConversionTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeConversionTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeCustomerGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeCustomerGateways(ctx context.Context, params *ec2.DescribeCustomerGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeCustomerGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeCustomerGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeCustomerGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeCustomerGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeCustomerGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDhcpOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeDhcpOptions(ctx context.Context, params *ec2.DescribeDhcpOptionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeDhcpOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) (*ec2.DescribeDhcpOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) *ec2.DescribeDhcpOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeDhcpOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeDhcpOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEgressOnlyInternetGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeEgressOnlyInternetGateways(ctx context.Context, params *ec2.DescribeEgressOnlyInternetGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeEgressOnlyInternetGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeEgressOnlyInternetGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeEgressOnlyInternetGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeEgressOnlyInternetGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeEgressOnlyInternetGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeElasticGpus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeElasticGpus(ctx context.Context, params *ec2.DescribeElasticGpusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeElasticGpusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) (*ec2.DescribeElasticGpusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) *ec2.DescribeElasticGpusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeElasticGpusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeElasticGpusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExportImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeExportImageTasks(ctx context.Context, params *ec2.DescribeExportImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeExportImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeExportImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeExportImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeExportTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeExportTasks(ctx context.Context, params *ec2.DescribeExportTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeExportTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) (*ec2.DescribeExportTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) *ec2.DescribeExportTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeExportTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeExportTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFastLaunchImages provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFastLaunchImages(ctx context.Context, params *ec2.DescribeFastLaunchImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFastLaunchImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFastLaunchImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) *ec2.DescribeFastLaunchImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastLaunchImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFastLaunchImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFastSnapshotRestores(ctx context.Context, params *ec2.DescribeFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DescribeFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.DescribeFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFleetHistory(ctx context.Context, params *ec2.DescribeFleetHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFleetHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeFleetHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) *ec2.DescribeFleetHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleetInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFleetInstances(ctx context.Context, params *ec2.DescribeFleetInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFleetInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeFleetInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) *ec2.DescribeFleetInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFleets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFleets(ctx context.Context, params *ec2.DescribeFleetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFleetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) (*ec2.DescribeFleetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) *ec2.DescribeFleetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFleetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFleetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFlowLogs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFlowLogs(ctx context.Context, params *ec2.DescribeFlowLogsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFlowLogsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) (*ec2.DescribeFlowLogsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) *ec2.DescribeFlowLogsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFlowLogsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFlowLogsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFpgaImageAttribute(ctx context.Context, params *ec2.DescribeFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.DescribeFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeFpgaImages provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeFpgaImages(ctx context.Context, params *ec2.DescribeFpgaImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeFpgaImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) (*ec2.DescribeFpgaImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) *ec2.DescribeFpgaImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeFpgaImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeFpgaImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostReservationOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeHostReservationOfferings(ctx context.Context, params *ec2.DescribeHostReservationOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeHostReservationOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeHostReservationOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostReservationOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHostReservations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeHostReservations(ctx context.Context, params *ec2.DescribeHostReservationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeHostReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) (*ec2.DescribeHostReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) *ec2.DescribeHostReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeHosts(ctx context.Context, params *ec2.DescribeHostsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) (*ec2.DescribeHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) *ec2.DescribeHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIamInstanceProfileAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIamInstanceProfileAssociations(ctx context.Context, params *ec2.DescribeIamInstanceProfileAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIamInstanceProfileAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeIamInstanceProfileAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeIamInstanceProfileAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIamInstanceProfileAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIamInstanceProfileAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIdFormat(ctx context.Context, params *ec2.DescribeIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIdentityIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIdentityIdFormat(ctx context.Context, params *ec2.DescribeIdentityIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIdentityIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribeIdentityIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) *ec2.DescribeIdentityIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIdentityIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIdentityIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImageAttribute(ctx context.Context, params *ec2.DescribeImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) *ec2.DescribeImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImages provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImages(ctx context.Context, params *ec2.DescribeImagesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeImagesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) (*ec2.DescribeImagesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) *ec2.DescribeImagesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImagesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImagesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImportImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImportImageTasks(ctx context.Context, params *ec2.DescribeImportImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeImportImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeImportImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImportImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeImportSnapshotTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeImportSnapshotTasks(ctx context.Context, params *ec2.DescribeImportSnapshotTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeImportSnapshotTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) (*ec2.DescribeImportSnapshotTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) *ec2.DescribeImportSnapshotTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeImportSnapshotTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeImportSnapshotTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceAttribute(ctx context.Context, params *ec2.DescribeInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) *ec2.DescribeInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceCreditSpecifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceCreditSpecifications(ctx context.Context, params *ec2.DescribeInstanceCreditSpecificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceCreditSpecificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceCreditSpecificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceCreditSpecificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceCreditSpecificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceCreditSpecificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceEventNotificationAttributes(ctx context.Context, params *ec2.DescribeInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceEventWindows provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceEventWindows(ctx context.Context, params *ec2.DescribeInstanceEventWindowsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceEventWindowsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceEventWindowsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceEventWindowsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceEventWindowsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceEventWindowsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceStatus(ctx context.Context, params *ec2.DescribeInstanceStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) *ec2.DescribeInstanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypeOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceTypeOfferings(ctx context.Context, params *ec2.DescribeInstanceTypeOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceTypeOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypeOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypeOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstanceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstanceTypes(ctx context.Context, params *ec2.DescribeInstanceTypesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstanceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInstances(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) *ec2.DescribeInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeInternetGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeInternetGateways(ctx context.Context, params *ec2.DescribeInternetGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeInternetGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeInternetGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeInternetGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInternetGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInternetGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamPools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpamPools(ctx context.Context, params *ec2.DescribeIpamPoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIpamPoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamPoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) *ec2.DescribeIpamPoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamPoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamPoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpamScopes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpamScopes(ctx context.Context, params *ec2.DescribeIpamScopesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIpamScopesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) (*ec2.DescribeIpamScopesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) *ec2.DescribeIpamScopesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamScopesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamScopesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpams provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpams(ctx context.Context, params *ec2.DescribeIpamsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIpamsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) (*ec2.DescribeIpamsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) *ec2.DescribeIpamsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpamsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpamsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIpv6Pools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeIpv6Pools(ctx context.Context, params *ec2.DescribeIpv6PoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeIpv6PoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) (*ec2.DescribeIpv6PoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) *ec2.DescribeIpv6PoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeIpv6PoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeIpv6PoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeKeyPairs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeKeyPairs(ctx context.Context, params *ec2.DescribeKeyPairsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeKeyPairsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) (*ec2.DescribeKeyPairsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) *ec2.DescribeKeyPairsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeKeyPairsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeKeyPairsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchTemplateVersions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLaunchTemplateVersions(ctx context.Context, params *ec2.DescribeLaunchTemplateVersionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLaunchTemplateVersionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplateVersionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) *ec2.DescribeLaunchTemplateVersionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplateVersionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLaunchTemplateVersionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLaunchTemplates provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLaunchTemplates(ctx context.Context, params *ec2.DescribeLaunchTemplatesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLaunchTemplatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) (*ec2.DescribeLaunchTemplatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) *ec2.DescribeLaunchTemplatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLaunchTemplatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLaunchTemplatesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTableVpcAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayRouteTableVpcAssociations(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTableVpcAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTableVpcAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayRouteTables(ctx context.Context, params *ec2.DescribeLocalGatewayRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLocalGatewayRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayVirtualInterfaceGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayVirtualInterfaceGroups(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfaceGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfaceGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGatewayVirtualInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGatewayVirtualInterfaces(ctx context.Context, params *ec2.DescribeLocalGatewayVirtualInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLocalGatewayVirtualInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewayVirtualInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewayVirtualInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewayVirtualInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewayVirtualInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLocalGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeLocalGateways(ctx context.Context, params *ec2.DescribeLocalGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeLocalGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeLocalGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeLocalGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeLocalGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeLocalGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeManagedPrefixLists provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeManagedPrefixLists(ctx context.Context, params *ec2.DescribeManagedPrefixListsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeManagedPrefixListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribeManagedPrefixListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) *ec2.DescribeManagedPrefixListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeManagedPrefixListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeManagedPrefixListsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMovingAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeMovingAddresses(ctx context.Context, params *ec2.DescribeMovingAddressesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeMovingAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) (*ec2.DescribeMovingAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) *ec2.DescribeMovingAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeMovingAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeMovingAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNatGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNatGateways(ctx context.Context, params *ec2.DescribeNatGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNatGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeNatGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeNatGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNatGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNatGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkAcls provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkAcls(ctx context.Context, params *ec2.DescribeNetworkAclsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkAclsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkAclsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkAclsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkAclsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkAclsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsAccessScopeAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsAccessScopeAnalyses(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAccessScopeAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopeAnalysesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsAccessScopes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsAccessScopes(ctx context.Context, params *ec2.DescribeNetworkInsightsAccessScopesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInsightsAccessScopesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAccessScopesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAccessScopesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAccessScopesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAccessScopesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsAnalyses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsAnalyses(ctx context.Context, params *ec2.DescribeNetworkInsightsAnalysesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInsightsAnalysesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsAnalysesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsAnalysesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsAnalysesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsAnalysesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInsightsPaths provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInsightsPaths(ctx context.Context, params *ec2.DescribeNetworkInsightsPathsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInsightsPathsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInsightsPathsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInsightsPathsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInsightsPathsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInsightsPathsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInterfaceAttribute(ctx context.Context, params *ec2.DescribeNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfacePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInterfacePermissions(ctx context.Context, params *ec2.DescribeNetworkInterfacePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInterfacePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfacePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfacePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeNetworkInterfaces provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeNetworkInterfaces(ctx context.Context, params *ec2.DescribeNetworkInterfacesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeNetworkInterfacesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) (*ec2.DescribeNetworkInterfacesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) *ec2.DescribeNetworkInterfacesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeNetworkInterfacesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeNetworkInterfacesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePlacementGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePlacementGroups(ctx context.Context, params *ec2.DescribePlacementGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribePlacementGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) (*ec2.DescribePlacementGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) *ec2.DescribePlacementGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePlacementGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePlacementGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrefixLists provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePrefixLists(ctx context.Context, params *ec2.DescribePrefixListsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribePrefixListsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) (*ec2.DescribePrefixListsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) *ec2.DescribePrefixListsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrefixListsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePrefixListsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrincipalIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePrincipalIdFormat(ctx context.Context, params *ec2.DescribePrincipalIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribePrincipalIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) (*ec2.DescribePrincipalIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) *ec2.DescribePrincipalIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePrincipalIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePrincipalIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePublicIpv4Pools provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribePublicIpv4Pools(ctx context.Context, params *ec2.DescribePublicIpv4PoolsInput, optFns ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribePublicIpv4PoolsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) (*ec2.DescribePublicIpv4PoolsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) *ec2.DescribePublicIpv4PoolsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribePublicIpv4PoolsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribePublicIpv4PoolsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRegions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeRegions(ctx context.Context, params *ec2.DescribeRegionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeRegionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) (*ec2.DescribeRegionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) *ec2.DescribeRegionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRegionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRegionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReplaceRootVolumeTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReplaceRootVolumeTasks(ctx context.Context, params *ec2.DescribeReplaceRootVolumeTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeReplaceRootVolumeTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) (*ec2.DescribeReplaceRootVolumeTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) *ec2.DescribeReplaceRootVolumeTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReplaceRootVolumeTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReplaceRootVolumeTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstances(ctx context.Context, params *ec2.DescribeReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesListings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstancesListings(ctx context.Context, params *ec2.DescribeReservedInstancesListingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeReservedInstancesListingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesListingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesListingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesListingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesListingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesModifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstancesModifications(ctx context.Context, params *ec2.DescribeReservedInstancesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeReservedInstancesModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesModificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeReservedInstancesOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeReservedInstancesOfferings(ctx context.Context, params *ec2.DescribeReservedInstancesOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeReservedInstancesOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeReservedInstancesOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeReservedInstancesOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeReservedInstancesOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeReservedInstancesOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeRouteTables(ctx context.Context, params *ec2.DescribeRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledInstanceAvailability provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeScheduledInstanceAvailability(ctx context.Context, params *ec2.DescribeScheduledInstanceAvailabilityInput, optFns ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeScheduledInstanceAvailabilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstanceAvailabilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) *ec2.DescribeScheduledInstanceAvailabilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstanceAvailabilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeScheduledInstanceAvailabilityInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeScheduledInstances(ctx context.Context, params *ec2.DescribeScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) *ec2.DescribeScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupReferences provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSecurityGroupReferences(ctx context.Context, params *ec2.DescribeSecurityGroupReferencesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSecurityGroupReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroupRules provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSecurityGroupRules(ctx context.Context, params *ec2.DescribeSecurityGroupRulesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSecurityGroupRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSecurityGroups(ctx context.Context, params *ec2.DescribeSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSnapshotAttribute(ctx context.Context, params *ec2.DescribeSnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshotTierStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSnapshotTierStatus(ctx context.Context, params *ec2.DescribeSnapshotTierStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSnapshotTierStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotTierStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotTierStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotTierStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotTierStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSnapshots provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSnapshots(ctx context.Context, params *ec2.DescribeSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSnapshotsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) *ec2.DescribeSnapshotsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSnapshotsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSnapshotsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotDatafeedSubscription provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotDatafeedSubscription(ctx context.Context, params *ec2.DescribeSpotDatafeedSubscriptionInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSpotDatafeedSubscriptionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) (*ec2.DescribeSpotDatafeedSubscriptionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) *ec2.DescribeSpotDatafeedSubscriptionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotDatafeedSubscriptionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotDatafeedSubscriptionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotFleetInstances(ctx context.Context, params *ec2.DescribeSpotFleetInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSpotFleetInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetRequestHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotFleetRequestHistory(ctx context.Context, params *ec2.DescribeSpotFleetRequestHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSpotFleetRequestHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetRequestHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetRequestHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotFleetRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotFleetRequests(ctx context.Context, params *ec2.DescribeSpotFleetRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSpotFleetRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotFleetRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) *ec2.DescribeSpotFleetRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotFleetRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotFleetRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotInstanceRequests provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotInstanceRequests(ctx context.Context, params *ec2.DescribeSpotInstanceRequestsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSpotInstanceRequestsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) (*ec2.DescribeSpotInstanceRequestsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) *ec2.DescribeSpotInstanceRequestsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotInstanceRequestsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotInstanceRequestsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSpotPriceHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSpotPriceHistory(ctx context.Context, params *ec2.DescribeSpotPriceHistoryInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSpotPriceHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) (*ec2.DescribeSpotPriceHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) *ec2.DescribeSpotPriceHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSpotPriceHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSpotPriceHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStaleSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeStaleSecurityGroups(ctx context.Context, params *ec2.DescribeStaleSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeStaleSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeStaleSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeStaleSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStaleSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeStaleSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStoreImageTasks provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeStoreImageTasks(ctx context.Context, params *ec2.DescribeStoreImageTasksInput, optFns ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeStoreImageTasksOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) (*ec2.DescribeStoreImageTasksOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) *ec2.DescribeStoreImageTasksOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeStoreImageTasksOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeStoreImageTasksInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeSubnets(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) *ec2.DescribeSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTags provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTags(ctx context.Context, params *ec2.DescribeTagsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) *ec2.DescribeTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorFilters provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrafficMirrorFilters(ctx context.Context, params *ec2.DescribeTrafficMirrorFiltersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTrafficMirrorFiltersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorFiltersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorFiltersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorFiltersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorFiltersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorSessions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrafficMirrorSessions(ctx context.Context, params *ec2.DescribeTrafficMirrorSessionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTrafficMirrorSessionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorSessionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorSessionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorSessionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorSessionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrafficMirrorTargets provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrafficMirrorTargets(ctx context.Context, params *ec2.DescribeTrafficMirrorTargetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTrafficMirrorTargetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) (*ec2.DescribeTrafficMirrorTargetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) *ec2.DescribeTrafficMirrorTargetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrafficMirrorTargetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrafficMirrorTargetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayConnectPeers provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayConnectPeers(ctx context.Context, params *ec2.DescribeTransitGatewayConnectPeersInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayConnectPeersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectPeersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayConnectPeersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayConnectPeersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayConnectPeersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayConnects provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayConnects(ctx context.Context, params *ec2.DescribeTransitGatewayConnectsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayConnectsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayConnectsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayConnectsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayConnectsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayConnectsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayMulticastDomains provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayMulticastDomains(ctx context.Context, params *ec2.DescribeTransitGatewayMulticastDomainsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayMulticastDomainsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayMulticastDomainsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayMulticastDomainsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayMulticastDomainsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayMulticastDomainsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayPeeringAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayPeeringAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayPeeringAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayPeeringAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayPeeringAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayPeeringAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayPeeringAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayPeeringAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayRouteTables provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayRouteTables(ctx context.Context, params *ec2.DescribeTransitGatewayRouteTablesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayRouteTablesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayRouteTablesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayRouteTablesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayRouteTablesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayRouteTablesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGatewayVpcAttachments provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGatewayVpcAttachments(ctx context.Context, params *ec2.DescribeTransitGatewayVpcAttachmentsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewayVpcAttachmentsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewayVpcAttachmentsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewayVpcAttachmentsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewayVpcAttachmentsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewayVpcAttachmentsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTransitGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTransitGateways(ctx context.Context, params *ec2.DescribeTransitGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTransitGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeTransitGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeTransitGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTransitGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTransitGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeTrunkInterfaceAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeTrunkInterfaceAssociations(ctx context.Context, params *ec2.DescribeTrunkInterfaceAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeTrunkInterfaceAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) (*ec2.DescribeTrunkInterfaceAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) *ec2.DescribeTrunkInterfaceAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeTrunkInterfaceAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeTrunkInterfaceAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumeAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumeAttribute(ctx context.Context, params *ec2.DescribeVolumeAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVolumeAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) *ec2.DescribeVolumeAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumeAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumeStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumeStatus(ctx context.Context, params *ec2.DescribeVolumeStatusInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVolumeStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) (*ec2.DescribeVolumeStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) *ec2.DescribeVolumeStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumeStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumeStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumes(ctx context.Context, params *ec2.DescribeVolumesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVolumesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) *ec2.DescribeVolumesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVolumesModifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVolumesModifications(ctx context.Context, params *ec2.DescribeVolumesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVolumesModificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) *ec2.DescribeVolumesModificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVolumesModificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVolumesModificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcAttribute(ctx context.Context, params *ec2.DescribeVpcAttributeInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) (*ec2.DescribeVpcAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) *ec2.DescribeVpcAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcClassicLink(ctx context.Context, params *ec2.DescribeVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.DescribeVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.DescribeVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DescribeVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.DescribeVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointConnectionNotifications provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointConnectionNotifications(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionNotificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcEndpointConnectionNotificationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionNotificationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointConnectionNotificationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionNotificationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointConnectionNotificationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointConnections(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServiceConfigurations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointServiceConfigurations(ctx context.Context, params *ec2.DescribeVpcEndpointServiceConfigurationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcEndpointServiceConfigurationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServiceConfigurationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServiceConfigurationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServiceConfigurationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServiceConfigurationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServicePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointServicePermissions(ctx context.Context, params *ec2.DescribeVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcEndpointServicePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpointServices provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpointServices(ctx context.Context, params *ec2.DescribeVpcEndpointServicesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcEndpointServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointServicesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcEndpoints provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcEndpoints(ctx context.Context, params *ec2.DescribeVpcEndpointsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcEndpointsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) *ec2.DescribeVpcEndpointsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcEndpointsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcEndpointsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcPeeringConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcPeeringConnections(ctx context.Context, params *ec2.DescribeVpcPeeringConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcPeeringConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcPeeringConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpcPeeringConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcPeeringConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcPeeringConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpcs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpcs(ctx context.Context, params *ec2.DescribeVpcsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpcsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) *ec2.DescribeVpcsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpnConnections(ctx context.Context, params *ec2.DescribeVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.DescribeVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) *ec2.DescribeVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeVpnGateways provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DescribeVpnGateways(ctx context.Context, params *ec2.DescribeVpnGatewaysInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DescribeVpnGatewaysOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) (*ec2.DescribeVpnGatewaysOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) *ec2.DescribeVpnGatewaysOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpnGatewaysOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpnGatewaysInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachClassicLinkVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachClassicLinkVpc(ctx context.Context, params *ec2.DetachClassicLinkVpcInput, optFns ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DetachClassicLinkVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) (*ec2.DetachClassicLinkVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) *ec2.DetachClassicLinkVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachClassicLinkVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachClassicLinkVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachInternetGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachInternetGateway(ctx context.Context, params *ec2.DetachInternetGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DetachInternetGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) (*ec2.DetachInternetGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) *ec2.DetachInternetGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachInternetGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachInternetGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachNetworkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachNetworkInterface(ctx context.Context, params *ec2.DetachNetworkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DetachNetworkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) (*ec2.DetachNetworkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) *ec2.DetachNetworkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachNetworkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachNetworkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachVolume(ctx context.Context, params *ec2.DetachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DetachVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) *ec2.DetachVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachVpnGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DetachVpnGateway(ctx context.Context, params *ec2.DetachVpnGatewayInput, optFns ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DetachVpnGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) (*ec2.DetachVpnGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) *ec2.DetachVpnGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DetachVpnGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DetachVpnGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableEbsEncryptionByDefault(ctx context.Context, params *ec2.DisableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.DisableEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.DisableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableFastLaunch provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableFastLaunch(ctx context.Context, params *ec2.DisableFastLaunchInput, optFns ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableFastLaunchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) (*ec2.DisableFastLaunchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) *ec2.DisableFastLaunchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastLaunchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableFastLaunchInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableFastSnapshotRestores(ctx context.Context, params *ec2.DisableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.DisableFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.DisableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableImageDeprecation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableImageDeprecation(ctx context.Context, params *ec2.DisableImageDeprecationInput, optFns ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableImageDeprecationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.DisableImageDeprecationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) *ec2.DisableImageDeprecationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableImageDeprecationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableImageDeprecationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableIpamOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableIpamOrganizationAdminAccount(ctx context.Context, params *ec2.DisableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableIpamOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.DisableIpamOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) *ec2.DisableIpamOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableIpamOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableSerialConsoleAccess provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableSerialConsoleAccess(ctx context.Context, params *ec2.DisableSerialConsoleAccessInput, optFns ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableSerialConsoleAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.DisableSerialConsoleAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) *ec2.DisableSerialConsoleAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableSerialConsoleAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableSerialConsoleAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableTransitGatewayRouteTablePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableTransitGatewayRouteTablePropagation(ctx context.Context, params *ec2.DisableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableTransitGatewayRouteTablePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.DisableTransitGatewayRouteTablePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) *ec2.DisableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableTransitGatewayRouteTablePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVgwRoutePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableVgwRoutePropagation(ctx context.Context, params *ec2.DisableVgwRoutePropagationInput, optFns ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableVgwRoutePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.DisableVgwRoutePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) *ec2.DisableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVgwRoutePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVgwRoutePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableVpcClassicLink(ctx context.Context, params *ec2.DisableVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.DisableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisableVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.DisableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisableVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.DisableVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.DisableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisableVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateAddress(ctx context.Context, params *ec2.DisassociateAddressInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) (*ec2.DisassociateAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) *ec2.DisassociateAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateClientVpnTargetNetwork provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateClientVpnTargetNetwork(ctx context.Context, params *ec2.DisassociateClientVpnTargetNetworkInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateClientVpnTargetNetworkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) (*ec2.DisassociateClientVpnTargetNetworkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) *ec2.DisassociateClientVpnTargetNetworkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateClientVpnTargetNetworkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateClientVpnTargetNetworkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateEnclaveCertificateIamRole provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateEnclaveCertificateIamRole(ctx context.Context, params *ec2.DisassociateEnclaveCertificateIamRoleInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateEnclaveCertificateIamRoleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) (*ec2.DisassociateEnclaveCertificateIamRoleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) *ec2.DisassociateEnclaveCertificateIamRoleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateEnclaveCertificateIamRoleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateEnclaveCertificateIamRoleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateIamInstanceProfile provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateIamInstanceProfile(ctx context.Context, params *ec2.DisassociateIamInstanceProfileInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateIamInstanceProfileOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) (*ec2.DisassociateIamInstanceProfileOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) *ec2.DisassociateIamInstanceProfileOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateIamInstanceProfileOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateIamInstanceProfileInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateInstanceEventWindow(ctx context.Context, params *ec2.DisassociateInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.DisassociateInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.DisassociateInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateRouteTable(ctx context.Context, params *ec2.DisassociateRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) *ec2.DisassociateRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateSubnetCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateSubnetCidrBlock(ctx context.Context, params *ec2.DisassociateSubnetCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateSubnetCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateSubnetCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) *ec2.DisassociateSubnetCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateSubnetCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateSubnetCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayMulticastDomain provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateTransitGatewayMulticastDomain(ctx context.Context, params *ec2.DisassociateTransitGatewayMulticastDomainInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateTransitGatewayMulticastDomainOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayMulticastDomainOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayMulticastDomainOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayMulticastDomainOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayMulticastDomainInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTransitGatewayRouteTable provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateTransitGatewayRouteTable(ctx context.Context, params *ec2.DisassociateTransitGatewayRouteTableInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateTransitGatewayRouteTableOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) (*ec2.DisassociateTransitGatewayRouteTableOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) *ec2.DisassociateTransitGatewayRouteTableOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTransitGatewayRouteTableOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTransitGatewayRouteTableInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateTrunkInterface provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateTrunkInterface(ctx context.Context, params *ec2.DisassociateTrunkInterfaceInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateTrunkInterfaceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) (*ec2.DisassociateTrunkInterfaceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) *ec2.DisassociateTrunkInterfaceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateTrunkInterfaceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateTrunkInterfaceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisassociateVpcCidrBlock provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) DisassociateVpcCidrBlock(ctx context.Context, params *ec2.DisassociateVpcCidrBlockInput, optFns ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.DisassociateVpcCidrBlockOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) (*ec2.DisassociateVpcCidrBlockOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) *ec2.DisassociateVpcCidrBlockOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DisassociateVpcCidrBlockOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DisassociateVpcCidrBlockInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableEbsEncryptionByDefault(ctx context.Context, params *ec2.EnableEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.EnableEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.EnableEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableFastLaunch provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableFastLaunch(ctx context.Context, params *ec2.EnableFastLaunchInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableFastLaunchOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) (*ec2.EnableFastLaunchOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) *ec2.EnableFastLaunchOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastLaunchOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableFastLaunchInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableFastSnapshotRestores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableFastSnapshotRestores(ctx context.Context, params *ec2.EnableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableFastSnapshotRestoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) *ec2.EnableFastSnapshotRestoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableFastSnapshotRestoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableFastSnapshotRestoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableImageDeprecation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableImageDeprecation(ctx context.Context, params *ec2.EnableImageDeprecationInput, optFns ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableImageDeprecationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) (*ec2.EnableImageDeprecationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) *ec2.EnableImageDeprecationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableImageDeprecationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableImageDeprecationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableIpamOrganizationAdminAccount provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableIpamOrganizationAdminAccount(ctx context.Context, params *ec2.EnableIpamOrganizationAdminAccountInput, optFns ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableIpamOrganizationAdminAccountOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) (*ec2.EnableIpamOrganizationAdminAccountOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) *ec2.EnableIpamOrganizationAdminAccountOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableIpamOrganizationAdminAccountOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableIpamOrganizationAdminAccountInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableSerialConsoleAccess provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableSerialConsoleAccess(ctx context.Context, params *ec2.EnableSerialConsoleAccessInput, optFns ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableSerialConsoleAccessOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) (*ec2.EnableSerialConsoleAccessOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) *ec2.EnableSerialConsoleAccessOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableSerialConsoleAccessOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableSerialConsoleAccessInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableTransitGatewayRouteTablePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableTransitGatewayRouteTablePropagation(ctx context.Context, params *ec2.EnableTransitGatewayRouteTablePropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableTransitGatewayRouteTablePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) (*ec2.EnableTransitGatewayRouteTablePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) *ec2.EnableTransitGatewayRouteTablePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableTransitGatewayRouteTablePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableTransitGatewayRouteTablePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVgwRoutePropagation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVgwRoutePropagation(ctx context.Context, params *ec2.EnableVgwRoutePropagationInput, optFns ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableVgwRoutePropagationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) (*ec2.EnableVgwRoutePropagationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) *ec2.EnableVgwRoutePropagationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVgwRoutePropagationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVgwRoutePropagationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVolumeIO provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVolumeIO(ctx context.Context, params *ec2.EnableVolumeIOInput, optFns ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableVolumeIOOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) (*ec2.EnableVolumeIOOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) *ec2.EnableVolumeIOOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVolumeIOOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVolumeIOInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVpcClassicLink provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVpcClassicLink(ctx context.Context, params *ec2.EnableVpcClassicLinkInput, optFns ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableVpcClassicLinkOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) *ec2.EnableVpcClassicLinkOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVpcClassicLinkInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableVpcClassicLinkDnsSupport provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) EnableVpcClassicLinkDnsSupport(ctx context.Context, params *ec2.EnableVpcClassicLinkDnsSupportInput, optFns ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.EnableVpcClassicLinkDnsSupportOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) (*ec2.EnableVpcClassicLinkDnsSupportOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) *ec2.EnableVpcClassicLinkDnsSupportOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.EnableVpcClassicLinkDnsSupportOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.EnableVpcClassicLinkDnsSupportInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportClientVpnClientCertificateRevocationList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportClientVpnClientCertificateRevocationList(ctx context.Context, params *ec2.ExportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ExportClientVpnClientCertificateRevocationListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientCertificateRevocationListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) *ec2.ExportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientCertificateRevocationListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportClientVpnClientConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportClientVpnClientConfiguration(ctx context.Context, params *ec2.ExportClientVpnClientConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ExportClientVpnClientConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) (*ec2.ExportClientVpnClientConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) *ec2.ExportClientVpnClientConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportClientVpnClientConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportClientVpnClientConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportImage(ctx context.Context, params *ec2.ExportImageInput, optFns ...func(*ec2.Options)) (*ec2.ExportImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ExportImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) (*ec2.ExportImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) *ec2.ExportImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportTransitGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ExportTransitGatewayRoutes(ctx context.Context, params *ec2.ExportTransitGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ExportTransitGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.ExportTransitGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) *ec2.ExportTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ExportTransitGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ExportTransitGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedEnclaveCertificateIamRoles provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetAssociatedEnclaveCertificateIamRoles(ctx context.Context, params *ec2.GetAssociatedEnclaveCertificateIamRolesInput, optFns ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetAssociatedEnclaveCertificateIamRolesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) (*ec2.GetAssociatedEnclaveCertificateIamRolesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) *ec2.GetAssociatedEnclaveCertificateIamRolesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedEnclaveCertificateIamRolesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAssociatedEnclaveCertificateIamRolesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAssociatedIpv6PoolCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetAssociatedIpv6PoolCidrs(ctx context.Context, params *ec2.GetAssociatedIpv6PoolCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetAssociatedIpv6PoolCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetAssociatedIpv6PoolCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) *ec2.GetAssociatedIpv6PoolCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetAssociatedIpv6PoolCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetAssociatedIpv6PoolCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCapacityReservationUsage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetCapacityReservationUsage(ctx context.Context, params *ec2.GetCapacityReservationUsageInput, optFns ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetCapacityReservationUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) (*ec2.GetCapacityReservationUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) *ec2.GetCapacityReservationUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCapacityReservationUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCapacityReservationUsageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCoipPoolUsage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetCoipPoolUsage(ctx context.Context, params *ec2.GetCoipPoolUsageInput, optFns ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetCoipPoolUsageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) (*ec2.GetCoipPoolUsageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) *ec2.GetCoipPoolUsageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetCoipPoolUsageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetCoipPoolUsageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsoleOutput provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetConsoleOutput(ctx context.Context, params *ec2.GetConsoleOutputInput, optFns ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetConsoleOutputOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) (*ec2.GetConsoleOutputOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) *ec2.GetConsoleOutputOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleOutputOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetConsoleOutputInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsoleScreenshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetConsoleScreenshot(ctx context.Context, params *ec2.GetConsoleScreenshotInput, optFns ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetConsoleScreenshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) (*ec2.GetConsoleScreenshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) *ec2.GetConsoleScreenshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetConsoleScreenshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetConsoleScreenshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetDefaultCreditSpecification(ctx context.Context, params *ec2.GetDefaultCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetDefaultCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.GetDefaultCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) *ec2.GetDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetDefaultCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetDefaultCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetEbsDefaultKmsKeyId(ctx context.Context, params *ec2.GetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.GetEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.GetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEbsEncryptionByDefault provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetEbsEncryptionByDefault(ctx context.Context, params *ec2.GetEbsEncryptionByDefaultInput, optFns ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetEbsEncryptionByDefaultOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) (*ec2.GetEbsEncryptionByDefaultOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) *ec2.GetEbsEncryptionByDefaultOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetEbsEncryptionByDefaultOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetEbsEncryptionByDefaultInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFlowLogsIntegrationTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetFlowLogsIntegrationTemplate(ctx context.Context, params *ec2.GetFlowLogsIntegrationTemplateInput, optFns ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetFlowLogsIntegrationTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) (*ec2.GetFlowLogsIntegrationTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) *ec2.GetFlowLogsIntegrationTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetFlowLogsIntegrationTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetFlowLogsIntegrationTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupsForCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetGroupsForCapacityReservation(ctx context.Context, params *ec2.GetGroupsForCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetGroupsForCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) (*ec2.GetGroupsForCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) *ec2.GetGroupsForCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetGroupsForCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetGroupsForCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostReservationPurchasePreview provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetHostReservationPurchasePreview(ctx context.Context, params *ec2.GetHostReservationPurchasePreviewInput, optFns ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetHostReservationPurchasePreviewOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) (*ec2.GetHostReservationPurchasePreviewOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) *ec2.GetHostReservationPurchasePreviewOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetHostReservationPurchasePreviewOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetHostReservationPurchasePreviewInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInstanceTypesFromInstanceRequirements provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetInstanceTypesFromInstanceRequirements(ctx context.Context, params *ec2.GetInstanceTypesFromInstanceRequirementsInput, optFns ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetInstanceTypesFromInstanceRequirementsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) (*ec2.GetInstanceTypesFromInstanceRequirementsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) *ec2.GetInstanceTypesFromInstanceRequirementsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetInstanceTypesFromInstanceRequirementsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetInstanceTypesFromInstanceRequirementsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamAddressHistory provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamAddressHistory(ctx context.Context, params *ec2.GetIpamAddressHistoryInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetIpamAddressHistoryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) (*ec2.GetIpamAddressHistoryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) *ec2.GetIpamAddressHistoryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamAddressHistoryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamAddressHistoryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPoolAllocations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamPoolAllocations(ctx context.Context, params *ec2.GetIpamPoolAllocationsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetIpamPoolAllocationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolAllocationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) *ec2.GetIpamPoolAllocationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPoolAllocationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPoolAllocationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamPoolCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamPoolCidrs(ctx context.Context, params *ec2.GetIpamPoolCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetIpamPoolCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamPoolCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamPoolCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamPoolCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamPoolCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIpamResourceCidrs provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetIpamResourceCidrs(ctx context.Context, params *ec2.GetIpamResourceCidrsInput, optFns ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetIpamResourceCidrsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) (*ec2.GetIpamResourceCidrsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) *ec2.GetIpamResourceCidrsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetIpamResourceCidrsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetIpamResourceCidrsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLaunchTemplateData provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetLaunchTemplateData(ctx context.Context, params *ec2.GetLaunchTemplateDataInput, optFns ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetLaunchTemplateDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) (*ec2.GetLaunchTemplateDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) *ec2.GetLaunchTemplateDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetLaunchTemplateDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetLaunchTemplateDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedPrefixListAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetManagedPrefixListAssociations(ctx context.Context, params *ec2.GetManagedPrefixListAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetManagedPrefixListAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) *ec2.GetManagedPrefixListAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetManagedPrefixListAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetManagedPrefixListEntries provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetManagedPrefixListEntries(ctx context.Context, params *ec2.GetManagedPrefixListEntriesInput, optFns ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetManagedPrefixListEntriesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) (*ec2.GetManagedPrefixListEntriesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) *ec2.GetManagedPrefixListEntriesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetManagedPrefixListEntriesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetManagedPrefixListEntriesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkInsightsAccessScopeAnalysisFindings provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetNetworkInsightsAccessScopeAnalysisFindings(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, optFns ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetNetworkInsightsAccessScopeAnalysisFindingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeAnalysisFindingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkInsightsAccessScopeContent provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetNetworkInsightsAccessScopeContent(ctx context.Context, params *ec2.GetNetworkInsightsAccessScopeContentInput, optFns ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetNetworkInsightsAccessScopeContentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) (*ec2.GetNetworkInsightsAccessScopeContentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) *ec2.GetNetworkInsightsAccessScopeContentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetNetworkInsightsAccessScopeContentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetNetworkInsightsAccessScopeContentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPasswordData provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetPasswordData(ctx context.Context, params *ec2.GetPasswordDataInput, optFns ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetPasswordDataOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) (*ec2.GetPasswordDataOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) *ec2.GetPasswordDataOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetPasswordDataOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetPasswordDataInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReservedInstancesExchangeQuote provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetReservedInstancesExchangeQuote(ctx context.Context, params *ec2.GetReservedInstancesExchangeQuoteInput, optFns ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetReservedInstancesExchangeQuoteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) (*ec2.GetReservedInstancesExchangeQuoteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) *ec2.GetReservedInstancesExchangeQuoteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetReservedInstancesExchangeQuoteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetReservedInstancesExchangeQuoteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSerialConsoleAccessStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetSerialConsoleAccessStatus(ctx context.Context, params *ec2.GetSerialConsoleAccessStatusInput, optFns ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetSerialConsoleAccessStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) (*ec2.GetSerialConsoleAccessStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) *ec2.GetSerialConsoleAccessStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSerialConsoleAccessStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSerialConsoleAccessStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSpotPlacementScores provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetSpotPlacementScores(ctx context.Context, params *ec2.GetSpotPlacementScoresInput, optFns ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetSpotPlacementScoresOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) (*ec2.GetSpotPlacementScoresOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) *ec2.GetSpotPlacementScoresOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSpotPlacementScoresOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSpotPlacementScoresInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubnetCidrReservations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetSubnetCidrReservations(ctx context.Context, params *ec2.GetSubnetCidrReservationsInput, optFns ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetSubnetCidrReservationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) (*ec2.GetSubnetCidrReservationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) *ec2.GetSubnetCidrReservationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetSubnetCidrReservationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetSubnetCidrReservationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayAttachmentPropagations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayAttachmentPropagations(ctx context.Context, params *ec2.GetTransitGatewayAttachmentPropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetTransitGatewayAttachmentPropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayAttachmentPropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayAttachmentPropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayAttachmentPropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayAttachmentPropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.GetTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayPrefixListReferences provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayPrefixListReferences(ctx context.Context, params *ec2.GetTransitGatewayPrefixListReferencesInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetTransitGatewayPrefixListReferencesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayPrefixListReferencesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayPrefixListReferencesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayPrefixListReferencesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayPrefixListReferencesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayRouteTableAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayRouteTableAssociations(ctx context.Context, params *ec2.GetTransitGatewayRouteTableAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetTransitGatewayRouteTableAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTableAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayRouteTableAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTableAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayRouteTableAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitGatewayRouteTablePropagations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetTransitGatewayRouteTablePropagations(ctx context.Context, params *ec2.GetTransitGatewayRouteTablePropagationsInput, optFns ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetTransitGatewayRouteTablePropagationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) (*ec2.GetTransitGatewayRouteTablePropagationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) *ec2.GetTransitGatewayRouteTablePropagationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetTransitGatewayRouteTablePropagationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetTransitGatewayRouteTablePropagationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVpnConnectionDeviceSampleConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetVpnConnectionDeviceSampleConfiguration(ctx context.Context, params *ec2.GetVpnConnectionDeviceSampleConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetVpnConnectionDeviceSampleConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceSampleConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) *ec2.GetVpnConnectionDeviceSampleConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnConnectionDeviceSampleConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnConnectionDeviceSampleConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVpnConnectionDeviceTypes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) GetVpnConnectionDeviceTypes(ctx context.Context, params *ec2.GetVpnConnectionDeviceTypesInput, optFns ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.GetVpnConnectionDeviceTypesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) (*ec2.GetVpnConnectionDeviceTypesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) *ec2.GetVpnConnectionDeviceTypesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.GetVpnConnectionDeviceTypesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.GetVpnConnectionDeviceTypesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportClientVpnClientCertificateRevocationList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportClientVpnClientCertificateRevocationList(ctx context.Context, params *ec2.ImportClientVpnClientCertificateRevocationListInput, optFns ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ImportClientVpnClientCertificateRevocationListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) (*ec2.ImportClientVpnClientCertificateRevocationListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) *ec2.ImportClientVpnClientCertificateRevocationListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportClientVpnClientCertificateRevocationListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportClientVpnClientCertificateRevocationListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportImage(ctx context.Context, params *ec2.ImportImageInput, optFns ...func(*ec2.Options)) (*ec2.ImportImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ImportImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) (*ec2.ImportImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) *ec2.ImportImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportInstance provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportInstance(ctx context.Context, params *ec2.ImportInstanceInput, optFns ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ImportInstanceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) (*ec2.ImportInstanceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) *ec2.ImportInstanceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportInstanceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportInstanceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportKeyPair provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportKeyPair(ctx context.Context, params *ec2.ImportKeyPairInput, optFns ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ImportKeyPairOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) (*ec2.ImportKeyPairOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) *ec2.ImportKeyPairOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportKeyPairOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportKeyPairInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSnapshot provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportSnapshot(ctx context.Context, params *ec2.ImportSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ImportSnapshotOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) (*ec2.ImportSnapshotOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) *ec2.ImportSnapshotOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportSnapshotOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportSnapshotInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ImportVolume(ctx context.Context, params *ec2.ImportVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ImportVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) (*ec2.ImportVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) *ec2.ImportVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ImportVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ImportVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImagesInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ListImagesInRecycleBin(ctx context.Context, params *ec2.ListImagesInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ListImagesInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListImagesInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListImagesInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListImagesInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListImagesInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshotsInRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ListSnapshotsInRecycleBin(ctx context.Context, params *ec2.ListSnapshotsInRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ListSnapshotsInRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) (*ec2.ListSnapshotsInRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) *ec2.ListSnapshotsInRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ListSnapshotsInRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ListSnapshotsInRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAddressAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyAddressAttribute(ctx context.Context, params *ec2.ModifyAddressAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyAddressAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyAddressAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) *ec2.ModifyAddressAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAddressAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyAddressAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyAvailabilityZoneGroup provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyAvailabilityZoneGroup(ctx context.Context, params *ec2.ModifyAvailabilityZoneGroupInput, optFns ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyAvailabilityZoneGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) (*ec2.ModifyAvailabilityZoneGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) *ec2.ModifyAvailabilityZoneGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyAvailabilityZoneGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyAvailabilityZoneGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCapacityReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyCapacityReservation(ctx context.Context, params *ec2.ModifyCapacityReservationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyCapacityReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) *ec2.ModifyCapacityReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyCapacityReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyCapacityReservationFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyCapacityReservationFleet(ctx context.Context, params *ec2.ModifyCapacityReservationFleetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyCapacityReservationFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) (*ec2.ModifyCapacityReservationFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) *ec2.ModifyCapacityReservationFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyCapacityReservationFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyCapacityReservationFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyClientVpnEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyClientVpnEndpoint(ctx context.Context, params *ec2.ModifyClientVpnEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyClientVpnEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyClientVpnEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) *ec2.ModifyClientVpnEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyClientVpnEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyClientVpnEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyDefaultCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyDefaultCreditSpecification(ctx context.Context, params *ec2.ModifyDefaultCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyDefaultCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyDefaultCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) *ec2.ModifyDefaultCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyDefaultCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyDefaultCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyEbsDefaultKmsKeyId(ctx context.Context, params *ec2.ModifyEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ModifyEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.ModifyEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyFleet(ctx context.Context, params *ec2.ModifyFleetInput, optFns ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) (*ec2.ModifyFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) *ec2.ModifyFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyFpgaImageAttribute(ctx context.Context, params *ec2.ModifyFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.ModifyFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyHosts(ctx context.Context, params *ec2.ModifyHostsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) (*ec2.ModifyHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) *ec2.ModifyHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIdFormat(ctx context.Context, params *ec2.ModifyIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) *ec2.ModifyIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIdentityIdFormat provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIdentityIdFormat(ctx context.Context, params *ec2.ModifyIdentityIdFormatInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyIdentityIdFormatOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) (*ec2.ModifyIdentityIdFormatOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) *ec2.ModifyIdentityIdFormatOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIdentityIdFormatOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIdentityIdFormatInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyImageAttribute(ctx context.Context, params *ec2.ModifyImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) *ec2.ModifyImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceAttribute(ctx context.Context, params *ec2.ModifyInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) *ec2.ModifyInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCapacityReservationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceCapacityReservationAttributes(ctx context.Context, params *ec2.ModifyInstanceCapacityReservationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceCapacityReservationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCapacityReservationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCapacityReservationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCapacityReservationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCapacityReservationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceCreditSpecification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceCreditSpecification(ctx context.Context, params *ec2.ModifyInstanceCreditSpecificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceCreditSpecificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceCreditSpecificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) *ec2.ModifyInstanceCreditSpecificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceCreditSpecificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceCreditSpecificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceEventStartTime provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceEventStartTime(ctx context.Context, params *ec2.ModifyInstanceEventStartTimeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceEventStartTimeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventStartTimeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) *ec2.ModifyInstanceEventStartTimeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventStartTimeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceEventStartTimeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceEventWindow provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceEventWindow(ctx context.Context, params *ec2.ModifyInstanceEventWindowInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceEventWindowOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceEventWindowOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) *ec2.ModifyInstanceEventWindowOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceEventWindowOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceEventWindowInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceMaintenanceOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceMaintenanceOptions(ctx context.Context, params *ec2.ModifyInstanceMaintenanceOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceMaintenanceOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMaintenanceOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMaintenanceOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMaintenanceOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMaintenanceOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstanceMetadataOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstanceMetadataOptions(ctx context.Context, params *ec2.ModifyInstanceMetadataOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstanceMetadataOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyInstanceMetadataOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) *ec2.ModifyInstanceMetadataOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstanceMetadataOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstanceMetadataOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyInstancePlacement provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyInstancePlacement(ctx context.Context, params *ec2.ModifyInstancePlacementInput, optFns ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyInstancePlacementOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) (*ec2.ModifyInstancePlacementOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) *ec2.ModifyInstancePlacementOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyInstancePlacementOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyInstancePlacementInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpam(ctx context.Context, params *ec2.ModifyIpamInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) (*ec2.ModifyIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) *ec2.ModifyIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamPool provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpamPool(ctx context.Context, params *ec2.ModifyIpamPoolInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyIpamPoolOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) (*ec2.ModifyIpamPoolOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) *ec2.ModifyIpamPoolOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamPoolOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamPoolInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamResourceCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpamResourceCidr(ctx context.Context, params *ec2.ModifyIpamResourceCidrInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyIpamResourceCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) (*ec2.ModifyIpamResourceCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) *ec2.ModifyIpamResourceCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamResourceCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamResourceCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyIpamScope provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyIpamScope(ctx context.Context, params *ec2.ModifyIpamScopeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyIpamScopeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) (*ec2.ModifyIpamScopeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) *ec2.ModifyIpamScopeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyIpamScopeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyIpamScopeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyLaunchTemplate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyLaunchTemplate(ctx context.Context, params *ec2.ModifyLaunchTemplateInput, optFns ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyLaunchTemplateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) (*ec2.ModifyLaunchTemplateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) *ec2.ModifyLaunchTemplateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyLaunchTemplateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyLaunchTemplateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyManagedPrefixList provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyManagedPrefixList(ctx context.Context, params *ec2.ModifyManagedPrefixListInput, optFns ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyManagedPrefixListOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) (*ec2.ModifyManagedPrefixListOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) *ec2.ModifyManagedPrefixListOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyManagedPrefixListOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyManagedPrefixListInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyNetworkInterfaceAttribute(ctx context.Context, params *ec2.ModifyNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.ModifyNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyPrivateDnsNameOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyPrivateDnsNameOptions(ctx context.Context, params *ec2.ModifyPrivateDnsNameOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyPrivateDnsNameOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyPrivateDnsNameOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) *ec2.ModifyPrivateDnsNameOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyPrivateDnsNameOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyPrivateDnsNameOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyReservedInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyReservedInstances(ctx context.Context, params *ec2.ModifyReservedInstancesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyReservedInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) (*ec2.ModifyReservedInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) *ec2.ModifyReservedInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyReservedInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyReservedInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySecurityGroupRules provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySecurityGroupRules(ctx context.Context, params *ec2.ModifySecurityGroupRulesInput, optFns ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifySecurityGroupRulesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) (*ec2.ModifySecurityGroupRulesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) *ec2.ModifySecurityGroupRulesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySecurityGroupRulesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySecurityGroupRulesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySnapshotAttribute(ctx context.Context, params *ec2.ModifySnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifySnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) *ec2.ModifySnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySnapshotTier provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySnapshotTier(ctx context.Context, params *ec2.ModifySnapshotTierInput, optFns ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifySnapshotTierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) (*ec2.ModifySnapshotTierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) *ec2.ModifySnapshotTierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySnapshotTierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySnapshotTierInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySpotFleetRequest provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySpotFleetRequest(ctx context.Context, params *ec2.ModifySpotFleetRequestInput, optFns ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifySpotFleetRequestOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) (*ec2.ModifySpotFleetRequestOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) *ec2.ModifySpotFleetRequestOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySpotFleetRequestOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySpotFleetRequestInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifySubnetAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifySubnetAttribute(ctx context.Context, params *ec2.ModifySubnetAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifySubnetAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) (*ec2.ModifySubnetAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) *ec2.ModifySubnetAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifySubnetAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifySubnetAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorFilterNetworkServices provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTrafficMirrorFilterNetworkServices(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorFilterNetworkServicesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterNetworkServicesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorFilterNetworkServicesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorFilterRule provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTrafficMirrorFilterRule(ctx context.Context, params *ec2.ModifyTrafficMirrorFilterRuleInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyTrafficMirrorFilterRuleOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorFilterRuleOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorFilterRuleOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorFilterRuleOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorFilterRuleInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTrafficMirrorSession provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTrafficMirrorSession(ctx context.Context, params *ec2.ModifyTrafficMirrorSessionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyTrafficMirrorSessionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) (*ec2.ModifyTrafficMirrorSessionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) *ec2.ModifyTrafficMirrorSessionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTrafficMirrorSessionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTrafficMirrorSessionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGateway provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTransitGateway(ctx context.Context, params *ec2.ModifyTransitGatewayInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyTransitGatewayOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayPrefixListReference provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTransitGatewayPrefixListReference(ctx context.Context, params *ec2.ModifyTransitGatewayPrefixListReferenceInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyTransitGatewayPrefixListReferenceOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayPrefixListReferenceOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayPrefixListReferenceOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayPrefixListReferenceOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayPrefixListReferenceInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyTransitGatewayVpcAttachment(ctx context.Context, params *ec2.ModifyTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.ModifyTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.ModifyTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVolume provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVolume(ctx context.Context, params *ec2.ModifyVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVolumeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) *ec2.ModifyVolumeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVolumeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVolumeAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVolumeAttribute(ctx context.Context, params *ec2.ModifyVolumeAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVolumeAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVolumeAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) *ec2.ModifyVolumeAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVolumeAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVolumeAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcAttribute(ctx context.Context, params *ec2.ModifyVpcAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) (*ec2.ModifyVpcAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) *ec2.ModifyVpcAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpoint provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpoint(ctx context.Context, params *ec2.ModifyVpcEndpointInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcEndpointOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointConnectionNotification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointConnectionNotification(ctx context.Context, params *ec2.ModifyVpcEndpointConnectionNotificationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcEndpointConnectionNotificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointConnectionNotificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointConnectionNotificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointConnectionNotificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointConnectionNotificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServiceConfiguration provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointServiceConfiguration(ctx context.Context, params *ec2.ModifyVpcEndpointServiceConfigurationInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcEndpointServiceConfigurationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServiceConfigurationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServiceConfigurationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServiceConfigurationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServiceConfigurationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServicePayerResponsibility provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointServicePayerResponsibility(ctx context.Context, params *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServicePayerResponsibilityOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePayerResponsibilityOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServicePayerResponsibilityInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcEndpointServicePermissions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcEndpointServicePermissions(ctx context.Context, params *ec2.ModifyVpcEndpointServicePermissionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcEndpointServicePermissionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcEndpointServicePermissionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcEndpointServicePermissionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcEndpointServicePermissionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcEndpointServicePermissionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcPeeringConnectionOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcPeeringConnectionOptions(ctx context.Context, params *ec2.ModifyVpcPeeringConnectionOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcPeeringConnectionOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpcPeeringConnectionOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpcPeeringConnectionOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcPeeringConnectionOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcPeeringConnectionOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpcTenancy provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpcTenancy(ctx context.Context, params *ec2.ModifyVpcTenancyInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpcTenancyOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) (*ec2.ModifyVpcTenancyOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) *ec2.ModifyVpcTenancyOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpcTenancyOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpcTenancyInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnConnection(ctx context.Context, params *ec2.ModifyVpnConnectionInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpnConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) *ec2.ModifyVpnConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnConnectionOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnConnectionOptions(ctx context.Context, params *ec2.ModifyVpnConnectionOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpnConnectionOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnConnectionOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpnConnectionOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnConnectionOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnConnectionOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnTunnelCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnTunnelCertificate(ctx context.Context, params *ec2.ModifyVpnTunnelCertificateInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpnTunnelCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) *ec2.ModifyVpnTunnelCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnTunnelCertificateInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyVpnTunnelOptions provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ModifyVpnTunnelOptions(ctx context.Context, params *ec2.ModifyVpnTunnelOptionsInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ModifyVpnTunnelOptionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) (*ec2.ModifyVpnTunnelOptionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) *ec2.ModifyVpnTunnelOptionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ModifyVpnTunnelOptionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ModifyVpnTunnelOptionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MonitorInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) MonitorInstances(ctx context.Context, params *ec2.MonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.MonitorInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) *ec2.MonitorInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MonitorInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MonitorInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveAddressToVpc provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) MoveAddressToVpc(ctx context.Context, params *ec2.MoveAddressToVpcInput, optFns ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.MoveAddressToVpcOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) (*ec2.MoveAddressToVpcOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) *ec2.MoveAddressToVpcOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveAddressToVpcOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveAddressToVpcInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MoveByoipCidrToIpam provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) MoveByoipCidrToIpam(ctx context.Context, params *ec2.MoveByoipCidrToIpamInput, optFns ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.MoveByoipCidrToIpamOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) (*ec2.MoveByoipCidrToIpamOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) *ec2.MoveByoipCidrToIpamOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.MoveByoipCidrToIpamOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.MoveByoipCidrToIpamInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ProvisionByoipCidr(ctx context.Context, params *ec2.ProvisionByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ProvisionByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) *ec2.ProvisionByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionIpamPoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ProvisionIpamPoolCidr(ctx context.Context, params *ec2.ProvisionIpamPoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ProvisionIpamPoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionIpamPoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) *ec2.ProvisionIpamPoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionIpamPoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionIpamPoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProvisionPublicIpv4PoolCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ProvisionPublicIpv4PoolCidr(ctx context.Context, params *ec2.ProvisionPublicIpv4PoolCidrInput, optFns ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ProvisionPublicIpv4PoolCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) (*ec2.ProvisionPublicIpv4PoolCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) *ec2.ProvisionPublicIpv4PoolCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ProvisionPublicIpv4PoolCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ProvisionPublicIpv4PoolCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseHostReservation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) PurchaseHostReservation(ctx context.Context, params *ec2.PurchaseHostReservationInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.PurchaseHostReservationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) (*ec2.PurchaseHostReservationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) *ec2.PurchaseHostReservationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseHostReservationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseHostReservationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseReservedInstancesOffering provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) PurchaseReservedInstancesOffering(ctx context.Context, params *ec2.PurchaseReservedInstancesOfferingInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.PurchaseReservedInstancesOfferingOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) (*ec2.PurchaseReservedInstancesOfferingOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) *ec2.PurchaseReservedInstancesOfferingOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseReservedInstancesOfferingOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseReservedInstancesOfferingInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurchaseScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) PurchaseScheduledInstances(ctx context.Context, params *ec2.PurchaseScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.PurchaseScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.PurchaseScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) *ec2.PurchaseScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.PurchaseScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.PurchaseScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RebootInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RebootInstances(ctx context.Context, params *ec2.RebootInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RebootInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) *ec2.RebootInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RebootInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RebootInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterImage provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterImage(ctx context.Context, params *ec2.RegisterImageInput, optFns ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RegisterImageOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) (*ec2.RegisterImageOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) *ec2.RegisterImageOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterImageOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterImageInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterInstanceEventNotificationAttributes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterInstanceEventNotificationAttributes(ctx context.Context, params *ec2.RegisterInstanceEventNotificationAttributesInput, optFns ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RegisterInstanceEventNotificationAttributesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) (*ec2.RegisterInstanceEventNotificationAttributesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) *ec2.RegisterInstanceEventNotificationAttributesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterInstanceEventNotificationAttributesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterInstanceEventNotificationAttributesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTransitGatewayMulticastGroupMembers provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterTransitGatewayMulticastGroupMembers(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupMembersInput, optFns ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RegisterTransitGatewayMulticastGroupMembersOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupMembersOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) *ec2.RegisterTransitGatewayMulticastGroupMembersOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupMembersOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupMembersInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterTransitGatewayMulticastGroupSources provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RegisterTransitGatewayMulticastGroupSources(ctx context.Context, params *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, optFns ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) (*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) *ec2.RegisterTransitGatewayMulticastGroupSourcesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RegisterTransitGatewayMulticastGroupSourcesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RegisterTransitGatewayMulticastGroupSourcesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayMulticastDomainAssociations provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectTransitGatewayMulticastDomainAssociations(ctx context.Context, params *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayMulticastDomainAssociationsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayMulticastDomainAssociationsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayMulticastDomainAssociationsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayPeeringAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectTransitGatewayPeeringAttachment(ctx context.Context, params *ec2.RejectTransitGatewayPeeringAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RejectTransitGatewayPeeringAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayPeeringAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayPeeringAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayPeeringAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayPeeringAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectTransitGatewayVpcAttachment provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectTransitGatewayVpcAttachment(ctx context.Context, params *ec2.RejectTransitGatewayVpcAttachmentInput, optFns ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RejectTransitGatewayVpcAttachmentOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) (*ec2.RejectTransitGatewayVpcAttachmentOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) *ec2.RejectTransitGatewayVpcAttachmentOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectTransitGatewayVpcAttachmentOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectTransitGatewayVpcAttachmentInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectVpcEndpointConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectVpcEndpointConnections(ctx context.Context, params *ec2.RejectVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RejectVpcEndpointConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) (*ec2.RejectVpcEndpointConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) *ec2.RejectVpcEndpointConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcEndpointConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectVpcEndpointConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectVpcPeeringConnection provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RejectVpcPeeringConnection(ctx context.Context, params *ec2.RejectVpcPeeringConnectionInput, optFns ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RejectVpcPeeringConnectionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) (*ec2.RejectVpcPeeringConnectionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) *ec2.RejectVpcPeeringConnectionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RejectVpcPeeringConnectionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RejectVpcPeeringConnectionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseAddress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReleaseAddress(ctx context.Context, params *ec2.ReleaseAddressInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReleaseAddressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) (*ec2.ReleaseAddressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) *ec2.ReleaseAddressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseAddressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseAddressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseHosts provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReleaseHosts(ctx context.Context, params *ec2.ReleaseHostsInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReleaseHostsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) (*ec2.ReleaseHostsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) *ec2.ReleaseHostsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseHostsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseHostsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseIpamPoolAllocation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReleaseIpamPoolAllocation(ctx context.Context, params *ec2.ReleaseIpamPoolAllocationInput, optFns ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReleaseIpamPoolAllocationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) (*ec2.ReleaseIpamPoolAllocationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) *ec2.ReleaseIpamPoolAllocationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReleaseIpamPoolAllocationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReleaseIpamPoolAllocationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceIamInstanceProfileAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceIamInstanceProfileAssociation(ctx context.Context, params *ec2.ReplaceIamInstanceProfileAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReplaceIamInstanceProfileAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceIamInstanceProfileAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceIamInstanceProfileAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceIamInstanceProfileAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceIamInstanceProfileAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceNetworkAclAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceNetworkAclAssociation(ctx context.Context, params *ec2.ReplaceNetworkAclAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReplaceNetworkAclAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceNetworkAclAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceNetworkAclAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceNetworkAclEntry provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceNetworkAclEntry(ctx context.Context, params *ec2.ReplaceNetworkAclEntryInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReplaceNetworkAclEntryOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) (*ec2.ReplaceNetworkAclEntryOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) *ec2.ReplaceNetworkAclEntryOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceNetworkAclEntryOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceNetworkAclEntryInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceRoute(ctx context.Context, params *ec2.ReplaceRouteInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReplaceRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) *ec2.ReplaceRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceRouteTableAssociation provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceRouteTableAssociation(ctx context.Context, params *ec2.ReplaceRouteTableAssociationInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReplaceRouteTableAssociationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) (*ec2.ReplaceRouteTableAssociationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) *ec2.ReplaceRouteTableAssociationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceRouteTableAssociationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceRouteTableAssociationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceTransitGatewayRoute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReplaceTransitGatewayRoute(ctx context.Context, params *ec2.ReplaceTransitGatewayRouteInput, optFns ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReplaceTransitGatewayRouteOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) (*ec2.ReplaceTransitGatewayRouteOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) *ec2.ReplaceTransitGatewayRouteOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReplaceTransitGatewayRouteOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReplaceTransitGatewayRouteInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReportInstanceStatus provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ReportInstanceStatus(ctx context.Context, params *ec2.ReportInstanceStatusInput, optFns ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ReportInstanceStatusOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) (*ec2.ReportInstanceStatusOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) *ec2.ReportInstanceStatusOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ReportInstanceStatusOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ReportInstanceStatusInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestSpotFleet provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RequestSpotFleet(ctx context.Context, params *ec2.RequestSpotFleetInput, optFns ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RequestSpotFleetOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) (*ec2.RequestSpotFleetOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) *ec2.RequestSpotFleetOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotFleetOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RequestSpotFleetInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestSpotInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RequestSpotInstances(ctx context.Context, params *ec2.RequestSpotInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RequestSpotInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) (*ec2.RequestSpotInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) *ec2.RequestSpotInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RequestSpotInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RequestSpotInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetAddressAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetAddressAttribute(ctx context.Context, params *ec2.ResetAddressAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetAddressAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) (*ec2.ResetAddressAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) *ec2.ResetAddressAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetAddressAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetAddressAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetEbsDefaultKmsKeyId provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetEbsDefaultKmsKeyId(ctx context.Context, params *ec2.ResetEbsDefaultKmsKeyIdInput, optFns ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetEbsDefaultKmsKeyIdOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) (*ec2.ResetEbsDefaultKmsKeyIdOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) *ec2.ResetEbsDefaultKmsKeyIdOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetEbsDefaultKmsKeyIdOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetEbsDefaultKmsKeyIdInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetFpgaImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetFpgaImageAttribute(ctx context.Context, params *ec2.ResetFpgaImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetFpgaImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetFpgaImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) *ec2.ResetFpgaImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetFpgaImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetFpgaImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetImageAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetImageAttribute(ctx context.Context, params *ec2.ResetImageAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetImageAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) (*ec2.ResetImageAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) *ec2.ResetImageAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetImageAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetImageAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetInstanceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetInstanceAttribute(ctx context.Context, params *ec2.ResetInstanceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetInstanceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetInstanceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) *ec2.ResetInstanceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetInstanceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetInstanceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetNetworkInterfaceAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetNetworkInterfaceAttribute(ctx context.Context, params *ec2.ResetNetworkInterfaceAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetNetworkInterfaceAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) (*ec2.ResetNetworkInterfaceAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) *ec2.ResetNetworkInterfaceAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetNetworkInterfaceAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetNetworkInterfaceAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetSnapshotAttribute provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) ResetSnapshotAttribute(ctx context.Context, params *ec2.ResetSnapshotAttributeInput, optFns ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.ResetSnapshotAttributeOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) (*ec2.ResetSnapshotAttributeOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) *ec2.ResetSnapshotAttributeOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.ResetSnapshotAttributeOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.ResetSnapshotAttributeInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreAddressToClassic provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreAddressToClassic(ctx context.Context, params *ec2.RestoreAddressToClassicInput, optFns ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RestoreAddressToClassicOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) (*ec2.RestoreAddressToClassicOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) *ec2.RestoreAddressToClassicOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreAddressToClassicOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreAddressToClassicInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreImageFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreImageFromRecycleBin(ctx context.Context, params *ec2.RestoreImageFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RestoreImageFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreImageFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreImageFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreImageFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreImageFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreManagedPrefixListVersion provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreManagedPrefixListVersion(ctx context.Context, params *ec2.RestoreManagedPrefixListVersionInput, optFns ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RestoreManagedPrefixListVersionOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) (*ec2.RestoreManagedPrefixListVersionOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) *ec2.RestoreManagedPrefixListVersionOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreManagedPrefixListVersionOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreManagedPrefixListVersionInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreSnapshotFromRecycleBin provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreSnapshotFromRecycleBin(ctx context.Context, params *ec2.RestoreSnapshotFromRecycleBinInput, optFns ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RestoreSnapshotFromRecycleBinOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotFromRecycleBinOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) *ec2.RestoreSnapshotFromRecycleBinOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreSnapshotFromRecycleBinOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreSnapshotFromRecycleBinInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreSnapshotTier provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RestoreSnapshotTier(ctx context.Context, params *ec2.RestoreSnapshotTierInput, optFns ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RestoreSnapshotTierOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) (*ec2.RestoreSnapshotTierOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) *ec2.RestoreSnapshotTierOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RestoreSnapshotTierOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RestoreSnapshotTierInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeClientVpnIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RevokeClientVpnIngress(ctx context.Context, params *ec2.RevokeClientVpnIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RevokeClientVpnIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) (*ec2.RevokeClientVpnIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) *ec2.RevokeClientVpnIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeClientVpnIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeClientVpnIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSecurityGroupEgress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RevokeSecurityGroupEgress(ctx context.Context, params *ec2.RevokeSecurityGroupEgressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RevokeSecurityGroupEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RevokeSecurityGroupIngress(ctx context.Context, params *ec2.RevokeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RevokeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RunInstances(ctx context.Context, params *ec2.RunInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RunInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) *ec2.RunInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RunInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunScheduledInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) RunScheduledInstances(ctx context.Context, params *ec2.RunScheduledInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.RunScheduledInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) (*ec2.RunScheduledInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) *ec2.RunScheduledInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RunScheduledInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RunScheduledInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchLocalGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SearchLocalGatewayRoutes(ctx context.Context, params *ec2.SearchLocalGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.SearchLocalGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchLocalGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) *ec2.SearchLocalGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchLocalGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchLocalGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTransitGatewayMulticastGroups provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SearchTransitGatewayMulticastGroups(ctx context.Context, params *ec2.SearchTransitGatewayMulticastGroupsInput, optFns ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.SearchTransitGatewayMulticastGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayMulticastGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) *ec2.SearchTransitGatewayMulticastGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayMulticastGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchTransitGatewayMulticastGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchTransitGatewayRoutes provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SearchTransitGatewayRoutes(ctx context.Context, params *ec2.SearchTransitGatewayRoutesInput, optFns ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.SearchTransitGatewayRoutesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) (*ec2.SearchTransitGatewayRoutesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) *ec2.SearchTransitGatewayRoutesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SearchTransitGatewayRoutesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SearchTransitGatewayRoutesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendDiagnosticInterrupt provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) SendDiagnosticInterrupt(ctx context.Context, params *ec2.SendDiagnosticInterruptInput, optFns ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.SendDiagnosticInterruptOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) (*ec2.SendDiagnosticInterruptOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) *ec2.SendDiagnosticInterruptOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.SendDiagnosticInterruptOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.SendDiagnosticInterruptInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartInstances(ctx context.Context, params *ec2.StartInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.StartInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) *ec2.StartInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartNetworkInsightsAccessScopeAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartNetworkInsightsAccessScopeAnalysis(ctx context.Context, params *ec2.StartNetworkInsightsAccessScopeAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.StartNetworkInsightsAccessScopeAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAccessScopeAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) *ec2.StartNetworkInsightsAccessScopeAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartNetworkInsightsAccessScopeAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartNetworkInsightsAccessScopeAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartNetworkInsightsAnalysis provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartNetworkInsightsAnalysis(ctx context.Context, params *ec2.StartNetworkInsightsAnalysisInput, optFns ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.StartNetworkInsightsAnalysisOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) (*ec2.StartNetworkInsightsAnalysisOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) *ec2.StartNetworkInsightsAnalysisOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartNetworkInsightsAnalysisOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartNetworkInsightsAnalysisInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartVpcEndpointServicePrivateDnsVerification provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StartVpcEndpointServicePrivateDnsVerification(ctx context.Context, params *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, optFns ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) (*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) *ec2.StartVpcEndpointServicePrivateDnsVerificationOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StartVpcEndpointServicePrivateDnsVerificationOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StartVpcEndpointServicePrivateDnsVerificationInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) StopInstances(ctx context.Context, params *ec2.StopInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.StopInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) *ec2.StopInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.StopInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.StopInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateClientVpnConnections provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) TerminateClientVpnConnections(ctx context.Context, params *ec2.TerminateClientVpnConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.TerminateClientVpnConnectionsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) (*ec2.TerminateClientVpnConnectionsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) *ec2.TerminateClientVpnConnectionsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateClientVpnConnectionsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.TerminateClientVpnConnectionsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TerminateInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) TerminateInstances(ctx context.Context, params *ec2.TerminateInstancesInput, optFns ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.TerminateInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) *ec2.TerminateInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.TerminateInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.TerminateInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignIpv6Addresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UnassignIpv6Addresses(ctx context.Context, params *ec2.UnassignIpv6AddressesInput, optFns ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.UnassignIpv6AddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) (*ec2.UnassignIpv6AddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) *ec2.UnassignIpv6AddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignIpv6AddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignIpv6AddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnassignPrivateIpAddresses provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UnassignPrivateIpAddresses(ctx context.Context, params *ec2.UnassignPrivateIpAddressesInput, optFns ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.UnassignPrivateIpAddressesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) (*ec2.UnassignPrivateIpAddressesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) *ec2.UnassignPrivateIpAddressesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnassignPrivateIpAddressesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnassignPrivateIpAddressesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnmonitorInstances provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UnmonitorInstances(ctx context.Context, params *ec2.UnmonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.UnmonitorInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) *ec2.UnmonitorInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UnmonitorInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UnmonitorInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroupRuleDescriptionsEgress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UpdateSecurityGroupRuleDescriptionsEgress(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, optFns ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) *ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsEgressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsEgressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSecurityGroupRuleDescriptionsIngress provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) UpdateSecurityGroupRuleDescriptionsIngress(ctx context.Context, params *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, optFns ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) (*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) *ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.UpdateSecurityGroupRuleDescriptionsIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.UpdateSecurityGroupRuleDescriptionsIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawByoipCidr provides a mock function with given fields: ctx, params, optFns
func (_m *EC2) WithdrawByoipCidr(ctx context.Context, params *ec2.WithdrawByoipCidrInput, optFns ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *ec2.WithdrawByoipCidrOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) (*ec2.WithdrawByoipCidrOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) *ec2.WithdrawByoipCidrOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.WithdrawByoipCidrOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.WithdrawByoipCidrInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewEC2 creates a new instance of EC2. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEC2(t interface {
	mock.TestingT
	Cleanup(func())
}) *EC2 {
	mock := &EC2{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
